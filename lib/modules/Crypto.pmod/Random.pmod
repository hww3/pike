#pike __REAL_VERSION__
// $Id: Random.pmod,v 1.3 2004/02/02 16:27:05 nilsson Exp $

//! This module contains stuff to that tries to give you the
//! best possible random generation.

#if constant(Nettle.Yarrow)

static class RND {
  inherit Nettle.Yarrow;
  static int bytes_left = 32;

#if constant(Crypto.nt)
  static object ctx;
#else
  static Stdio.File f;
#endif

  static int last_tick;
  static function ticker;

  static void create(int(0..1) no_block) {
    // Source 0: /dev/random or CryptGenRandom
    // Source 1: ticker
    // Source 2: external
    ::create(3);
#if constant(Crypto.nt)
    ctx = Crypto.nt.CryptAcquireContext(0, 0, Crypto.nt.PROV_RSA_FULL,
					Crypto.nt.CRYPT_VERIFYCONTEXT );
    seed( ctx->CryptGenRandom(min_seed_size()*2) );
#else
    if(no_block)
      f = Stdio.File("/dev/urandom", "r");
    else
      f = Stdio.File("/dev/random", "r");
    if(!f)
      error("No entropy source found.\n");
    seed( f->read(min_seed_size()*2) );
#endif
#if constant(System.rdtsc)
    ticker = System.rdtsc;
#elif constant(gethrtime)
    ticker = gethrtime;
#else
    ticker = time;
#endif
  }

  string random_string(int len) {
    String.Buffer buf = String.Buffer(len);
    int new_tick = ticker();
    update( (string)(new_tick-last_tick), 1, 1 );
    last_tick = new_tick;

    while(len) {
      int pass = min(len, bytes_left);
      buf->add( ::random_string(pass) );
      bytes_left -= pass;
      len -= pass;
      if(!bytes_left) {
#if constant(Crypto.nt)
	// CryptGenRandom claims to be cryptographically strong.
	update( ctx->CryptGenRandom(32), 0, 256 );
#else
	// Only trust 50% randomness.
	update( f->read(64), 0, 256 );
#endif
	bytes_left = 32;
      }
    }
    return (string)buf;
  }
}

static string rnd_bootstrap(int len) {
  rnd_obj = RND(1);
  rnd_func = rnd_obj->random_string;
  return rnd_func(len);
}

static RND rnd_obj;
static function(int:string) rnd_func = rnd_bootstrap;

static string rnd_block_bootstrap(int len) {
  rnd_block_obj = RND(0);
  rnd_block_func = rnd_block_obj->random_string;
  return rnd_block_func(len);
}

static RND rnd_block_obj;
static function(int:string) rnd_block_func = rnd_block_bootstrap;


//! Returns a string of length @[len] with random content. The
//! content is generated by a Yarrow random generator that is
//! constantly updated with output from /dev/random on UNIX and
//! CryptGenRandom on NT. The Yarrow random generator is fed
//! at least the amount of random data from its sources as it
//! outputs, thus doing its best to give at least good pseudo-
//! random data on operating systems with bad /dev/random.
string random_string(int len) {
  return rnd_func(len);
}

//! Returns a @[Gmp.mpz] object with a random value between @expr{0@}
//! and @[top]. Uses @[random_string].
Gmp.mpz random(int top) {
  return Gmp.mpz(rnd_func( (int)ceil( log((float)top)/log(2.0) ) ),
		 256) % top;
}

//! Works as @[random_string], but may block in order to gather
//! enough entropy to make a truely random output.
string blocking_random_string(int len) {
  return rnd_block_func(len);
}

//! Inject additional entropy into the random generator.
//! @param data
//!   The random string.
//! @param entropy
//!   The number of bits in the random string that is
//!   truely random.
void add_entropy(string data, int entropy) {
  if(rnd_obj)
    rnd_obj->update(data, 2, entropy);
  if(rnd_block_obj)
    rnd_block_obj->update(data, 2, entropy);
}

#endif
