string describe_backtrace(mixed *trace);

/* This function is called when an error occurs that is not caught
 * with catch(). It's argument consists of:
 * ({ error_string, backtrace }) where backtrace is the output from the
 * backtrace() efun.
 */
void handle_error(mixed *trace)
{
  efun::trace(0);
//  perror(sprintf("trace=%O\n",trace));
  perror(describe_backtrace(trace));
}

/* Note that create is called before add_precompiled_program
 */
void create()
{
  /* make ourselves known */
  add_efun("describe_backtrace",describe_backtrace);
  add_efun("master",lambda() { return this_object(); });
}

mapping (string:program) programs=([]);

/* This function is called whenever a module has built a clonable program
 * with functions written in C and wants to notify the LPC part about
 * this. It also supplies a suggested name for the program.
 */
void add_precompiled_program(string name, program p)
{
//  perror("Precompiled: "+name+"\n");
  programs[name]=p;
//  perror(sprintf("programs =\n%O\n",programs));
}

/* This function is called when the driver wants to cast a string
 * to a program, this might be because of an explicit cast, an inherit
 * or a implict cast. In the future it might receive more arguments,
 * to aid the master finding the right program.
 */
program cast_to_program(string pname)
{
  program ret;
  if(pname[0]!='/')
    pname=combine_path(getcwd(),pname);

  if(pname[sizeof(pname)-3..sizeof(pname)]==".lpc")
    pname=pname[0..sizeof(pname)-4];

//  perror("Searching for "+pname+"\n");
//  perror(sprintf("in %O\n",programs));
  if(ret=programs[pname]) return ret;
  
//  perror("Didn't find it\n");

  if(file_stat(pname))
    ret=compile_file(pname);
  else
    ret=compile_file(pname+".lpc");
  return programs[pname]=ret;
}

/*
 * This function is called whenever a inherit is called for.
 * It is supposed to return the program to inherit.
 * The first argument is the argument given to inherit, and the second
 * is the file name of the program currently compiling. Note that the
 * file name can be changed with #line, or set by compile_string, so
 * it can not be 100% trusted to be a filename.
 * previous_object(), can be virtually anything in this function, as it
 * is called from the compiler.
 */
program handle_inherit(string pname, string current_file)
{
  program p;
  string *tmp;
  p=cast_to_program(pname);
  if(p) return p;
  tmp=explode(current_file,"/");
  tmp[-1]=pname;
  return cast_to_program(implode(tmp,"/"));
}

mapping (string:object) objects=(["/master.lpc":this_object()]);

/* This function is called when the drivers wants to cast a string
 * to an object because of an implict or explicit cast. This function
 * may also receive more arguments in the future.
 */
object cast_to_object(string oname)
{
  object ret;

  if(oname[0]=='/')
    oname=combine_path(getcwd(),oname);

  if(oname[sizeof(oname)-3..sizeof(oname)]==".lpc")
    oname=oname[0..sizeof(oname)-4];

  if(ret=objects[oname]) return ret;

  return objects[oname]=clone(cast_to_program(oname));
}

mapping (string:string) environment=([]);

varargs mixed getenv(string s)
{
  if(!s) return environment;
  return environment[s];
}

/* This function is called when all the driver is done with all setup
 * of modules, efuns, tables etc. etc. and is ready to start executing
 * _real_ programs. It receives the arguments not meant for the driver
 * and an array containing the environment variables on the same form as
 * a C program receives them.
 */
void _main(string *argv, string *env)
{
  int i;
  object script;
  string a,b;
  string *q;

  foreach(env,a) if(sscanf(a,"%s=%s",a,b)) environment[a]=b;
  add_efun("getenv",getenv);

  add_efun("write",clone(cast_to_program("/precompiled/file"),"stdout")->write);

//  terminal->set_nonblocking(test,0,0);
//  write("Gurka.\n");
//  return;

//  script=clone((program)"/precompiled/file");
//  script->popen(({"ls"}));
//  write(script->read(10000000));

//  script->close();

//  perror(sprintf("%O\n",backtrace()[-1]));
  a=backtrace()[-1][0];
  q=a/"/";
  q[-1]="simulate.lpc";
//  perror(sprintf("%O\n",q));
//  perror(sprintf("%O\n",q*"/"));
  clone(compile_file(q*"/"));

//  perror(sprintf("All efuns:\n%O\n",all_efuns()));

  if(!sizeof(argv))
  {
    perror("Usage: ulpc [-driver options] script [script arguments]\n");
    exit(1);
  }
  script=(object)argv[0];

  i=script->main(sizeof(argv),argv,env);
  if(i >=0) exit(i);
}

int inhibit_compile_errors;

void set_inhibit_compile_errors(int i)
{
  inhibit_compile_errors=i;
}

/*
 * This function is called whenever a compiling error occurs,
 * Nothing strange about it.
 * Note that previous_object cannot be trusted in ths function, because
 * the compiler calls this function.
 */
void compile_error(string file,int line,string err)
{
  if(!inhibit_compile_errors)
    perror(sprintf("%s:%d:%s\n",file,line,err));
}

/* This function is called whenever an #include directive is encountered
 * it receives the argument for #include and should return the file name
 * of the file to include
 * Note that previous_object cannot be trusted in ths function, because
 * the compiler calls this function.
 */
string handle_include(string f, string current_file)
{
  string *tmp, path;
/*  perror("Handle include: "+f+"\n"); */

  tmp=explode(current_file, "/");
  tmp[-1]=f;
  path=combine_path(getcwd(),implode(tmp,"/"));
  if(file_stat(path)) return path;
  
  if(path=getenv("LPC_INCLUDE_PATH"))
  {
    foreach(explode(path,":"), path)
    {
      path=combine_path(path,f);
      if(file_stat(path)) return path;
    }
  }
  return 0;
}

/* It is possible that this should be a real efun,
 * it is currently used by handle_error to convert a backtrace to a
 * readable message.
 */
string describe_backtrace(mixed *trace)
{
  int e;
  string ret;

  if(arrayp(trace) && sizeof(trace)==2 && stringp(trace[0]))
  {
    ret=trace[0];
    trace=trace[1];
  }else{
    ret="";
  }

  if(!arrayp(trace))
  {
    ret+="No backtrace.\n";
  }else{
    for(e=0;e<sizeof(trace);e++)
    {
      mixed *tmp;
      string row;

      tmp=trace[e];
      if(stringp(tmp))
      {
	row=tmp;
      }
      else if(arrayp(tmp))
      {
	row="";
	if(sizeof(tmp)>=3 && functionp(tmp[2]))
	{
	  row=function_name(tmp[2])+" in ";
	}

	if(sizeof(tmp)>=2 && stringp(tmp[0]) && intp(tmp[1]))
	{
	  row+="line "+tmp[1]+" in "+tmp[0];
	}else{
	  row+="Unknown program";
	}
      }
      else
      {
	row="Destructed object";
      }
      ret+=row+"\n";
    }
  }

  return ret;
}

