#!/bin/sh

# Notes about limitations in SysV sed:
#
#  o The *-operator only operates on single character regexps.
#  o The |-operator does not exist.
#  o Labels are only terminated by newline (ie ; does not terminate
#    a label).
#  o Character ranges may not contain literal newlines.

sed -e '
  # First convert #line directives.
  s/^# \([0-9]* "[^"]*"\).*$/#line \1/
  s/^# \([0-9]*\).*$/#line \1/
  t

  # Output all complete OPCODE[0-9].* --- expressions
  # accumulated so far.
: loop
  /OPCODE[0-9]/!b keepnl

  # Stupid IRIX cpp turns --- into -- -
  # SysV sed does not support multi-character *-expressions,
  # so we use % instead.
  s/ -- \{0,1\}- / ½ /g

  # Make sure the substitute flag is cleared.
  t loop

  h
  s/^[^½]*\(OPCODE[0-9][^½]*\) ½.*$/\1¤/p
  t more
  N
  b loop

  # Remove the match from the hold space,
  # and check for more.
: more
  g
  s/^[^½]*OPCODE[0-9][^½]* ½\(.*\)$/\1/
  b loop

  # Keep only the newlines.
: keepnl
  s/.//g' | sed -e '
  # Remove newlines that were inserted by p.
: loop
  /¤$/{
    N
    s/¤\n//
    b loop
  }
  # Add empty lines to hold, and start the next cycle.
  /^[ 	]*$/{
    # We are only interrested in the newline...
    s/.//g
    H
    d
  }
  # Clear hold, and put #line directives there,
  # and start the next cycle.
  /^#line/{
    h
    d
  }

  # Print hold except for a possible initial newline.
  x
  s/^\n//
  p

  # Clear hold.
  s/.//g
  s/\n//g
  x'
