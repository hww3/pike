define(MATRIX_EQUAL,[[
  (max(@map(Array.flatten( (array) (($1)-($2)) ),abs))<1e-5)
]])

define(MATRIX_CONVOLVE_TEST,[[
test_any([[
      Math.Matrix a=]]$1[[;
      Math.Matrix b=]]$2[[;
      Math.Matrix r=]]$3[[;
      Math.Matrix r1=a->convolve(b);					
      Math.Matrix r2=b->convolve(a);					
      if (!]]MATRIX_EQUAL(r1,r2)[[)					
	 error("convolving \na=%O,\nb=%O\n"				
	       "gave different results depending on order:\n"		
	       "a->convolve(b):\n%O\n"					
	       "b->convolve(a):\n%O\n"					
	       "expected:\n%O\n",					
	       a,b,r1,r2,r);						
      if (!]]MATRIX_EQUAL(r1,r)[[)					
	 error("convolving \n%O,\n%O\n"					
	       "gave erranous result,\n%O,\nexpected\n%O\n",		
	       a,b,r1,r);						
      return 1;
  ]],1)
]])

   
MATRIX_CONVOLVE_TEST(
   Math.Matrix( ({0,0,0, 0,1,0, 0,0,0})/3 ),
   Math.Matrix( ({0,0,0, 0,1,0, 0,0,0})/3 ),
   Math.Matrix( ({ ({ 0, 0, 0, 0, 0}),
                   ({ 0, 0, 0, 0, 0}),
                   ({ 0, 0, 1, 0, 0}),
                   ({ 0, 0, 0, 0, 0}),
                   ({ 0, 0, 0, 0, 0}) }) )
            );

MATRIX_CONVOLVE_TEST(
   Math.Matrix( ({1,1,1, 1,1,1, 1,1,1})/3 ),
   Math.Matrix( ({1,1,1, 1,1,1, 1,1,1})/3 ),
   Math.Matrix( ({ ({      1,      2,      3,      2,      1}),
                   ({      2,      4,      6,      4,      2}),
                   ({      3,      6,      9,      6,      3}),
                   ({      2,      4,      6,      4,      2}),
                   ({      1,      2,      3,      2,      1}) }) )
    );

MATRIX_CONVOLVE_TEST(
   Math.Matrix( ({1,2,3,4})/2 ),
   Math.Matrix( ({11,12,13,14})/2 ),
   Math.Matrix( ({ ({     11,     34,     24}),
                   ({     46,    120,     76}),
                   ({     39,     94,     56}) }) )
                     );

MATRIX_CONVOLVE_TEST(
   Math.Matrix( ({1}) ),
   Math.Matrix( ({1}) ),
   Math.Matrix( ({1}) )
                     );

MATRIX_CONVOLVE_TEST(
   Math.Matrix( ({1}) ),
   Math.Matrix( ({-1,1,2}) ),
   Math.Matrix( ({-1,1,2}) )
                     );
MATRIX_CONVOLVE_TEST(
   Math.Matrix( ({1}) ),
   Math.Matrix( ({-1,1,2})/1 ),
   Math.Matrix( ({-1,1,2})/1 )
                     );

MATRIX_CONVOLVE_TEST(
   Math.Matrix( ({1,2,3,4})/2 ),
   Math.Matrix( ({10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25})/4 ),
   Math.Matrix( ({ ({     10,     31,     34,     37,     26}), 
                   ({     44,    116,    126,    136,     86}), 
                   ({     60,    156,    166,    176,    110}), 
                   ({     76,    196,    206,    216,    134}), 
                   ({     66,    157,    164,    171,    100}) }) )
                     );
MATRIX_CONVOLVE_TEST(
   Math.Matrix( ({1,2,3,4})/2 ),
   Math.Matrix( ({10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25})/2 ),
   Math.Matrix( ({ ({     10,     31,     22}), 
                   ({     42,    110,     70}), 
                   ({     50,    130,     82}), 
                   ({     58,    150,     94}), 
                   ({     66,    170,    106}), 
                   ({     74,    190,    118}), 
                   ({     82,    210,    130}), 
                   ({     90,    230,    142}), 
                   ({     72,    171,    100}) }) )
                     );

// Inf
test_true([[Math.inf>0.0]])
test_true( Math.inf == Math.inf )
test_false( Math.inf != Math.inf )
test_true([[(Math.inf/2)==Math.inf]])
// -Inf
test_true([[-Math.inf<0.0]])
test_true( -Math.inf == -Math.inf )
test_false( -Math.inf != -Math.inf )
test_true([[(-Math.inf/2)==-Math.inf]])
test_false( Math.inf == -Math.inf )
test_true( Math.inf != -Math.inf )
// NaN
test_false([[Math.nan>0.0]])
test_false([[Math.nan<0.0]])
test_false([[Math.nan==0.0]])
test_true([[Math.nan!=0.0]])
// -NaN
test_false([[-Math.nan>0.0]])
test_false([[-Math.nan<0.0]])
test_false([[-Math.nan==0.0]])
test_true([[-Math.nan!=0.0]])
test_false( Math.nan == Math.nan )
test_true( Math.nan != Math.nan )

dnl Floating point comparison.
define([[test_approx]], [[
  test_eq(`<=(-0.0000001, ($1) - ($2), 0.0000001), 1)
]])

test_approx(Math.Angle(45, "deg")->degree(), 45)
test_approx(Math.Angle(45, "deg")->rad(), 0.25*Math.pi)
test_approx(Math.Angle(45, "deg")->gon(), 50.0)
test_approx(Math.Angle(45, "deg")->streck(), 787.5)
test_approx(Math.Angle(361, "deg")->degree(), 1)
test_approx(Math.Angle(45, "deg")->clone_me()->gon(), 50.0)

dnl convert_angle 1-1 test
define([[test_convert]], [[
  test_approx(Math.convert_angle(Math.convert_angle($1, $2, $3), $3, $2), $1)
]])

test_convert(90, "deg", "rad")
test_convert(90, "rad", "gon")
test_convert(90, "gon", "str")
test_convert(90, "str", "deg")
