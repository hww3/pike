// -*- Pike -*-

#pike __REAL_VERSION__
//! @ignore
static private inherit @module@;
//! @endignore

//! @appears Locale.Charset
//! The Charset module supports a wide variety of different character sets, and it is
//! flexible in regard of the names of character sets it accepts. The character case
//! is ignored, as are the most common non-alaphanumeric characters appearing in character set
//! names. E.g. @tt{"iso-8859-1"@} works just as good as @tt{"ISO_8859_1"@}.
//!
//! First of all the Charset module is capable of handling the following encodings of
//! Unicode.
//! @xml{
//! <matrix>
//! <r><c>utf7</c></r>
//! <r><c>utf8</c></r>
//! <r><c>utf16</c></r>
//! <r><c>utf16be</c></r>
//! <r><c>utf16le</c></r>
//! <r><c>utf75</c></r>
//! <r><c>utf7½</c></r>
//! </matrix>
//! @}
//!
//! @xml{
//! <matrix>
//! <r><c>shifjis</c></r>
//! <r><c>euc-kr</c></r>
//! <r><c>euc-cn</c></r>
//! <r><c>euc-jp</c></r>
//! </matrix>
//! @}
//!
//! Most, if not all, of the relevant code pages are represented, as the following list
//! shows. These may be prefixed with @tt{"cp"@} or @tt{"ibm"@}. Code pages from 1250 and
//! up may be prefixed with @tt{"windows"@}.
//! @xml{
//! <matrix>
//! <r><c>037</c></r>
//! <r><c>038</c></r>
//! <r><c>273</c></r>
//! <r><c>274</c></r>
//! <r><c>275</c></r>
//! <r><c>277</c></r>
//! <r><c>278</c></r>
//! <r><c>280</c></r>
//! <r><c>281</c></r>
//! <r><c>284</c></r>
//! <r><c>285</c></r>
//! <r><c>290</c></r>
//! <r><c>297</c></r>
//! <r><c>367</c></r>
//! <r><c>420</c></r>
//! <r><c>423</c></r>
//! <r><c>424</c></r>
//! <r><c>437</c></r>
//! <r><c>500</c></r>
//! <r><c>819</c></r>
//! <r><c>850</c></r>
//! <r><c>851</c></r>
//! <r><c>852</c></r>
//! <r><c>855</c></r>
//! <r><c>857</c></r>
//! <r><c>860</c></r>
//! <r><c>861</c></r>
//! <r><c>862</c></r>
//! <r><c>863</c></r>
//! <r><c>864</c></r>
//! <r><c>865</c></r>
//! <r><c>866</c></r>
//! <r><c>868</c></r>
//! <r><c>869</c></r>
//! <r><c>870</c></r>
//! <r><c>871</c></r>
//! <r><c>880</c></r>
//! <r><c>891</c></r>
//! <r><c>903</c></r>
//! <r><c>904</c></r>
//! <r><c>905</c></r>
//! <r><c>918</c></r>
//! <r><c>950</c></r>
//! <r><c>1026</c></r>
//! <r><c>1250</c></r>
//! <r><c>1251</c></r>
//! <r><c>1252</c></r>
//! <r><c>1253</c></r>
//! <r><c>1254</c></r>
//! <r><c>1255</c></r>
//! <r><c>1256</c></r>
//! <r><c>1257</c></r>
//! <r><c>1258</c></r>
//! </matrix>
//! @}
//!
//! +359 more.

class ascii {
  static private string s = "";
  object(this_program) feed(string ss)
  {
    s += ss;
    return this_object();
  }
  string drain()
  {
    string ss = s;
    s = "";
    return ss;
  }
  object(this_program) clear()
  {
    s = "";
    return this_object();
  }
}

private class UTF16dec {
  inherit ascii;
  static int check_bom=1, le=0;
  string drain() {
    string s = ::drain();
    if(sizeof(s)&1) {
      feed(s[sizeof(s)-1..]);
      s = s[..sizeof(s)-2];
    }
    if(check_bom && sizeof(s))
      switch(s[..1]) {
       case "\xfe\xff":
       case "\xff\xfe":
	 le=(s[0]==0xff);
	 s=s[2..];
       default:
	 check_bom=0;
      }
    if(le)
      s = map(s/2, reverse)*"";
    return unicode_to_string(s);
  }
}

private class UTF16LEdec {
  inherit UTF16dec;
  static void create() { le=1; }
}

private string normalize(string in) {
  if(!in) return 0;
  string out = replace(lower_case(in),
		      ({ "_",".",":","-","(",")" }),
		      ({ "","","","","","" }));

  if( (out=="isoir91" || out=="isoir92") && in[-2]!='9')
    out = sprintf("%s-%c", out[..sizeof(out)-2], out[-1]);

  if(sscanf(out, "cp%*d")) out = out[2..];
  if(sscanf(out, "ibm%*d")) out = out[3..];
  return out;
}

//! Returns a charset decoder object.
//! @param name
//!   The name of the character set to decode from. Supported charsets
//!   include (not all supported charsets are enumerable):
//!   "iso_8859-1:1987", "iso_8859-1:1998", "iso-8859-1", "iso-ir-100",
//!   "latin1", "l1", "ansi_x3.4-1968", "iso_646.irv:1991", "iso646-us",
//!   "iso-ir-6", "us", "us-ascii", "ascii", "cp367", "ibm367", "cp819",
//!   "ibm819", "iso-2022" (of various kinds), "utf-7", "utf-8" and
//!   various encodings as described by RFC1345.
//! @throws
//!   If the asked-for @[name] was not supported, an error is thrown.
object(ascii) decoder(string name)
{
  name = normalize(name);
  if(!name || (<
    "iso885911987", "iso885911998", "iso88591", "isoir100",
    "latin1", "l1", "ansix341968", "iso646irv1991", "iso646us",
    "isoir6", "us", "usascii", "ascii", "367", "819">)[name])
    return ascii();

  if(has_prefix(name, "iso2022"))
    return ISO2022Dec();

  program p = ([
    "utf7": UTF7dec,
    "utf8": UTF8dec,
    "utf16": UTF16dec,
    "utf16be": UTF16dec,
    "utf16le": UTF16LEdec,
    "utf75": UTF7_5dec,
    "utf7½": UTF7_5dec,
    "shiftjis": ShiftJisDec,
  ])[name];

  if(p)
    return p();

  if(has_prefix(name, "euc")) {
    string sub = ([
      "kr":"korean",
      "jp":"x0208",
      "cn":"chinese",
    ])[name[3..]];

    if(sub)
      return EUCDec(sub);
  }

  object o = rfc1345(name);

  if(o)
    return o;

  throw(({"Unknown character encoding "+name+"\n", backtrace()}));
}

class _encoder
{
  static string s = "";
  static string|void replacement;
  static function(string:string)|void repcb;
  static string low_convert(string s, string|void r,
			     function(string:string)|void rc)
  {
    int i = strlen(s);
    string rr;
    while(--i>=0)
      if(s[i]>255)
	if(rc && (rr = rc(s[i..i])))
	  s=s[..i-1]+low_convert(rr,r)+s[i+1..];
	else if(r)
	  s=s[..i-1]+low_convert(r)+s[i+1..];
	else
	  throw(({"Character unsupported by encoding.\n", backtrace()}));
    return s;
  }
  object(this_program) feed(string ss)
  {
    s += low_convert(ss, replacement, repcb);
    return this_object();
  }
  string drain()
  {
    string ss = s;
    s = "";
    return ss;
  }
  object(this_program) clear()
  {
    s = "";
    return this_object();
  }
  void set_replacement_callback(function(string:string) rc)
  {
    repcb = rc;
  }
  static void create(string|void r, string|void rc)
  {
    replacement = r;
    repcb = rc;
  }
}

private class UTF16enc {
  inherit _encoder;
  static private string low_convert(string s, string|void r,
				    function(string:string)|void rc)
  {
    int i = strlen(s);
    string rr;
    while(--i>=0)
      if(s[i]>0x10ffff)
	if(rc && (rr = rc(s[i..i])))
	  s=s[..i-1]+low_convert(rr,r)+s[i+1..];
	else if(r)
	  s=s[..i-1]+low_convert(r)+s[i+1..];
	else
	  throw(({"Character unsupported by encoding.\n", backtrace()}));
    return s;
  }
  object(this_program) feed(string ss) {
    s += ss;
    return this_object();
  }
  string drain() {
    string ss = s;
    s = "";
    catch {
      return string_to_unicode(ss);
    };
    ss = low_convert(ss, replacement, repcb);
    return string_to_unicode(ss);
  }
}

private class UTF16LEenc {
  inherit UTF16enc;
  string drain() {
    return map(::drain()/2, reverse)*"";
  }
}

//! Returns a charset encoder object.
//! @param name
//!   The name of the character set to decode from. Supported charsets
//!   include (not all supported charsets are enumerable):
//!   "iso_8859-1:1987", "iso_8859-1:1998", "iso-8859-1", "iso-ir-100",
//!   "latin1", "l1", "ansi_x3.4-1968", "iso_646.irv:1991", "iso646-us",
//!   "iso-ir-6", "us", "us-ascii", "ascii", "cp367", "ibm367", "cp819",
//!   "ibm819", "iso-2022" (of various kinds), "utf-7", "utf-8" and
//!   various encodings as described by RFC1345.
//! @throws
//!   If the asked-for @[name] was not supported, an error is thrown.
object(_encoder) encoder(string name, string|void replacement,
			 function(string:string)|void repcb)
{
  name = normalize(name);
  if(!name || (<
    "iso885911987", "iso885911998", "iso88591", "isoir100",
    "latin1", "l1", "ansix341968", "iso646irv1991", "iso646us",
    "isoir6", "us", "usascii", "ascii", "367", "819">)[name])
    return _encoder(replacement, repcb);

  if(has_prefix(name, "iso2022"))
    return ISO2022Enc(replacement, repcb);

  program p = ([
    "utf7": UTF7enc,
    "utf8": UTF8enc,
    "utf16": UTF16enc,
    "utf16be": UTF16enc,
    "utf16le": UTF16LEenc,
    "utf7.5": UTF7_5enc,
    "utf7½": UTF7_5enc,
    "shiftjis": ShiftJisEnc,
  ])[name];

  if(p)
    return p(replacement, repcb);

  if(has_prefix(name, "euc")) {
    string sub = ([
      "kr":"korean",
      "jp":"x0208",
      "cn":"chinese",
    ])[name[3..]];

    if(sub)
      return EUCEnc(sub, replacement, repcb);
  }

  object o = rfc1345(name, 1, replacement, repcb);

  if(o)
    return o;

  error("Unknown character encoding "+name+"\n");
}
