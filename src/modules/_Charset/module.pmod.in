// -*- Pike -*-

#pike __REAL_VERSION__
//! @ignore
static private inherit @module@;
//! @endignore

//! @appears Locale.Charset

class ascii {
  static private string s = "";
  object(this_program) feed(string ss)
  {
    s += ss;
    return this_object();
  }
  string drain()
  {
    string ss = s;
    s = "";
    return ss;
  }
  object(this_program) clear()
  {
    s = "";
    return this_object();
  }
}

private class UTF16dec {
  inherit ascii;
  static int check_bom=1, le=0;
  string drain() {
    string s = ::drain();
    if(sizeof(s)&1) {
      feed(s[sizeof(s)-1..]);
      s = s[..sizeof(s)-2];
    }
    if(check_bom && sizeof(s))
      switch(s[..1]) {
       case "\xfe\xff":
       case "\xff\xfe":
	 le=(s[0]==0xff);
	 s=s[2..];
       default:
	 check_bom=0;
      }
    if(le)
      s = map(s/2, reverse)*"";
    return unicode_to_string(s);
  }
}

private class UTF16LEdec {
  inherit UTF16dec;
  static void create() { le=1; }
}

private string normalize(string in) {
  if(!in) return 0;
  string out = replace(lower_case(in),
		      ({ "_",".",":","-","(",")" }),
		      ({ "","","","","","" }));

  if( (out=="isoir91" || out=="isoir92") && in[-2]!='9')
    out = sprintf("%s-%c", out[..sizeof(out)-2], out[-1]);

  if(sscanf(out, "cp%*d")) out = out[2..];
  if(sscanf(out, "ibm%*d")) out = out[3..];
  return out;
}

//! Returns a charset decoder object.
//! @param name
//!   The name of the character set to decode from. Supported charsets
//!   include (not all supported charsets are enumerable):
//!   "iso_8859-1:1987", "iso_8859-1:1998", "iso-8859-1", "iso-ir-100",
//!   "latin1", "l1", "ansi_x3.4-1968", "iso_646.irv:1991", "iso646-us",
//!   "iso-ir-6", "us", "us-ascii", "ascii", "cp367", "ibm367", "cp819",
//!   "ibm819", "iso-2022" (of various kinds), "utf-7", "utf-8" and
//!   various encodings as described by RFC1345.
//! @throws
//!   If the asked-for @[name] was not supported, an error is thrown.
object(ascii) decoder(string name)
{
  name = normalize(name);
  if(!name || (<
    "iso885911987", "iso885911998", "iso88591", "isoir100",
    "latin1", "l1", "ansix341968", "iso646irv1991", "iso646us",
    "isoir6", "us", "usascii", "ascii", "367", "819">)[name])
    return ascii();

  if(has_prefix(name, "iso2022"))
    return ISO2022Dec();

  program p = ([
    "utf7": UTF7dec,
    "utf8": UTF8dec,
    "utf16": UTF16dec,
    "utf16be": UTF16dec,
    "utf16le": UTF16LEdec,
    "utf75": UTF7_5dec,
    "utf7½": UTF7_5dec,
    "shiftjis": ShiftJisDec,
  ])[name];

  if(p)
    return p();

  if(has_prefix(name, "euc")) {
    string sub = ([
      "kr":"korean",
      "jp":"x0208",
      "cn":"chinese",
    ])[name[3..]];

    if(sub)
      return EUCDec(sub);
  }

  object o = rfc1345(name);

  if(o)
    return o;

  throw(({"Unknown character encoding "+name+"\n", backtrace()}));
}

class _encoder
{
  static string s = "";
  static string|void replacement;
  static function(string:string)|void repcb;
  static string low_convert(string s, string|void r,
			     function(string:string)|void rc)
  {
    int i = strlen(s);
    string rr;
    while(--i>=0)
      if(s[i]>255)
	if(rc && (rr = rc(s[i..i])))
	  s=s[..i-1]+low_convert(rr,r)+s[i+1..];
	else if(r)
	  s=s[..i-1]+low_convert(r)+s[i+1..];
	else
	  throw(({"Character unsupported by encoding.\n", backtrace()}));
    return s;
  }
  object(this_program) feed(string ss)
  {
    s += low_convert(ss, replacement, repcb);
    return this_object();
  }
  string drain()
  {
    string ss = s;
    s = "";
    return ss;
  }
  object(this_program) clear()
  {
    s = "";
    return this_object();
  }
  void set_replacement_callback(function(string:string) rc)
  {
    repcb = rc;
  }
  static void create(string|void r, string|void rc)
  {
    replacement = r;
    repcb = rc;
  }
}

private class UTF16enc {
  inherit _encoder;
  static private string low_convert(string s, string|void r,
				    function(string:string)|void rc)
  {
    int i = strlen(s);
    string rr;
    while(--i>=0)
      if(s[i]>0x10ffff)
	if(rc && (rr = rc(s[i..i])))
	  s=s[..i-1]+low_convert(rr,r)+s[i+1..];
	else if(r)
	  s=s[..i-1]+low_convert(r)+s[i+1..];
	else
	  throw(({"Character unsupported by encoding.\n", backtrace()}));
    return s;
  }
  object(this_program) feed(string ss) {
    s += ss;
    return this_object();
  }
  string drain() {
    string ss = s;
    s = "";
    catch {
      return string_to_unicode(ss);
    };
    ss = low_convert(ss, replacement, repcb);
    return string_to_unicode(ss);
  }
}

private class UTF16LEenc {
  inherit UTF16enc;
  string drain() {
    return map(::drain()/2, reverse)*"";
  }
}

//! Returns a charset encoder object.
//! @param name
//!   The name of the character set to decode from. Supported charsets
//!   include (not all supported charsets are enumerable):
//!   "iso_8859-1:1987", "iso_8859-1:1998", "iso-8859-1", "iso-ir-100",
//!   "latin1", "l1", "ansi_x3.4-1968", "iso_646.irv:1991", "iso646-us",
//!   "iso-ir-6", "us", "us-ascii", "ascii", "cp367", "ibm367", "cp819",
//!   "ibm819", "iso-2022" (of various kinds), "utf-7", "utf-8" and
//!   various encodings as described by RFC1345.
//! @throws
//!   If the asked-for @[name] was not supported, an error is thrown.
object(_encoder) encoder(string name, string|void replacement,
			 function(string:string)|void repcb)
{
  name = normalize(name);
  if(!name || (<
    "iso885911987", "iso885911998", "iso88591", "isoir100",
    "latin1", "l1", "ansix341968", "iso646irv1991", "iso646us",
    "isoir6", "us", "usascii", "ascii", "367", "819">)[name])
    return _encoder(replacement, repcb);

  if(has_prefix(name, "iso2022"))
    return ISO2022Enc(replacement, repcb);

  program p = ([
    "utf7": UTF7enc,
    "utf8": UTF8enc,
    "utf16": UTF16enc,
    "utf16be": UTF16enc,
    "utf16le": UTF16LEenc,
    "utf7.5": UTF7_5enc,
    "utf7½": UTF7_5enc,
    "shiftjis": ShiftJisEnc,
  ])[name];

  if(p)
    return p(replacement, repcb);

  if(has_prefix(name, "euc")) {
    string sub = ([
      "kr":"korean",
      "jp":"x0208",
      "cn":"chinese",
    ])[name[3..]];

    if(sub)
      return EUCEnc(sub, replacement, repcb);
  }

  object o = rfc1345(name, 1, replacement, repcb);

  if(o)
    return o;

  throw(({"Unknown character encoding "+name+"\n", backtrace()}));
}
