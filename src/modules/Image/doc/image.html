<!-- $id$ -->

<center>
<i>Pike module: </i>
<h1>image</h1>
Pontus Hagland <a href=law@infovav.se><i>law@infovav.se</i></a>
<br>Per Hedbor <a href=per@infovav.se><i>per@infovav.se</i></a>
<br>David Kågedal <a href=kg@infovav.se><i>kg@infovav.se</i></a>
</center>

<hr>

This package adds two Pike progams:

<ul>
<li><tt><a href=#image>"precompiled/image"</a></tt> and
<li><tt><a href=#font>"precompiled/font"</a></tt>.
</ul>

<hr>

<a name=image><h2>methods in precompiled/image:</h2></a>

Methods resulting in a new object:

<br><a name=cloner><tt>object <a href=#clone><b>clone</b></a>( </tt>[<tt>int <b>xsize</b>,int <b>ysize</b> </tt>[<tt>,int <b>r</b>,int <b>g</b>,int <b>b</b></tt>]<tt> </b></tt>]<tt> </b>);</tt></a>
<p><a name=copyr><tt>object <a href=#copy><b>copy</b></a>( </tt>[<tt>int <b>x1</b>,int <b>y1</b>,int <b>x2</b>,int <b>y2</b> </tt>[<tt>,int <b>r</b>,int <b>g</b>,int <b>b</b></tt>]<tt> </b></tt>]<tt> </b>);</tt></a>
<br><a name=autocropr><tt>object <a href=#autocrop><b>autocrop</b></a>( </tt>[<tt>int <b>border_width</b> </tt>[<tt>,int <b>left</b>,int <b>right</b>,int <b>top</b>,int <b>bottom</b></tt>]<tt></b> </tt>[<tt>,int <b>r</b>,int <b>g</b>,int <b>b</b></tt>]<tt> </b></tt>]<tt> </b>);</tt></a>
<p><a name=grayr><tt>object <a href=#gray><b>gray</b></a>();</tt></a>
<br><a name=colorr><tt>object <a href=#color><b>color</b></a>(int <b>r</b>,int <b>g</b>,int <b>b</b>);</tt></a>
<br><a name=invertr><tt>object <a href=#invert><b>invert</b></a>();</tt></a>

<p><a name=mirrorxr><tt>object <a href=#mirrorx><b>mirrorx</b></a>(void);</tt></a>
<br><a name=mirroryr><tt>object <a href=#mirrory><b>mirrory</b></a>(void);</tt></a>
<br><a name=rotate_cwr><tt>object <a href=#rotate_cw><b>rotate_cw</b></a>(void);</tt></a>
<br><a name=rotate_ccwr><tt>object <a href=#rotate_ccw><b>rotate_ccw</b></a>(void);</tt></a>
<br><a name=thresholdr><tt>object <a href=#threshold><b>threshold</b></a>(</tt>[<tt>int <b>r</b>,int <b>g</b>,int <b>b</b></tt>]<tt></b>); </tt></a>
<br><a name=apply_matrixr><tt>object <a href=#apply_matrix><b>apply_matrix</b></a>(array(array(int)) <b>matrix</b>,</tt>[<tt>int <b>r</b>,int <b>g</b>,int <b>b</b></tt>[<tt>,int <b>div</b></tt>]]<tt>);</tt></a>
<p><a name=scaler><tt>object <a href=#scale><b>scale</b></a>(float <b>factor</b>);</tt></a>
<br><a name=scaler><tt>object <a href=#scale><b>scale</b></a>(float <b>factorx</b>,float <b>factory</b>);</tt></a>
<br><a name=scaler><tt>object <a href=#scale><b>scale</b></a>(int <b>newx</b></tt>|<tt><b>0</b>,int <b>newy</b></tt>|<tt><b>0</b>);</tt></a>

<p>Methods operating on current object:

<br><a name=toppmr><tt>string <a href=#toppm><b>toppm</b></a>(void</b>);</tt></a>
<br><a name=fromppmr><tt>string|object <a href=#fromppm><b>fromppm</b></a>(string <b>s</b>);</tt></a>
<br><a name=togifr><tt>string <a href=#togif><b>togif</b></a>( </tt>[<tt>int <b>r</b>,inr g</b>,int <b>b</b></tt>]<tt> </b>);</tt></a>
<p><a name=paster><tt>object <a href=#paste><b>paste</b></a>(object <b>img</b> </tt>[<tt>,int <b>x</b>,int <b>y</b></tt>]<tt></b>)</tt></a>
<br><a name=paste_alphar><tt>object <a href=#paste_alpha><b>paste_alpha</b></a>(object <b>img</b>, int <b>alpha</b> </tt>[<tt>,int <b>x</b>, int <b>y</b></tt>]<tt></b>);</tt></a>
<br><a name=paste_maskr><tt>object <a href=#paste_mask><b>paste_mask</b></a>(object <b>img</b>, object <b>alpha_mask</b> </tt>[<tt>,int <b>x</b>,int <b>y</b></tt>]<tt></b>);</tt></a>
<p><a name=setcolorr><tt>object <a href=#setcolor><b>setcolor</b></a>(int <b>r</b>,int <b>g</b>,int <b>b</b>);</tt></a>
<br><a name=setpixelr><tt>object <a href=#setpixel><b>setpixel</b></a>(int <b>x</b>,int <b>y</b> </tt>[<tt>,int <b>r</b>,int <b>g</b>,int <b>b</b></tt>]<tt> </b>);</tt></a>
<br><a name=liner><tt>object <a href=#line><b>line</b></a>(int <b>x1</b>,int <b>y1</b>,int <b>x2</b>,int <b>y2</b> </tt>[<tt>,int <b>r</b>,int <b>g</b>,int <b>b</b></tt>]<tt> </b>);</tt></a>
<br><a name=boxr><tt>object <a href=#box><b>box</b></a>(int <b>x1</b>,int <b>y1</b>,int <b>x2</b>,int <b>y2</b> </tt>[<tt>,int <b>r</b>,int <b>g</b>,int <b>b</b></tt>]<tt> </b>);</tt></a>
<br><a name=circler><tt>object <a href=#circle><b>circle</b></a>(int <b>x</b>,int <b>y</b>,int <b>radx</b>,int <b>rady</b> </tt>[<tt>,int <b>r</b>,int <b>b</b>,int <b>g</b></tt>]<tt> </b>);</tt></a>
<br><a name=tuned_boxr><tt>object <a href=#tuned_box><b>tuned_box</b></a>(int <b>x1</b>,int <b>y1</b>,int <b>x2</b>,int <b>y2</b>,array(array(int)) corner_rgb</b>);</tt></a>

<p>Information giving methods:
<br><a name=xsizer><tt>object <a href=#xsize><b>xsize</b></a>();</tt></a>
<br><a name=ysizer><tt>object <a href=#ysize><b>ysize</b></a>();</tt></a>

<hr>

<dl>
<dt>METHOD
<dd><a name=apply_matrix><tt>object <a href=#apply_matrixr><b>apply_matrix</b></a>(array(array(int)) <b>matrix</b>,</tt>[<tt>int <b>r</b>,int <b>g</b>,int <b>b</b></tt>[<tt>,int <b>div</b></tt>]]<tt>);</tt></a>
<dt>DESCRIPTION

<dd>This method applies a matrix on the image. Each surrounding pixel
is multiplied with the value of the matrix element in that point,
these values are added and divided by the total sum of the matrix
values (and the <b>div</b> argument) and stored on the pixel
(eventually added to the <b>r</b>,<b>g</b>,<b>b</b> argument given as
'mean' value).

<p>It is possible to use a matrix of RGB groups (ie an array of three
integers) instead of the simple values, this making it possible to
apply different matrices on red, green and blue channel.

<dt>RETURN VALUE
<dd>the new object
<dt>EXAMPLE
<dd>
A 'blur' operation (3x3, gaussian):
<pre>blurred=image->apply_matrix( ({ ({1,2,1}), ({2,3,2}), ({1,2,1}) }) );</pre>
<p>A 'Emboss' operation (3x3):
<pre>emossed=image->apply_matrix(({ ({0,1,8}), ({-1,0,1}), ({-8,-1,0}) }), 128,128,128, 15 );</pre>
Here i'm using 128,128,128 (gray) as a mean, because i get negative values.
<br>A division by 15 is good to give 'normal' edges.

<dt>BUGS
<dd>not known
</dl>

<hr>

<dl>
<dt>METHOD
<dd><a name=autocrop><tt>object <a href=#autocropr><b>autocrop</b></a>( </tt>[<tt>int <b>border_width</b> </tt>[<tt>,int <b>left</b>,int <b>right</b>,int <b>top</b>,int <b>bottom</b></tt>]<tt></b> </tt>[<tt>,int <b>r</b>,int <b>g</b>,int <b>b</b></tt>]<tt> </b></tt>]<tt> </b>);</tt></a>
<dt>DESCRIPTION

<dd>Crops away unneccesary borders from the image. The <b>border</b>
argument is to define the new thickness of the surrounding border and
the <b>r</b>,<b>g</b>,<b>b</b> is the newly created border color.

<p>The <b>left</b>, <b>right</b>, ... arguments is used to tell which
edges should be autocropped.

<dt>RETURN VALUE
<dd>the new object
<dt>EXAMPLE
<dd><pre>cropped=image->autocrop();</pre>
<dt>BUGS
<dd>now known
</dl>

<hr>

<dl>
<dt>METHOD
<dd><a name=box><tt>object <a href=#boxr><b>box</b></a>(int <b>x1</b>,int <b>y1</b>,int <b>x2</b>,int <b>y2</b> </tt>[<tt>,int <b>r</b>,int <b>g</b>,int <b>b</b></tt>]<tt> </b>);</tt></a>
<dt>DESCRIPTION

<dd>Draw a box of the default or specified color.

<dt>RETURN VALUE
<dd>the image object
<dt>EXAMPLE
<dd>
<dt>BUGS
<dd>
</dl>

<hr>

<dl>
<dt>METHOD
<dd><a name=circle><tt>object <a href=#circler><b>circle</b></a>(int <b>x</b>,int <b>y</b>,int <b>radx</b>,int <b>rady</b> </tt>[<tt>,int <b>r</b>,int <b>b</b>,int <b>g</b></tt>]<tt> </b>);</tt></a>
<dt>DESCRIPTION
<dd>Draw a circle. The coordinates given are the center of the image and the radius in x (horisontal) and y (vertical), this making it possible to draw an ellipse too. <tt>:-)</tt>
<dt>RETURN VALUE
<dd>the image object
<dt>EXAMPLE
<dd>
<dt>BUGS
<dd>
</dl>

<hr>

<dl>
<dt>METHOD
<dd><a name=clone><tt>object <a href=#cloner><b>clone</b></a>( </tt>[<tt>int <b>xsize</b>,int <b>ysize</b> </tt>[<tt>,int <b>r</b>,int <b>g</b>,int <b>b</b></tt>]<tt> </b></tt>]<tt> </b>);</tt></a>
<dt>DESCRIPTION
<dd>make a new object and return it
<ul>
<li>no arguments -> old image is copied
<li>size is given -> old image is copied cropped
<li>color is given -> new default color
</ul>
<dt>RETURN VALUE
<dd>the new object
<dt>SEE ALSO
<dd><a href=#copy>copy</a>, <a href=#clear>clear</a>
<dt>EXAMPLE
<dd>
<dt>BUGS
<dd>
</dl>

<hr>

<dl>
<dt>METHOD
<dd><a name=color><tt>object <a href=#colorr><b>color</b></a>(int <b>r</b>,int <b>g</b>,int <b>b</b>);</tt></a>
<dt>DESCRIPTION
<dd>Apply a color filter on the image. 
<dt>RETURN VALUE
<dd>the new object
<dt>EXAMPLE
<dd><pre>cyan=image->color(64,255,192);</pre>
This function is most usable on a image that has been <a href=#gray>gray</a>ed first.
<dt>BUGS
<dd>
</dl>

<hr>

<dl>
<dt>METHOD
<dd><a name=copy><tt>object <a href=#copyr><b>copy</b></a>( </tt>[<tt>int <b>x1</b>,int <b>y1</b>,int <b>x2</b>,int <b>y2</b> </tt>[<tt>,int <b>r</b>,int <b>g</b>,int <b>b</b></tt>]<tt> </b></tt>]<tt> </b>);</tt></a>
<dt>DESCRIPTION
<dd>Make a copy, or a copy of a part of the image. 
    It is possible to copy more then the image, to extend the image,
    this area is filled with the current (or given) color.
<dt>RETURN VALUE
<dd>the new image object
<dt>EXAMPLE
<dd><pre>copy=image->copy();

copy=image->copy(-10,-10,image->xsize()+9,image->ysize()+9);</pre>
<dt>BUGS
<dd>
</dl>

<hr>

<dl>
<dt>METHOD
<dd><a name=fromppm><tt>string|object <a href=#fromppmr><b>fromppm</b></a>(string <b>s</b>);</tt></a>
<dt>DESCRIPTION
<dd>Import a ppm image.
<dt>RETURN VALUE
<dd>0 (object) upon success, else the error message (string).
<dt>EXAMPLE
<dd><pre>image=clone( (program)"precompiled/image" );
image->fromppm(read_bytes("my_image.ppm",0,10000000));</pre>
<dt>BUGS
<dd>
</dl>

<hr>

<dl>
<dt>METHOD
<dd><a name=gray><tt>object <a href=#grayr><b>gray</b></a>(</tt>[<tt>int <b>r</b>,int <b>g</b>,int <b>b</b></tt>]<tt>);</tt></a>
<dt>DESCRIPTION

<dd>Make this image gray (each r,g,b gets the same value).<br> If a
color is given, that specifies the amount of r, g, and b that is used
to compute the gray level. Default is 87,127,41.

<dt>RETURN VALUE
<dd>the new object
<dt>EXAMPLE
<dd><pre>gray=image->gray()</pre>
<dt>BUGS
<dd>
</dl>

<hr>

<dl>
<dt>METHOD
<dd><a name=invert><tt>object <a href=#invertr><b>invert</b></a>();</tt></a>
<dt>DESCRIPTION
<dd>Invert the image.
<dt>RETURN VALUE
<dd>the new object
<dt>EXAMPLE
<dd><pre>inverted=image->invert()</pre>
<dt>BUGS
<dd>
</dl>

<hr>

<dl>
<dt>METHOD
<dd><a name=line><tt>object <a href=#liner><b>line</b></a>(int <b>x1</b>,int <b>y1</b>,int <b>x2</b>,int <b>y2</b> </tt>[<tt>,int <b>r</b>,int <b>g</b>,int <b>b</b></tt>]<tt> </b>);</tt></a>
<dt>DESCRIPTION
<dd>Draw a line from <b>x1</b>,<b>y1</b> to <b>x2</b>,<b>y2</b>.
<dt>RETURN VALUE
<dd>the image object
<dt>EXAMPLE
<dd><pre>image->line(17,100,42,1000);</pre>
<dt>BUGS
<dd>
</dl>

<hr>

<dl>
<dt>METHOD
<dd><a name=mirrorx><tt>object <a href=#mirrorxr><b>mirrorx</b></a>(void);</tt></a>
<dd><a name=mirrory><tt>object <a href=#mirroryr><b>mirrory</b></a>(void);</tt></a>
<dt>DESCRIPTION
<dd>Mirrors the image, horisontally or vertically.
<dt>RETURN VALUE
<dd>the new image object
<dt>EXAMPLE
<dd><pre>mirrored=image->mirrorx();</pre>
<dt>BUGS
<dd>
</dl>

<hr>
<dl>
<dt>METHOD
<dd><a name=rotate_cw><tt>object <a href=#rotate_cwr><b>rotate_cw</b></a>(void);</tt></a>
<dd><a name=rotate_ccw><tt>object <a href=#rotate_ccwr><b>rotate_ccw</b></a>(void);</tt></a>
<dt>DESCRIPTION
<dd>Rotate the image, clockwise or counterclockwise, 90 degrees.
<br>This operation is very fast compared to rotating any angle.
<dt>RETURN VALUE
<dd>the new image object
<dt>EXAMPLE
<dd><pre>snurr=image->rotate_cw();</pre>
<dt>BUGS
<dd>
</dl>
<hr>

<dl>
<dt>METHOD
<dd><a name=paste><tt>object <a href=#paster><b>paste</b></a>(object <b>img</b> </tt>[<tt>,int <b>x</b>,int <b>y</b></tt>]<tt></b>)</tt></a>
<dd><a name=paste_alpha><tt>object <a href=#paste_alphar><b>paste_alpha</b></a>(object <b>img</b>, int <b>alpha</b> </tt>[<tt>,int <b>x</b>, int <b>y</b></tt>]<tt></b>);</tt></a>
<dd><a name=paste_mask><tt>object <a href=#paste_maskr><b>paste_mask</b></a>(object <b>img</b>, object <b>alpha_mask</b> </tt>[<tt>,int <b>x</b>,int <b>y</b></tt>]<tt></b>);</tt></a>
<dt>DESCRIPTION
<dd>Paste an image on this image. Use the specified alpha channel
value or the second specified image as an alpha channel.<br>
The first argument is the image that will be pasted.
<dt>RETURN VALUE
<dd>the image object
this function doesn't return anything
<dt>EXAMPLE
<dd><pre>image->paste(other_smaller_image,17,42);

image->paste_mask(other_image,alpha_channel_image);</pre>
Paste a dog on a landscape:<pre>landscape->paste(dog,dog_alpha_channel,xpos,ypos);</pre>
Write some text:<pre>text=font->write("some text");
foreground=text->clear(255,255,255); // white
background->paste(foreground,text,xpos,ypos);</pre>
<dt>BUGS
<dd>
</dl>

<hr>

<dl>
<dt>METHOD
<dd><a name=scale><tt>object <a href=#scaler><b>scale</b></a>(float <b>factor</b>);</tt> (1</a>
<dd><a name=scale><tt>object <a href=#scaler><b>scale</b></a>(float <b>factorx</b>,float <b>factory</b>);</tt> (2</a>
<dd><a name=scale><tt>object <a href=#scaler><b>scale</b></a>(int <b>newx</b></tt>|<tt><b>0</b>,int <b>newy</b></tt>|<tt><b>0</b>);</tt> (3</a>
<dt>DESCRIPTION
<dd>Scale this image.
<ol>
<li>scale the image with a (line scale) factor
<li>scale the image with different factors on x and y
<li>scale the image to a new size
<br>with newx or newy set to zero, just scale the image to fit the x
or y size and keep proportions.
</ol>
<dt>RETURN VALUE
<dd>the new object
this function doesn't return anything
<dt>EXAMPLE
<dd>
<dt>BUGS
<dd>
</dl>

<hr>

<dt>METHOD
<dd><a name=setcolor><tt>object <a href=#setcolorr><b>setcolor</b></a>(int <b>r</b>,int <b>g</b>,int <b>b</b>);</tt></a>
<dt>DESCRIPTION
<dd>set the default color used for drawing lines, etc
<dt>RETURN VALUE
<dd>the image object
<dt>EXAMPLE
<dd>
<dt>BUGS
<dd>
</dl>

<hr>

<dt>METHOD
<dd><a name=setpixel><tt>object <a href=#setpixelr><b>setpixel</b></a>(int <b>x</b>,int <b>y</b> </tt>[<tt>,int <b>r</b>,int <b>g</b>,int <b>b</b></tt>]<tt> </b>);</tt></a>
<dt>DESCRIPTION
<dd>set the color of the specified pixel
<dt>RETURN VALUE
<dd>the image object
<dt>EXAMPLE
<dd>
<dt>BUGS
<dd>
</dl>

<hr>

<dl>
<dt>METHOD
<dd><a name=threshold><tt>object <a href=#thresholdr><b>threshold</b></a>(</tt>[<tt>int <b>r</b>,int <b>g</b>,int <b>b</b></tt>]<tt></b>); </tt></a>
<dt>DESCRIPTION
<dd>make image black-and-white using the given value as the threshold
<dt>RETURN VALUE
<dd>the new object
<dt>EXAMPLE
<dd>
<dt>BUGS
<dd>
</dl>

<hr>

<dl>
<dt>METHOD
<dd><a name=togif><tt>string <a href=#togifr><b>togif</b></a>( </tt>[<tt>int <b>r</b>,inr g</b>,int <b>b</b></tt>]<tt> </b>);</tt></a>
<dt>DESCRIPTION
<dd>export gif
<br>if the color are given, this is the transparent color
<dt>RETURN VALUE
<dd>the gifimage as a string
<dt>EXAMPLE
<dd>
<dt>BUGS
<dd>
</dl>

<hr>

<dl>
<dt>METHOD
<dd><a name=toppm><tt>string <a href=#toppmr><b>toppm</b></a>(object</b>);</tt></a>
<dt>DESCRIPTION
<dd>export ppm
<dt>RETURN VALUE
<dd>the ppm image as a string
<dt>EXAMPLE
<dd>
<dt>BUGS
<dd>
</dl>

<hr>

<dl>
<dt>METHOD
<dd><a name=tuned_box><tt>object <a href=#tuned_boxr><b>tuned_box</b></a>(int <b>x1</b>,int <b>y1</b>,int <b>x2</b>,int <b>y2</b>,array(array(int)) corner_rgb</b>);</tt></a>
<dt>DESCRIPTION
<dd>draw a box with the specified corner colours, and shade the colors between
<dt>RETURN VALUE
<dd>the image object
<dt>EXAMPLE
<dd><pre>image->tuned_box(0,0,img->xsize()-1,img->ysize()-1,
	        ({({0,0,64}),({16,16,128}),
                  ({16,16,128}),({192,160,128})}));</pre>
<dt>BUGS
<dd>
</dl>

<hr>
<dl>
<dt>METHOD
<dd><a name=xsize><tt>object <a href=#xsizer><b>xsize</b></a>();</tt></a>
<dd><a name=ysize><tt>object <a href=#ysizer><b>ysize</b></a>();</tt></a>
<dt>DESCRIPTION
<dd>
<dt>RETURN VALUE
<dd>Gives the x- or the y-size (horisontal or vertical size) of the image.
<dt>EXAMPLE
<dd>
<dt>BUGS
<dd>
</dl>


<hr>

<a name=font><h2>methods in precompiled/font:</h2></a>

<a name=loadr><tt>int <a href=#load><b>load</b></a>(string <b>file_name</b>);</tt>
<br><a name=writer><tt>object <a href=#write><b>write</b></a>(string <b>line</b>, </tt>...<tt>);</tt>

<hr>
<dl>
<dt>METHOD
<dd><a name=load><tt>int <a href=#loadr><b>load</b></a>(string <b>file_name</b>);</tt>
<dt>DESCRIPTION
<dd>load this font object with the font from the specified file
<dt>RETURN VALUE
<dd>true on success
<dt>EXAMPLE
<dd>
<dt>BUGS
<dd>
</dl>

<hr>

<dl>
<dt>METHOD
<dd><a name=write><tt>object <a href=#writer><b>write</b></a>(string <b>line</b>, </tt>...<tt>);</tt>
<dt>DESCRIPTION
<dd>make a new image object from the specified text, each argument representing a line
<dt>RETURN VALUE
<dd>the new image object
<dt>EXAMPLE
<dd>
<dt>BUGS
<dd>
</dl>

<hr>

<h2>Example program:</h2>
(pike)
<pre>

int main()
{
   object txt,o,shad,font;
   int i;

   txt = 
      (font=clone((program)"/precompiled/font"))
      ->load("/usr/local/lib/pike/fonts/64/helvetica_bold_r")
      ->write("The Image Module")
      ->autocrop(20,0,0,0);

   shad=txt->mirrory()->scale(1.0,0.3)->color(64,64,64);

   o=clone((program)"/precompiled/image",
	   txt->xsize(),txt->ysize(), 0,0,100)
        ->tuned_box(0,0,txt->xsize(),txt->ysize(),
		    ({({0,0,0}),({0,0,0}),
		      ({0,0,255}),({128,128,0})}));
   
   o->setcolor(255,255,255,200);
   for (i=0; i<30; i++)
      if (random(2))
	 o->line(random(o->xsize()),o->ysize()-10-random(20+i*3),
		 o->xsize()-1-random(30),o->ysize()-1);
      else
	 o->line(random(o->xsize()),o->ysize()-10-random(20+i),
		 random(30),o->ysize()-1);

   for (i=0; i<10; i++)
      o->box(random(o->xsize()),random(o->ysize()),
	     random(o->xsize()),random(o->ysize()),
	     random(256),random(256),random(256),220);

   o -> paste_mask(txt->clear(0,255,0),
		   shad,0,(int)(font->baseline()*0.7)+shad->ysize()-10)
     -> paste_mask(txt->clear(255,255,0),
		 txt->apply_matrix(({({1,2,1}),({2,4,2}),({1,2,1})}))
		 ->apply_matrix(({({1,2,1}),({2,4,2}),({1,2,1})}))
		 ->modify_by_intensity(1,0,0, 0,255,255,255,255,255))
     -> paste_mask(txt->clone()
		   ->tuned_box(0,0,txt->xsize()-1,txt->ysize()-1,
			       ({({128,128,128}),({64,128,0}),
                                 ({64,128,0}),({255,255,0})})),
		   txt);
   write(o->togif_fs());
   return 0;
}
</pre>

<h2>Undocumented, yet:</h2>
<pre>
object image->select_from(int x,int y);
object image->distancesq(int r,int g,int b);
array(int) image->getpixel(int x,int y);
object image->skewx(int diff,rgb);
object image->skewy(int diff,rgb);
object image->skewx_expand(int diff,rgb);
object image->skewy_expand(int diff,rgb);
object image->rotate(int|float angle,rgb);
object image->rotate_expand(int|float angle,rgb);
object image->turbulence(colorrange,int octaves=3,float scale=1,
			 float xdiff=0,float ydiff=0,float cscale=1);
object image->noise(colorrange,float scale=0.1,
	 	    float xdiff=0,float ydiff=0,float cscale=1);
    where colorrange is ({ float position=0..1, ({r,g,b}),
       			   float position=0..1, ({r,g,b}), ... })
</pre>