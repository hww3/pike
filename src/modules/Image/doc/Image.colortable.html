<title>Pike documentation: Image.colortable</title>
<h2>Image.colortable</h2>


<blockquote>
This object keeps colortable information,
     mostly for image re-coloring (quantization).
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=Image.html>Image</a></tt>,
     <tt><a href=Image.image.html>Image.image</a></tt>,
     <tt><a href=Image.font.html>Image.font</a></tt>
</blockquote>

<hr>
<a name=%60*> </a>
<a name=%60%60*> </a>
<a name=map> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>map</b>(object&nbsp;image)<br>
object <b>`*</b>(object&nbsp;image)<br>
object <b>``*</b>(object&nbsp;image)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Map colors in an image object to the colors in 
     the colortable, and creates a new image with the
     closest colors.
</blockquote>
<h4>RETURNS</h4>


<blockquote>
a new image object
</blockquote>


<h4>NOTE</h4>
<blockquote>
Flat (not cube) colortable and not '<tt><a href=Image.colortable.html#full>full</a></tt>' method: 
     this method does figure out the data needed for
     the lookup method, which may take time the first
     use of the colortable - the second use is quicker.

<p>     cubicle, tree, full
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=Image.colortable.html#></a></tt>
</blockquote>

<hr>
<a name=%60+> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>`+</b>(object&nbsp;with, ...)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
sums colortables
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>object(<ref>colortable</ref>) with</tt>
  <dd><tt><a href=Image.colortable.html#colortable>colortable</a></tt> object with colors to add
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the resulting new <ref>colortable</ref> object
</blockquote>

<hr>
<a name=%60-> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>`-</b>(object&nbsp;with, ...)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
subtracts colortables
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>object(<ref>colortable</ref>) with</tt>
  <dd><tt><a href=Image.colortable.html#colortable>colortable</a></tt> object with colors to subtract
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the resulting new <ref>colortable</ref> object
</blockquote>

<hr>
<a name=add> </a>
<a name=create> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>void <b>create</b>()<br>
void <b>create</b>(array(array(int))&nbsp;colors)<br>
void <b>create</b>(object(Image.image)&nbsp;image, int&nbsp;number)<br>
void <b>create</b>(object(Image.image)&nbsp;image, int&nbsp;number, array(array(int))&nbsp;needed)<br>
void <b>create</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
void <b>create</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b, &nbsp;array(int)&nbsp;from1, array(int)&nbsp;to1, int&nbsp;steps1, &nbsp;..., &nbsp;array(int)&nbsp;fromn, array(int)&nbsp;ton, int&nbsp;stepsn)<br>
object <b>add</b>(array(array(int))&nbsp;colors)<br>
object <b>add</b>(object(Image.image)&nbsp;image, int&nbsp;number)<br>
object <b>add</b>(object(Image.image)&nbsp;image, int&nbsp;number, array(array(int))&nbsp;needed)<br>
object <b>add</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
object <b>add</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b, &nbsp;array(int)&nbsp;from1, array(int)&nbsp;to1, int&nbsp;steps1, &nbsp;..., &nbsp;array(int)&nbsp;fromn, array(int)&nbsp;ton, int&nbsp;stepsn)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
<tt><a href=Image.colortable.html#create>create</a></tt> initiates a colortable object. 
     Default is that no colors are in the colortable. 

<p>     <tt><a href=Image.colortable.html#create>create</a></tt> can also take the same arguments
     as <tt><a href=Image.colortable.html#add>add</a></tt>, thus adding colors to the colortable.

<p>     The colortable is mostly a list of colors,
     or more advanced, colors and weight.

<p>     The colortable could also be a colorcube, with or 
     without additional scales. A colorcube is the by-far 
     fastest way to find colors. 

<p>     Example:
     <pre>
     ct=colortable(my_image,256); // the best 256 colors
     ct=colortable(my_image,255,({0,0,0})); // black and the best other 255

<p>     ct=colortable(({({0,0,0}),({255,255,255})})); // black and white

<p>     ct=colortable(6,7,6); // a colortable of 252 colors
     ct=colortable(7,7,5, ({0,0,0}),({255,255,255}),11); 
             // a colorcube of 245 colors, and a greyscale of the rest -> 256
     </pre>
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>array(array(int)) colors</tt>
  <dd>list of colors
<dt><tt>object(Image.image) image</tt>
  <dd>source image 

<p>     note: you may not get all colors from image,
     max hash size is (probably, set by a <tt>#define</tt>) 
     32768 entries, giving
     maybe half that number of colors as maximum.
<dt><tt>int number</tt>
  <dd>number of colors to get from the image
     
     0 (zero) gives all colors in the image.

<p>     Default value is 256.
<dt><tt>array(array(int)) needed</tt>
  <dd>needed colors (to optimize selection of others to these given)
     
     this will add to the total number of colors (see argument 'number')
<dt><tt>int r</tt>
<dt><tt>int g</tt>
<dt><tt>int b</tt>
  <dd>size of sides in the colorcube, must (of course) be equal
     or larger than 2 - if smaller, the cube is ignored (no colors).
     This could be used to have only scales (like a greyscale)
     in the output.
<dt><tt>array(int) fromi</tt>
<dt><tt>array(int) toi</tt>
<dt><tt>int stepi</tt>
  <dd>This is to add the possibility of adding a scale
     of colors to the colorcube; for instance a grayscale
     using the arguments <tt>({0,0,0}),({255,255,255}),17</tt>,
     adding a scale from black to white in 17 or more steps.

<p>     Colors already in the cube is used again to add the number
     of steps, if possible. 

<p>     The total number of colors in the table is therefore
     <tt>r*b*g+step1+...+stepn</tt>.
</dl></blockquote>

<hr>
<a name=cast> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>cast</b>(string&nbsp;to)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
cast the colortable to an array

<p>     example: <tt>(array)Image.colortable(img)</tt>
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>string to</tt>
  <dd>must be "array".
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the resulting array
</blockquote>


<h4>KNOWN BUGS</h4>
<blockquote>
ignores argument (ie <tt>(string)colortable</tt> gives an array)
</blockquote>

<hr>
<a name=cubicles> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>cubicles</b>()<br>
object <b>cubicles</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
object <b>cubicles</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b, int&nbsp;accuracy)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Set the colortable to use the cubicles algorithm to lookup
     the closest color. This is a mostly very fast and very
     accurate way to find the correct color, and the default
     algorithm.

<p>
     The colorspace is divided in small cubes, each cube
     containing the colors in that cube. Each cube then gets
     a list of the colors in the cube, and the closest from
     the corners and midpoints between corners.  

<p>     When a color is needed, the algorithm first finds the
     correct cube and then compares with all the colors in
     the list for that cube.

<p>     example: <tt>colors=Image.colortable(img)->cubicles();</tt>

<p>     algorithm time: between O[m] and O[m * n], 
     where n is numbers of colors and m is number of pixels

<p>     The arguments can be heavy trimmed for the usage
     of your colortable; a large number (10×10×10 or bigger)
     of cubicles is recommended when you use the colortable
     repeatedly, since the calculation takes much
     more time then usage.

<p>     In some cases, the <tt><a href=Image.colortable.html#full>full</a></tt> method is faster.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int r</tt>
<dt><tt>int g</tt>
<dt><tt>int b</tt>
  <dd>Size, ie how much the colorspace is divided.
     Note that the size of each cubicle is at least about 8b,
     and that it takes time to calculate them. The number of
     cubicles are <tt>r*g*b</tt>, and default is 4,5,4,
     ie 80 cubicles. This works good for 200±100 colors.
<dt><tt>int accuracy</tt>
  <dd>Accuracy when checking sides of cubicles.
     Default is 16. A value of 1 gives complete accuracy,
     ie cubicle() method gives exactly the same result
     as full(), but takes (in worst case) 16× the time
     to calculate.
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the called object
</blockquote>


<h4>NOTE</h4>
<blockquote>
this method doesn't figure out the cubicles, this is 
     done on the first use of the colortable

<p>     Not applicable to colorcube types of colortable.
</blockquote>

<hr>
<a name=full> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>full</b>()</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Set the colortable to use full scan to lookup the closest color.

<p>     example: <tt>colors=Image.colortable(img)->full();</tt>

<p>     algorithm time: O[n*m], where n is numbers of colors 
     and m is number of pixels
</blockquote>
<h4>RETURNS</h4>


<blockquote>
the called object
</blockquote>


<h4>NOTE</h4>
<blockquote>
Not applicable to colorcube types of colortable.
</blockquote>

<hr>
<a name=reduce> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>reduce</b>(int&nbsp;colors)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
reduces the number of colors

<p>     All needed (see <tt><a href=Image.colortable.html#create>create</a></tt>) colors are kept.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int colors</tt>
  <dd>target number of colors
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the new <ref>colortable</ref> object
</blockquote>

<hr>
<a name=spacefactors> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>spacefactors</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Colortable tuning option, this sets the color space
     distance factors. This is used when comparing distances
     in the colorspace and comparing grey levels.

<p>     Default factors are 2, 3 and 1; blue is much 
     darker than green. Compare with <tt><a href=Image.image.html#grey>Image.image::grey</a></tt>().
</blockquote>
<h4>RETURNS</h4>


<blockquote>
the called object
</blockquote>


<h4>NOTE</h4>
<blockquote>
This has no sanity check. Some functions may bug
     if the factors are to high - color reduction functions 
     sums grey levels in the image, this could exceed maxint
     in the case of high factors. Negative values may 
     also cause strange effects. *grin*
</blockquote>

<hr>
<a name=tree> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>tree</b>()</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Set the colortable to use a tree algorithm to find
     the best color.

<p>     example: <tt>colors=Image.colortable(img)->tree</tt>

<p>     algorithm time: O[ln n], where n is numbers of colors
</blockquote>
<h4>RETURNS</h4>


<blockquote>
the called object
</blockquote>


<h4>NOTE</h4>
<blockquote>
This method doesn't figure out the tree, this is 
     done on the first use of the colortable.

<p>     Not applicable to colorcube types of colortable.
</blockquote>
