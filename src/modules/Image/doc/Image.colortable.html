<title>Pike documentation: Image.colortable</title>
<h2>Image.colortable</h2>


<blockquote>
This object keeps colortable information,
     mostly for image re-coloring (quantization).

<p>     The object has color reduction, quantisation,
     mapping and dithering capabilities.
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=Image.html>Image</a></tt>,
     <tt><a href=Image.image.html>Image.image</a></tt>,
     <tt><a href=Image.font.html>Image.font</a></tt>,
     <tt><a href=Image.GIF.html>Image.GIF</a></tt>
</blockquote>

<hr>
<a name=%60*> </a>
<a name=%60%60*> </a>
<a name=map> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>map</b>(object&nbsp;image)<br>
object <b>`*</b>(object&nbsp;image)<br>
object <b>``*</b>(object&nbsp;image)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Map colors in an image object to the colors in 
     the colortable, and creates a new image with the
     closest colors. 

<p>     <table><tr valign=center>
     <td></td>
     <td></td>
     <td></td>
     <td></td>
     <td></td>
     <td></td>
     <td>no dither</td>
     </tr><tr valign=center>
     <td></td>
     <td></td>
     <td></td>
     <td></td>
     <td></td>
     <td></td>
     <td><tt><a href=Image.colortable.html#floyd_steinberg>floyd_steinberg</a></tt> dither</td>
     </tr><tr valign=center>
     <td></td>
     <td></td>
     <td></td>
     <td></td>
     <td></td>
     <td></td>
     <td><tt><a href=Image.colortable.html#ordered>ordered</a></tt> dither</td>
     </tr><tr valign=center>
     <td></td>
     <td></td>
     <td></td>
     <td></td>
     <td></td>
     <td></td>
     <td><tt><a href=Image.colortable.html#randomcube>randomcube</a></tt> dither</td>
     </tr><tr valign=center>
     <td>original</td>
     <td>2</td>
     <td>4</td>
     <td>8</td>
     <td>16</td>
     <td>32 colors</td>
     </tr></table>
</blockquote>
<h4>RETURNS</h4>


<blockquote>
a new image object
</blockquote>


<h4>NOTE</h4>
<blockquote>
Flat (not cube) colortable and not '<tt><a href=Image.colortable.html#full>full</a></tt>' method: 
     this method does figure out the data needed for
     the lookup method, which may take time the first
     use of the colortable - the second use is quicker.
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=Image.colortable.html#cubicles>cubicles</a></tt>,
     <tt><a href=Image.colortable.html#full>full</a></tt>
</blockquote>

<hr>
<a name=%60+> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>`+</b>(object&nbsp;with, ...)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
sums colortables
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>object(<ref>colortable</ref>) with</tt>
  <dd><tt><a href=Image.colortable.html#colortable>colortable</a></tt> object with colors to add
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the resulting new <ref>colortable</ref> object
</blockquote>

<hr>
<a name=%60-> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>`-</b>(object&nbsp;with, ...)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
subtracts colortables
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>object(<ref>colortable</ref>) with</tt>
  <dd><tt><a href=Image.colortable.html#colortable>colortable</a></tt> object with colors to subtract
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the resulting new <ref>colortable</ref> object
</blockquote>

<hr>
<a name=add> </a>
<a name=create> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>void <b>create</b>()<br>
void <b>create</b>(array(array(int))&nbsp;colors)<br>
void <b>create</b>(object(Image.image)&nbsp;image, int&nbsp;number)<br>
void <b>create</b>(object(Image.image)&nbsp;image, int&nbsp;number, array(array(int))&nbsp;needed)<br>
void <b>create</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
void <b>create</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b, &nbsp;array(int)&nbsp;from1, array(int)&nbsp;to1, int&nbsp;steps1, &nbsp;..., &nbsp;array(int)&nbsp;fromn, array(int)&nbsp;ton, int&nbsp;stepsn)<br>
object <b>add</b>(array(array(int))&nbsp;colors)<br>
object <b>add</b>(object(Image.image)&nbsp;image, int&nbsp;number)<br>
object <b>add</b>(object(Image.image)&nbsp;image, int&nbsp;number, array(array(int))&nbsp;needed)<br>
object <b>add</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
object <b>add</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b, &nbsp;array(int)&nbsp;from1, array(int)&nbsp;to1, int&nbsp;steps1, &nbsp;..., &nbsp;array(int)&nbsp;fromn, array(int)&nbsp;ton, int&nbsp;stepsn)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
<tt><a href=Image.colortable.html#create>create</a></tt> initiates a colortable object. 
     Default is that no colors are in the colortable. 

<p>     <tt><a href=Image.colortable.html#add>add</a></tt> takes the same argument(s) as
     <tt><a href=Image.colortable.html#create>create</a></tt>, thus adding colors to the colortable.

<p>     The colortable is mostly a list of colors,
     or more advanced, colors and weight.

<p>     The colortable could also be a colorcube, with or 
     without additional scales. A colorcube is the by-far 
     fastest way to find colors. 

<p>     Example:
     <pre>
     ct=colortable(my_image,256); // the best 256 colors
     ct=colortable(my_image,256,({0,0,0})); // black and the best other 255

<p>     ct=colortable(({({0,0,0}),({255,255,255})})); // black and white

<p>     ct=colortable(6,7,6); // a colortable of 252 colors
     ct=colortable(7,7,5, ({0,0,0}),({255,255,255}),11); 
             // a colorcube of 245 colors, and a greyscale of the rest -> 256
     </pre>
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>array(array(int)) colors</tt>
  <dd>list of colors
<dt><tt>object(Image.image) image</tt>
  <dd>source image 

<p>     note: you may not get all colors from image,
     max hash size is (probably, set by a <tt>#define</tt>) 
     32768 entries, giving
     maybe half that number of colors as maximum.
<dt><tt>int number</tt>
  <dd>number of colors to get from the image
     
     0 (zero) gives all colors in the image.

<p>     Default value is 256.
<dt><tt>array(array(int)) needed</tt>
  <dd>needed colors (to optimize selection of others to these given)
     
     this will add to the total number of colors (see argument 'number')
<dt><tt>int r</tt>
<dt><tt>int g</tt>
<dt><tt>int b</tt>
  <dd>size of sides in the colorcube, must (of course) be equal
     or larger than 2 - if smaller, the cube is ignored (no colors).
     This could be used to have only scales (like a greyscale)
     in the output.
<dt><tt>array(int) fromi</tt>
<dt><tt>array(int) toi</tt>
<dt><tt>int stepi</tt>
  <dd>This is to add the possibility of adding a scale
     of colors to the colorcube; for instance a grayscale
     using the arguments <tt>({0,0,0}),({255,255,255}),17</tt>,
     adding a scale from black to white in 17 or more steps.

<p>     Colors already in the cube is used again to add the number
     of steps, if possible. 

<p>     The total number of colors in the table is therefore
     <tt>r*b*g+step1+...+stepn</tt>.
</dl></blockquote>

<hr>
<a name=cast> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>cast</b>(string&nbsp;to)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
cast the colortable to an array

<p>     example: <tt>(array)Image.colortable(img)</tt>
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>string to</tt>
  <dd>must be "array".
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the resulting array
</blockquote>


<h4>KNOWN BUGS</h4>
<blockquote>
ignores argument (ie <tt>(string)colortable</tt> gives an array)
</blockquote>

<hr>
<a name=cubicles> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>cubicles</b>()<br>
object <b>cubicles</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
object <b>cubicles</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b, int&nbsp;accuracy)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Set the colortable to use the cubicles algorithm to lookup
     the closest color. This is a mostly very fast and very
     accurate way to find the correct color, and the default
     algorithm.

<p>
     The colorspace is divided in small cubes, each cube
     containing the colors in that cube. Each cube then gets
     a list of the colors in the cube, and the closest from
     the corners and midpoints between corners.  

<p>     When a color is needed, the algorithm first finds the
     correct cube and then compares with all the colors in
     the list for that cube.

<p>     example: <tt>colors=Image.colortable(img)->cubicles();</tt>

<p>     algorithm time: between O[m] and O[m * n], 
     where n is numbers of colors and m is number of pixels

<p>     The arguments can be heavy trimmed for the usage
     of your colortable; a large number (10×10×10 or bigger)
     of cubicles is recommended when you use the colortable
     repeatedly, since the calculation takes much
     more time then usage.

<p>     recommended values:

<p>     <pre>   
     image size  setup
     100×100     cubicles(4,5,4) (default)
     1000×1000   cubicles(12,12,12) (factor 2 faster than default)
     </pre>  

<p>     In some cases, the <tt><a href=Image.colortable.html#full>full</a></tt> method is faster.

<p>     <table><tr valign=center>
     <td></td>
     <td></td>
     <td></td>
     </tr><tr valign=center>
     <td>original</td>
     <td>default cubicles,<br>16 colors</td>
     <td>accuracy=200</td>
     </tr></table>
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int r</tt>
<dt><tt>int g</tt>
<dt><tt>int b</tt>
  <dd>Size, ie how much the colorspace is divided.
     Note that the size of each cubicle is at least about 8b,
     and that it takes time to calculate them. The number of
     cubicles are <tt>r*g*b</tt>, and default is 4,5,4,
     ie 80 cubicles. This works good for 200±100 colors.
<dt><tt>int accuracy</tt>
  <dd>Accuracy when checking sides of cubicles.
     Default is 16. A value of 1 gives complete accuracy,
     ie cubicle() method gives exactly the same result
     as full(), but takes (in worst case) 16× the time
     to calculate.
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the called object
</blockquote>


<h4>NOTE</h4>
<blockquote>
this method doesn't figure out the cubicles, this is 
     done on the first use of the colortable

<p>     Not applicable to colorcube types of colortable.
</blockquote>

<hr>
<a name=floyd_steinberg> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>floyd_steinberg</b>()<br>
object <b>floyd_steinberg</b>(int&nbsp;dir, int|float&nbsp;forward, int|float&nbsp;downforward, int|float&nbsp;down, int|float&nbsp;downback, int|float&nbsp;factor)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Set dithering method to floyd_steinberg.
     
     The arguments to this method is for fine-tuning of the 
     algorithm (for computer graphics wizards). 

<p>     <table><tr valign=center>
     <td></td>
     <td></td>
     <td></td>
     </tr><tr valign=center>
     <td>original</td>
     <td>floyd_steinberg to a 4×4×4 colorcube</td>
     <td>floyd_steinberg to 16 chosen colors</td>
     </tr></table>
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int bidir</tt>
  <dd>Set algorithm direction of forward.
     -1 is backward, 1 is forward, 0 for toggle of direction
     each line (default).
<dt><tt>int|float forward</tt>
<dt><tt>int|float downforward</tt>
<dt><tt>int|float down</tt>
<dt><tt>int|float downback</tt>
  <dd>Set error correction directions. Default is 
     forward=7, downforward=1, down=5, downback=3.
<dt><tt>int|float factor</tt>
  <dd>Error keeping factor. 
     Error will increase if more than 1.0 and decrease if less than 1.0.
     A value of 0.0 will cancel any dither effects.
     Default is 0.95.
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the called object
</blockquote>

<hr>
<a name=full> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>full</b>()</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Set the colortable to use full scan to lookup the closest color.

<p>     example: <tt>colors=Image.colortable(img)->full();</tt>

<p>     algorithm time: O[n*m], where n is numbers of colors 
     and m is number of pixels
</blockquote>
<h4>RETURNS</h4>


<blockquote>
the called object
</blockquote>


<h4>NOTE</h4>
<blockquote>
Not applicable to colorcube types of colortable.
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=Image.colortable.html#cubicles>cubicles</a></tt>,
     <tt><a href=Image.colortable.html#map>map</a></tt>
</blockquote>

<hr>
<a name=nodither> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>nodither</b>()</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Set no dithering (default).
</blockquote>
<h4>RETURNS</h4>


<blockquote>
the called object
</blockquote>

<hr>
<a name=ordered> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>ordered</b>()<br>
object <b>ordered</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
object <b>ordered</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b, int&nbsp;xsize, int&nbsp;ysize)<br>
object <b>ordered</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b, int&nbsp;xsize, int&nbsp;ysize, int&nbsp;x, int&nbsp;y)<br>
object <b>ordered</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b, int&nbsp;xsize, int&nbsp;ysize, int&nbsp;rx, int&nbsp;ry, int&nbsp;gx, int&nbsp;gy, int&nbsp;bx, int&nbsp;by)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Set ordered dithering, which gives a position-dependent error added
     to the pixel values. 

<p>     <table><tr valign=center>
     <td></td>
     <td></td>
     <td></td>
     <td></td>
     </tr><tr valign=top>
     <td>original</td>
     <td colspan=2>mapped to <br><tt>Image.colortable(6,6,6)-></tt></td>
     </tr><tr valign=top>
     <td></td>
     <td><tt>ordered<br> (42,42,42,2,2)</tt></td>
     <td><tt>ordered()</tt></td>
     <td><tt>ordered<br> (42,42,42, 8,8,<br> 0,0, 0,1, 1,0)</tt></td>
     </tr><tr valign=top>
     <td></td>
     <td></td>
     <td></td>
     <td></td>
     </tr></table>
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int r</tt>
<dt><tt>int g</tt>
<dt><tt>int b</tt>
  <dd>The maximum error. Default is 32, or colorcube steps (256/size).
<dt><tt>int xsize</tt>
<dt><tt>int ysize</tt>
  <dd>Size of error matrix. Default is 8×8.
     Only values which factors to multiples of 2 and 3 are
     possible to choose (2,3,4,6,8,12,...).
<dt><tt>int x</tt>
<dt><tt>int y</tt>
<dt><tt>int rx</tt>
<dt><tt>int ry</tt>
<dt><tt>int gx</tt>
<dt><tt>int gy</tt>
<dt><tt>int bx</tt>
<dt><tt>int by</tt>
  <dd>Offset for the error matrix. <tt>x</tt> and <tt>y</tt> is for
     both red, green and blue values, the other is individual.
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the called object
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=Image.colortable.html#randomcube>randomcube</a></tt>,
     <tt><a href=Image.colortable.html#nodither>nodither</a></tt>,
     <tt><a href=Image.colortable.html#floyd_steinberg>floyd_steinberg</a></tt>,
     <tt><a href=Image.colortable.html#create>create</a></tt>
</blockquote>

<hr>
<a name=randomcube> </a>
<a name=randomgrey> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>randomcube</b>()<br>
object <b>randomcube</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
object <b>randomgrey</b>()<br>
object <b>randomgrey</b>(int&nbsp;err)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Set random cube dithering.
     Color choosen is the closest one to color in picture
     plus (flat) random error; <tt>color±random(error)</tt>.

<p>     The randomgrey method uses the same random error on red, green
     and blue and the randomcube method has three random errors.

<p>     <table><tr valign=center>
     <td></td>
     <td></td>
     <td></td>
     </tr><tr valign=top>
     <td>original</td>
     <td colspan=2>mapped to <br><tt>Image.colortable(4,4,4)-></tt></td>
     </tr><tr valign=top>
     <td></td>
     <td>randomcube()</td>
     <td>randomgrey()</td>
     </tr><tr valign=top>
     <td></td>
     <td></td>
     <td></td>
     </tr></table>
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int r</tt>
<dt><tt>int g</tt>
<dt><tt>int b</tt>
<dt><tt>int err</tt>
  <dd>The maximum error. Default is 32, or colorcube step.
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the called object
</blockquote>


<h4>NOTE</h4>
<blockquote>
<tt><a href=Image.colortable.html#randomgrey>randomgrey</a></tt> method needs colorcube size to be the same on
     red, green and blue sides to work properly. It uses the
     red colorcube value as default.
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=Image.colortable.html#ordered>ordered</a></tt>,
     <tt><a href=Image.colortable.html#nodither>nodither</a></tt>,
     <tt><a href=Image.colortable.html#floyd_steinberg>floyd_steinberg</a></tt>,
     <tt><a href=Image.colortable.html#create>create</a></tt>
</blockquote>

<hr>
<a name=reduce> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>reduce</b>(int&nbsp;colors)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
reduces the number of colors

<p>     All needed (see <tt><a href=Image.colortable.html#create>create</a></tt>) colors are kept.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int colors</tt>
  <dd>target number of colors
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the new <ref>colortable</ref> object
</blockquote>

<hr>
<a name=spacefactors> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>spacefactors</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Colortable tuning option, this sets the color space
     distance factors. This is used when comparing distances
     in the colorspace and comparing grey levels.

<p>     Default factors are 3, 4 and 1; blue is much 
     darker than green. Compare with <tt><a href=Image.image.html#grey>Image.image->grey</a></tt>().
</blockquote>
<h4>RETURNS</h4>


<blockquote>
the called object
</blockquote>


<h4>NOTE</h4>
<blockquote>
This has no sanity check. Some functions may bug
     if the factors are to high - color reduction functions 
     sums grey levels in the image, this could exceed maxint
     in the case of high factors. Negative values may 
     also cause strange effects. *grin*
</blockquote>
