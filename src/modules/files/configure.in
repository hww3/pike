# $Id: configure.in,v 1.87 2003/05/15 13:25:41 marcus Exp $
AC_INIT(file.c)
AC_CONFIG_HEADER(file_machine.h)

AC_MODULE_INIT()

AC_DEFINE(WITH_TERMIOS)

AC_HAVE_HEADERS(sys/types.h arpa/inet.h sys/socketvar.h netinet/in.h \
 poll.h sys/poll.h sys/uio.h sys/mman.h linux/mman.h sys/time.h \
 sys/mount.h ustat.h sys/statfs.h sys/statvfs.h sys/vfs.h sys/param.h \
 sys/socket.h sys/stream.h sys/protosw.h netdb.h sys/sysproto.h winsock.h \
 direct.h sys/wait.h process.h sys/file.h net/netdb.h limits.h unistd.h \
 termios.h poll.h sys/poll.h sys/select.h sys/un.h)
AC_HEADER_DIRENT
AC_CHECK_LIB(bind, __inet_ntoa)
AC_CHECK_LIB(socket, socket)
AC_CHECK_LIB(nsl, gethostbyname)

AC_HAVE_FUNCS(getwd perror readdir_r statvfs statfs ustat lseek64 lstat fsync \
 grantpt unlockpt ptsname socketpair writev sendfile munmap madvise poll \
 setsockopt getprotobyname truncate64 ftruncate64 inet_ntoa inet_ntop)

AC_FUNC_MMAP

AC_MSG_CHECKING(if struct iovec is defined)
AC_CACHE_VAL(pike_cv_struct_iovec, [
  AC_TRY_COMPILE([
#ifdef HAVE_SYS_TYPES_H
#include <sys/types.h>
#endif /* HAVE_SYS_TYPES_H */
#include <unistd.h>
#ifdef HAVE_SYS_UIO_H
#include <sys/uio.h>
#endif /* HAVE_SYS_UIO_H */
  ],[
    struct iovec iov;

    iov.iov_base = (void *)0;
    iov.iov_len = 0;
  ], [ pike_cv_struct_iovec=yes ], [ pike_cv_struct_iovec=no ])
])
if test "$pike_cv_struct_iovec" = "yes"; then
  AC_MSG_RESULT(yes)
  AC_DEFINE(HAVE_STRUCT_IOVEC)
else
  AC_MSG_RESULT(no)
fi

if test "$ac_cv_func_sendfile" = "yes"; then
  AC_MSG_CHECKING(if sendfile takes 4(Linux) or 6(HP/UX) or 7(FreeBSD) arguments)
  AC_CACHE_VAL(pike_cv_sendfile_args, [
    AC_TRY_COMPILE([
#ifdef HAVE_SYS_TYPES_H
#include <sys/types.h>
#endif /* HAVE_SYS_TYPES_H */
#ifdef HAVE_SYS_SOCKET_H
#include <sys/socket.h>
#endif /* HAVE_SYS_SOCKET_H */
#ifdef HAVE_SYS_UIO_H
#include <sys/uio.h>
#endif /* HAVE_SYS_UIO_H */
    ], [
      return sendfile(0,0,0,0,(void *)0,(void *)0,0);
    ], [
      # Probably FreeBSD-style, but we need to check that
      # we indeed have a prototype...
      AC_TRY_COMPILE([
#ifdef HAVE_SYS_TYPES_H
#include <sys/types.h>
#endif /* HAVE_SYS_TYPES_H */
#ifdef HAVE_SYS_SOCKET_H
#include <sys/socket.h>
#endif /* HAVE_SYS_SOCKET_H */
#ifdef HAVE_SYS_UIO_H
#include <sys/uio.h>
#endif /* HAVE_SYS_UIO_H */
      ], [
        /* This should fail on FreeBSD and HPUX.
         * If it succeeds, we don't have a prototype,
         * which would indicate Linux.
         */
        return sendfile(0,0,(void *)0,0);
      ], [ pike_cv_sendfile_args=4 ], [ pike_cv_sendfile_args=7 ])
    ], [
      AC_TRY_COMPILE([
#ifdef HAVE_SYS_TYPES_H
#include <sys/types.h>
#endif /* HAVE_SYS_TYPES_H */
#ifdef HAVE_SYS_SOCKET_H
#include <sys/socket.h>
#endif /* HAVE_SYS_SOCKET_H */
#ifdef HAVE_SYS_UIO_H
#include <sys/uio.h>
#endif /* HAVE_SYS_UIO_H */
      ], [
        /* Try HPUX */
        return (int)sendfile(0,0,0,0,(void *)0,0);
      ], [ pike_cv_sendfile_args=6 ], [ pike_cv_sendfile_args=4 ])
    ])
  ])
  if test "$pike_cv_sendfile_args" = "7"; then
    AC_MSG_RESULT([7 - FreeBSD style])
    AC_DEFINE(HAVE_FREEBSD_SENDFILE)

    AC_MSG_CHECKING([if sendfile looks thread-safe])
    AC_CACHE_VAL(pike_cv_freebsd_sendfile_threadsafe, [
      # We're optimistic -- default to assuming it works.
      pike_cv_freebsd_sendfile_threadsafe="yes"
      if test -f /usr/lib/libc_r.so; then
        if /usr/bin/nm -D /usr/lib/libc_r.so 2>&1 | grep _thread_sys >/dev/null 2>&1; then
	  # Ok, looks like we can perform the test.
	  # Assume we have a broken sendfile(2).
          pike_cv_freebsd_sendfile_threadsafe="no"
	  if /usr/bin/nm -D /usr/lib/libc_r.so 2>&1 | grep _thread_sys_sendfile >/dev/null 2>&1; then
	    # Wee! They have actually added a wrapper for sendfile(2)!
	    pike_cv_freebsd_sendfile_threadsafe="yes"
	  else :; fi
	else :; fi
      else :; fi
    ])

    if test "$pike_cv_freebsd_sendfile_threadsafe" = "yes"; then
      AC_MSG_RESULT(yes)
    else
      AC_MSG_RESULT(no - disabling use of sendfile)
      AC_DEFINE(HAVE_BROKEN_SENDFILE)
    fi
  else
    if test "$pike_cv_sendfile_args" = "6"; then
      AC_MSG_RESULT([6 - HP/UX style])
      AC_DEFINE(HAVE_HPUX_SENDFILE)
    else
      AC_MSG_RESULT([4 - Linux style])
    fi
  fi
else
  :
fi

AC_MSG_CHECKING(if mkdir takes 1 or 2 arguments)
AC_CACHE_VAL(pike_cv_func_mkdir_args,[
AC_TRY_COMPILE([
#ifndef _LARGEFILE_SOURCE
#  define _FILE_OFFSET_BITS 64
#  define _LARGEFILE_SOURCE
#  define _LARGEFILE64_SOURCE 1
#endif
/* HPUX needs these too... */
#ifndef __STDC_EXT__
#  define __STDC_EXT__
#endif /* !__STDC_EXT__ */

#include <sys/types.h>
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
#ifdef HAVE_DIRECT_H
#include <direct.h>
#endif
],[
  mkdir("conftestdir",0666);
],pike_cv_func_mkdir_args=2,pike_cv_func_mkdir_args=1)
])

AC_MSG_RESULT($pike_cv_func_mkdir_args)
AC_DEFINE_UNQUOTED(MKDIR_ARGS,$pike_cv_func_mkdir_args)

if test x$ac_cv_func_readdir_r = xyes ; then
  AC_MSG_CHECKING(if readdir_r takes 2(old Solaris & HPUX) or 3(Posix) arguments)
  AC_CACHE_VAL(pike_cv_func_posix_readdir_r, [
    AC_TRY_COMPILE([
#ifndef _LARGEFILE_SOURCE
#  define _FILE_OFFSET_BITS 64
#  define _LARGEFILE_SOURCE
#  define _LARGEFILE64_SOURCE 1
#endif
/* HPUX needs these too... */
#ifndef __STDC_EXT__
#  define __STDC_EXT__
#endif /* !__STDC_EXT__ */

/* For _REENTRANT */
#include "../../machine.h"
#ifndef POSIX_SOURCE
#define POSIX_SOURCE
#endif
#include <sys/types.h>
#ifdef HAVE_DIRENT_H
#include <dirent.h>
#else
#ifdef HAVE_SYS_NDIR_H
#include <sys/ndir.h>
#endif
#ifdef HAVE_SYS_DIR_H
#include <sys/dir.h>
#endif
#ifdef HAVE_NDIR_H
#include <ndri.h>
#endif
#endif
#ifdef HAVE_SYS_PARAM_H
#include <sys/param.h>
#endif
#ifdef HAVE_SYS_SYSPROTO_H
#include <sys/sysproto.h>
#endif
], [
  exit(0);

  /* NOT REACHED */
  readdir_r((DIR *)0, (struct dirent *)0);
],pike_cv_func_posix_readdir_r=no,pike_cv_func_posix_readdir_r=yes)
  ])

if test x$pike_cv_func_posix_readdir_r = xyes ; then
  AC_MSG_RESULT(3 - POSIX)

  # Linux libc 5 has a broken POSIX readdir_r().
  # It always returns 9 (EBADF).
  AC_MSG_CHECKING(if readdir_r works)
  AC_CACHE_VAL(pike_cv_func_working_posix_readdir_r, [
    AC_TRY_RUN([
#ifndef _LARGEFILE_SOURCE
#  define _FILE_OFFSET_BITS 64
#  define _LARGEFILE_SOURCE
#  define _LARGEFILE64_SOURCE 1
#endif
/* HPUX needs these too... */
#ifndef __STDC_EXT__
#  define __STDC_EXT__
#endif /* !__STDC_EXT__ */

/* For _REENTRANT */
#include "../../machine.h"
#ifndef POSIX_SOURCE
#define POSIX_SOURCE
#endif
#include <sys/errno.h>
#ifdef HAVE_DIRENT_H
#include <dirent.h>
#else
#ifdef HAVE_SYS_NDIR_H
#include <sys/ndir.h>
#endif
#ifdef HAVE_SYS_DIR_H
#include <sys/dir.h>
#endif
#ifdef HAVE_NDIR_H
#include <ndri.h>
#endif
#endif
#ifdef HAVE_SYS_PARAM_H
#include <sys/param.h>
#endif
#ifdef HAVE_SYS_SYSPROTO_H
#include <sys/sysproto.h>
#endif

extern int errno;

int main()
{
  DIR *dir = opendir(".");
  char tmp[1024];
  struct dirent *d;
  int retval;

  if (!dir) {
    /* Failed to open dir */
    exit(1);
  }

  retval = readdir_r(dir, (struct dirent *)tmp, &d);

  if (!retval) {
    /* OK, got an entry */
    exit(0);
  }

  if (retval == -1) {
    /* Solaris returns -1 instead of errno */
    retval = errno;
  }

  if (retval == ENOENT) {
    /* No entries left */
    exit(0);
  }
  exit(retval);
}
], pike_cv_func_working_posix_readdir_r=yes,
   pike_cv_func_working_posix_readdir_r=no,
   pike_cv_func_working_posix_readdir_r=no)
  ])
  if test x$pike_cv_func_working_posix_readdir_r = xyes ; then
    AC_MSG_RESULT(yes)
    AC_DEFINE(HAVE_POSIX_READDIR_R)
  else
    AC_MSG_RESULT(no)
  fi
else
  AC_MSG_RESULT(2)

  AC_MSG_CHECKING(if readdir_r returns an int(HPUX) or a pointer(Solaris))
  AC_CACHE_VAL(pike_cv_func_solaris_style_readdir_r, [
    AC_TRY_RUN([
#ifndef _LARGEFILE_SOURCE
#  define _FILE_OFFSET_BITS 64
#  define _LARGEFILE_SOURCE
#  define _LARGEFILE64_SOURCE 1
#endif
/* HPUX needs these too... */
#ifndef __STDC_EXT__
#  define __STDC_EXT__
#endif /* !__STDC_EXT__ */

/* For _REENTRANT */
#include "../../machine.h"
#ifndef POSIX_SOURCE
#define POSIX_SOURCE
#endif
#include <sys/errno.h>
#ifdef HAVE_DIRENT_H
#include <dirent.h>
#else
#ifdef HAVE_SYS_NDIR_H
#include <sys/ndir.h>
#endif
#ifdef HAVE_SYS_DIR_H
#include <sys/dir.h>
#endif
#ifdef HAVE_NDIR_H
#include <ndri.h>
#endif
#endif
#ifdef HAVE_SYS_PARAM_H
#include <sys/param.h>
#endif
#ifdef HAVE_SYS_SYSPROTO_H
#include <sys/sysproto.h>
#endif

extern int errno;

int main()
{
  DIR *dir = opendir(".");
  char tmp[1024];
  unsigned long retval;

  retval = (unsigned long) readdir_r(dir, (struct dirent *)tmp);

  if (retval == (unsigned long)tmp) {
    /* Solaris */
    exit(0);
  } else if (retval == ~0UL) {
    /* HPUX */
    exit(1);
  } else if (!retval) {
    if (!errno) {
      /* HPUX */
      exit(1);
    } else {
      /* Solaris */
      exit(0);
    }
  } else {
    /* Unknown, but probably Solaris */
    exit(0);
  }
}
],pike_cv_func_solaris_style_readdir_r=yes,
  pike_cv_func_solaris_style_readdir_r=no,
  pike_cv_func_solaris_style_readdir_r=unknown)
  ])
  if test x$pike_cv_func_solaris_style_readdir_r = xyes ; then
    AC_MSG_RESULT(Solaris style)
    AC_DEFINE(HAVE_SOLARIS_READDIR_R)
  else
    if test x$pike_cv_func_solaris_style_readdir_r = xno ; then
      AC_MSG_RESULT(HPUX style)
      AC_DEFINE(HAVE_HPUX_READDIR_R)
    else
      AC_MSG_RESULT(Unknown)
    fi
  fi
fi

else :; fi

if test x$ac_cv_func_statvfs = xyes ; then
  AC_MSG_CHECKING(if the struct statvfs exists)
  AC_CACHE_VAL(pike_cv_struct_statvfs, [
    AC_TRY_COMPILE([
#ifndef _LARGEFILE_SOURCE
#  define _FILE_OFFSET_BITS 64
#  define _LARGEFILE_SOURCE
#  define _LARGEFILE64_SOURCE 1
#endif
/* HPUX needs these too... */
#ifndef __STDC_EXT__
#  define __STDC_EXT__
#endif /* !__STDC_EXT__ */

#ifndef POSIX_SOURCE
#define POSIX_SOURCE
#endif
#ifdef HAVE_SYS_PARAM_H
#include <sys/param.h>
#endif
#ifdef HAVE_SYS_SYSPROTO_H
#include <sys/sysproto.h>
#endif
#ifdef HAVE_SYS_TYPES_H
#include <sys/types.h>
#endif
#include <sys/stat.h>
#ifdef HAVE_SYS_VFS_H
#include <sys/vfs.h>
#endif
#ifdef HAVE_SYS_STATFS_H
#include <sys/statfs.h>
#endif
#ifdef HAVE_SYS_MOUNT_H
#include <sys/mount.h>
#endif
    ], [
      struct statfs st;
    ], [ pike_cv_struct_statvfs=yes
    ], [ pike_cv_struct_statvfs=no
    ])
  ])
  AC_MSG_RESULT($pike_cv_struct_statvfs)

  if test x$pike_cv_struct_statvfs = xyes; then
    AC_DEFINE(HAVE_STRUCT_STATVFS)

    AC_MSG_CHECKING(if the struct statvfs has the member f_fstr)
    AC_CACHE_VAL(pike_cv_struct_statvfs_f_fstr, [
      AC_TRY_COMPILE([
#ifndef _LARGEFILE_SOURCE
#  define _FILE_OFFSET_BITS 64
#  define _LARGEFILE_SOURCE
#  define _LARGEFILE64_SOURCE 1
#endif
/* HPUX needs these too... */
#ifndef __STDC_EXT__
#  define __STDC_EXT__
#endif /* !__STDC_EXT__ */

#ifndef POSIX_SOURCE
#define POSIX_SOURCE
#endif
#ifdef HAVE_SYS_PARAM_H
#include <sys/param.h>
#endif
#ifdef HAVE_SYS_SYSPROTO_H
#include <sys/sysproto.h>
#endif
#ifdef HAVE_SYS_TYPES_H
#include <sys/types.h>
#endif
#include <sys/stat.h>
#ifdef HAVE_SYS_VFS_H
#include <sys/vfs.h>
#endif
#ifdef HAVE_SYS_STATFS_H
#include <sys/statfs.h>
#endif
#ifdef HAVE_SYS_MOUNT_H
#include <sys/mount.h>
#endif
      ], [
        struct statvfs st;
        st.f_fstr[0] = 0;
      ], [ pike_cv_struct_statvfs_f_fstr=yes
      ], [ pike_cv_struct_statvfs_f_fstr=no
      ])
    ])
    AC_MSG_RESULT($pike_cv_struct_statvfs_f_fstr)
    if test x$pike_cv_struct_statvfs_f_fstr = xyes; then
      AC_DEFINE(HAVE_STATVFS_F_FSTR)
    else :; fi

###############################################################

    AC_MSG_CHECKING(if the struct statvfs has the member f_basetype)
    AC_CACHE_VAL(pike_cv_struct_statvfs_f_basetype, [
      AC_TRY_COMPILE([
#ifndef _LARGEFILE_SOURCE
#  define _FILE_OFFSET_BITS 64
#  define _LARGEFILE_SOURCE
#  define _LARGEFILE64_SOURCE 1
#endif
/* HPUX needs these too... */
#ifndef __STDC_EXT__
#  define __STDC_EXT__
#endif /* !__STDC_EXT__ */

#ifndef POSIX_SOURCE
#define POSIX_SOURCE
#endif
#ifdef HAVE_SYS_PARAM_H
#include <sys/param.h>
#endif
#ifdef HAVE_SYS_SYSPROTO_H
#include <sys/sysproto.h>
#endif
#ifdef HAVE_SYS_TYPES_H
#include <sys/types.h>
#endif
#include <sys/stat.h>
#ifdef HAVE_SYS_VFS_H
#include <sys/vfs.h>
#endif
#ifdef HAVE_SYS_STATFS_H
#include <sys/statfs.h>
#endif
#ifdef HAVE_SYS_MOUNT_H
#include <sys/mount.h>
#endif
      ], [
        struct statvfs st;
        st.f_basetype[0] = 0;
      ], [ pike_cv_struct_statvfs_f_basetype=yes
      ], [ pike_cv_struct_statvfs_f_basetype=no
      ])
    ])
    AC_MSG_RESULT($pike_cv_struct_statvfs_f_basetype)
    if test x$pike_cv_struct_statvfs_f_basetype = xyes; then
      AC_DEFINE(HAVE_STATVFS_F_BASETYPE)
    else :; fi

###############################################################

  else :; fi
else :; fi

if test x$ac_cv_func_statfs = xyes ; then
  AC_MSG_CHECKING(if statfs takes 2(BSD) or 4(SysV) arguments)
  AC_CACHE_VAL(pike_cv_func_sysv_statfs, [
    AC_TRY_COMPILE([
#ifndef _LARGEFILE_SOURCE
#  define _FILE_OFFSET_BITS 64
#  define _LARGEFILE_SOURCE
#  define _LARGEFILE64_SOURCE 1
#endif
/* HPUX needs these too... */
#ifndef __STDC_EXT__
#  define __STDC_EXT__
#endif /* !__STDC_EXT__ */

#ifndef POSIX_SOURCE
#define POSIX_SOURCE
#endif
#ifdef HAVE_SYS_PARAM_H
#include <sys/param.h>
#endif
#ifdef HAVE_SYS_SYSPROTO_H
#include <sys/sysproto.h>
#endif
#ifdef HAVE_SYS_TYPES_H
#include <sys/types.h>
#endif
#include <sys/stat.h>
#ifdef HAVE_SYS_VFS_H
#include <sys/vfs.h>
#endif
#ifdef HAVE_SYS_STATFS_H
#include <sys/statfs.h>
#endif
#ifdef HAVE_SYS_PARAM_H
#include <sys/param.h>
#endif
#ifdef HAVE_SYS_MOUNT_H
#include <sys/mount.h>
#endif
], [
  exit(0);

  /* NOT REACHED */
  /* NOTE:
   *   If there isn't any prototype for statfs this will succeed even
   *   on BSDs. This doesn't matter since the first two arguments are
   *   the same on both BSD and SysV.
   *	/grubba 1998-05-17
   */
  statfs((char *)0, (struct statfs *)0, 0, 0);
],pike_cv_func_sysv_statfs=yes,pike_cv_func_sysv_statfs=no)
  ])
  if test x$pike_cv_func_sysv_statfs = xyes ; then
    AC_MSG_RESULT([SysV style, or no prototype])
    AC_DEFINE(HAVE_SYSV_STATFS)
  else
    AC_MSG_RESULT(BSD style)
  fi

  AC_MSG_CHECKING(if the struct statfs exists)
  AC_CACHE_VAL(pike_cv_struct_statfs, [
    AC_TRY_COMPILE([
#ifndef _LARGEFILE_SOURCE
#  define _FILE_OFFSET_BITS 64
#  define _LARGEFILE_SOURCE
#  define _LARGEFILE64_SOURCE 1
#endif
/* HPUX needs these too... */
#ifndef __STDC_EXT__
#  define __STDC_EXT__
#endif /* !__STDC_EXT__ */

#ifndef POSIX_SOURCE
#define POSIX_SOURCE
#endif
#ifdef HAVE_SYS_PARAM_H
#include <sys/param.h>
#endif
#ifdef HAVE_SYS_SYSPROTO_H
#include <sys/sysproto.h>
#endif
#ifdef HAVE_SYS_TYPES_H
#include <sys/types.h>
#endif
#include <sys/stat.h>
#ifdef HAVE_SYS_VFS_H
#include <sys/vfs.h>
#endif
#ifdef HAVE_SYS_STATFS_H
#include <sys/statfs.h>
#endif
#ifdef HAVE_SYS_MOUNT_H
#include <sys/mount.h>
#endif
    ], [
      struct statfs st;
    ], [ pike_cv_struct_statfs=yes
    ], [ pike_cv_struct_statfs=no
    ])
  ])
  AC_MSG_RESULT($pike_cv_struct_statfs)
  if test x$pike_cv_struct_statfs = xyes; then
    AC_DEFINE(HAVE_STRUCT_STATFS)

    AC_MSG_CHECKING(if the struct statfs has the member f_fsid)
    AC_CACHE_VAL(pike_cv_struct_statfs_f_fsid, [
      AC_TRY_COMPILE([
#ifndef _LARGEFILE_SOURCE
#  define _FILE_OFFSET_BITS 64
#  define _LARGEFILE_SOURCE
#  define _LARGEFILE64_SOURCE 1
#endif
/* HPUX needs these too... */
#ifndef __STDC_EXT__
#  define __STDC_EXT__
#endif /* !__STDC_EXT__ */

#ifndef POSIX_SOURCE
#define POSIX_SOURCE
#endif
#ifdef HAVE_SYS_PARAM_H
#include <sys/param.h>
#endif
#ifdef HAVE_SYS_SYSPROTO_H
#include <sys/sysproto.h>
#endif
#ifdef HAVE_SYS_TYPES_H
#include <sys/types.h>
#endif
#include <sys/stat.h>
#ifdef HAVE_SYS_VFS_H
#include <sys/vfs.h>
#endif
#ifdef HAVE_SYS_STATFS_H
#include <sys/statfs.h>
#endif
#ifdef HAVE_SYS_MOUNT_H
#include <sys/mount.h>
#endif
      ], [
        struct statfs st;
        st.f_fsid = 0;
      ], [ pike_cv_struct_statfs_f_fsid=yes
      ], [ pike_cv_struct_statfs_f_fsid=no
      ])
    ])
    AC_MSG_RESULT($pike_cv_struct_statfs_f_fsid)
    if test x$pike_cv_struct_statfs_f_fsid = xyes; then
      AC_DEFINE(HAVE_STATFS_F_FSID)
    else :; fi

    AC_MSG_CHECKING(if the struct statfs has the member f_bavail)
    AC_CACHE_VAL(pike_cv_struct_statfs_f_bavail, [
      AC_TRY_COMPILE([
#ifndef _LARGEFILE_SOURCE
#  define _FILE_OFFSET_BITS 64
#  define _LARGEFILE_SOURCE
#  define _LARGEFILE64_SOURCE 1
#endif
/* HPUX needs these too... */
#ifndef __STDC_EXT__
#  define __STDC_EXT__
#endif /* !__STDC_EXT__ */

#ifndef POSIX_SOURCE
#define POSIX_SOURCE
#endif
#ifdef HAVE_SYS_PARAM_H
#include <sys/param.h>
#endif
#ifdef HAVE_SYS_SYSPROTO_H
#include <sys/sysproto.h>
#endif
#ifdef HAVE_SYS_TYPES_H
#include <sys/types.h>
#endif
#include <sys/stat.h>
#ifdef HAVE_SYS_VFS_H
#include <sys/vfs.h>
#endif
#ifdef HAVE_SYS_STATFS_H
#include <sys/statfs.h>
#endif
#ifdef HAVE_SYS_MOUNT_H
#include <sys/mount.h>
#endif
      ], [
        struct statfs st;
        st.f_bavail = 0;
      ], [ pike_cv_struct_statfs_f_bavail=yes
      ], [ pike_cv_struct_statfs_f_bavail=no
      ])
    ])
    AC_MSG_RESULT($pike_cv_struct_statfs_f_bavail)
    if test x$pike_cv_struct_statfs_f_bavail = xyes; then
      AC_DEFINE(HAVE_STATFS_F_BAVAIL)
    else :; fi
  else
    # No struct statfs. We might be running ULTRIX,
    # so check for struct fs_data.
    AC_MSG_CHECKING(if the struct fs_data exists)
    AC_CACHE_VAL(pike_cv_struct_fs_data, [
      AC_TRY_COMPILE([
#ifndef _LARGEFILE_SOURCE
#  define _FILE_OFFSET_BITS 64
#  define _LARGEFILE_SOURCE
#  define _LARGEFILE64_SOURCE 1
#endif
/* HPUX needs these too... */
#ifndef __STDC_EXT__
#  define __STDC_EXT__
#endif /* !__STDC_EXT__ */

#ifndef POSIX_SOURCE
#define POSIX_SOURCE
#endif
#ifdef HAVE_SYS_PARAM_H
#include <sys/param.h>
#endif
#ifdef HAVE_SYS_SYSPROTO_H
#include <sys/sysproto.h>
#endif
#ifdef HAVE_SYS_TYPES_H
#include <sys/types.h>
#endif
#include <sys/stat.h>
#ifdef HAVE_SYS_VFS_H
#include <sys/vfs.h>
#endif
#ifdef HAVE_SYS_STATFS_H
#include <sys/statfs.h>
#endif
#ifdef HAVE_SYS_MOUNT_H
#include <sys/mount.h>
#endif
      ], [
        struct fs_data st;
      ], [ pike_cv_struct_fs_data=yes
      ], [ pike_cv_struct_fs_data=no
      ])
    ])
    AC_MSG_RESULT($pike_cv_struct_fs_data)
    if test x$pike_cv_struct_fs_data = xyes; then
      AC_DEFINE(HAVE_STRUCT_FS_DATA)
    else :; fi
  fi
else :; fi

AC_MSG_CHECKING(for working (and failsafe) strerror)
AC_CACHE_VAL(pike_cv_func_failsafe_strerror,
[
AC_TRY_RUN([
#include <stdio.h>
#include <string.h>
int main()
{
  int e;
  char *s;
  for(e=0;e<256;e++) if(strerror(e)) if(strerror(e)[0]=='\b') exit(1);
  exit(0);
}
],pike_cv_func_failsafe_strerror=yes,pike_cv_func_failsafe_strerror=no,
  pike_cv_func_failsafe_strerror=no)
])

if test "$pike_cv_func_failsafe_strerror" = yes; then
  AC_MSG_RESULT(yes)
  AC_DEFINE(HAVE_STRERROR)
else
  AC_MSG_RESULT(no)
fi

AC_MSG_CHECKING(for select on AF_UNIX sockets)
AC_CACHE_VAL(pike_cv_select_on_unix_sockets,
[
AC_TRY_RUN([
#ifndef _LARGEFILE_SOURCE
#  define _FILE_OFFSET_BITS 64
#  define _LARGEFILE_SOURCE
#  define _LARGEFILE64_SOURCE 1
#endif
/* HPUX needs these too... */
#ifndef __STDC_EXT__
#  define __STDC_EXT__
#endif /* !__STDC_EXT__ */

#ifndef POSIX_SOURCE
#define POSIX_SOURCE
#endif
#include <stdio.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <netinet/in.h>
#include <errno.h>
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
#include <sys/time.h>
#ifdef HAVE_SYS_SELECT_H
#include <sys/select.h>
#endif
#ifdef HAVE_SYS_SOCKET_H
#include <sys/socket.h>
#endif

int main()
{
  fd_set tmp;
  struct timeval foo;
  int fds[2];
  char x;

  if(socketpair(AF_UNIX, SOCK_STREAM, 0, fds)<0)
  {
    fprintf(stderr,"socketpair() failed\n");
    exit(1);
  }

  if(shutdown(fds[1],1))
  {
    fprintf(stderr,"shutdown failed\n");
    exit(9);
  }
 
  if(shutdown(fds[0],1))
  {
    fprintf(stderr,"shutdown failed\n");
    exit(9);
  }
  close(fds[0]);

  foo.tv_sec=5;
  foo.tv_usec=0;

  FD_ZERO(&tmp);
  FD_SET(fds[1], &tmp);
  if(select(fds[1]+1,&tmp, 0,0,&foo)<=0)
  {
    fprintf(stderr,"select() does report closed sockets properly\n");
    exit(2);
  }

  if(!FD_ISSET(fds[1], &tmp))
  {
    fprintf(stderr,"FD_ISSET does not report closed sockets properly\n");
    exit(3);
  }

  if(socketpair(AF_UNIX, SOCK_STREAM, 0, fds)<0)
    exit(1);

  foo.tv_sec=1;
  foo.tv_usec=0;
  FD_ZERO(&tmp);
  FD_SET(fds[1], &tmp);

  if(select(fds[1]+1,&tmp, 0,0,&foo)>0)
  {
    fprintf(stderr,"select() always falls through\n");
    exit(4);
  }

  if(write(fds[0],"x",1)!=1)
  {
    fprintf(stderr,"write() failed\n");
    exit(1);
  }
  
  foo.tv_sec=1;
  foo.tv_usec=0;
  FD_ZERO(&tmp);
  FD_SET(fds[1], &tmp);

  if(select(fds[1]+1,&tmp, 0,0,&foo)<=0)
  {
    fprintf(stderr,"select() never falls through\n");
    exit(5);
  }
 
  if(!FD_ISSET(fds[1], &tmp))
  {
    fprintf(stderr,"select() does not modify read set properly\n");
    exit(6);
  }

  if(read(fds[1], &x, 1)!=1)
  {
    fprintf(stderr,"read() failed\n");
    exit(1);
  }

  if(shutdown(fds[0],1))
  {
    fprintf(stderr,"socketpair() failed\n");
    exit(1);
  }

  foo.tv_sec=1;
  foo.tv_usec=0;
  FD_ZERO(&tmp);
  FD_SET(fds[1], &tmp);

  if(select(fds[1]+1,&tmp, 0,0,&foo)<=0)
  {
    fprintf(stderr,"select() does not report shutdown()\n");
    exit(7);
  }
 
  if(!FD_ISSET(fds[1], &tmp))
  {
    fprintf(stderr,"select() does not modify read set properly on shutdown()\n");
    exit(8);
  }

  exit(0);
}


],pike_cv_select_on_unix_sockets=yes,pike_cv_select_on_unix_sockets=no,
  pike_cv_select_on_unix_sockets=no)
])

AC_MSG_RESULT($pike_cv_select_on_unix_sockets)
if test x$pike_cv_select_on_unix_sockets = xyes ; then
  AC_DEFINE(UNIX_SOCKETS_WORKS_WITH_SHUTDOWN)
fi


AC_MSG_CHECKING(size of socket buffers)
AC_CACHE_VAL(pike_cv_socket_buffer_max,
[
if test "x$enable_binary" = "xno"; then
  pike_cv_socket_buffer_max=0
else
AC_TRY_RUN([
#ifndef _LARGEFILE_SOURCE
#  define _FILE_OFFSET_BITS 64
#  define _LARGEFILE_SOURCE
#  define _LARGEFILE64_SOURCE 1
#endif
/* HPUX needs these too... */
#ifndef __STDC_EXT__
#  define __STDC_EXT__
#endif /* !__STDC_EXT__ */

#ifndef POSIX_SOURCE
#define POSIX_SOURCE
#endif
#include <stdio.h>
#include <sys/types.h>
#include <sys/param.h>
#include <errno.h>
#include <fcntl.h>
#include <signal.h>
#include <sys/wait.h>
#include <sys/socket.h>

int main()
{
  FILE *f;
  int fd, try, tmp;

  fd=socket(AF_INET, SOCK_STREAM, 0);

  if(fd < 0) return 1;

  try=1024;
  while(try < 65000)
  {
    tmp=try*2;
    if(setsockopt(fd, SOL_SOCKET, SO_SNDBUF, (char *)&tmp, sizeof(int)) < 0)
    {
      break;
    }
    try*=2;
  }
  f=fopen("conftest.out.2","w");
  fprintf(f,"%d\n",try);
  fclose(f);
  
  return 0;
}],
pike_cv_socket_buffer_max=`cat conftest.out.2`
,
pike_cv_socket_buffer_max=0,
pike_cv_socket_buffer_max=0
)
fi
])

AC_DEFINE_UNQUOTED(SOCKET_BUFFER_MAX,$pike_cv_socket_buffer_max)
AC_MSG_RESULT($pike_cv_socket_buffer_max)


AC_MSG_CHECKING(for working getcwd)
AC_CACHE_VAL(pike_cv_func_working_getcwd,
[
AC_TRY_RUN([
#ifndef _LARGEFILE_SOURCE
#  define _FILE_OFFSET_BITS 64
#  define _LARGEFILE_SOURCE
#  define _LARGEFILE64_SOURCE 1
#endif
/* HPUX needs these too... */
#ifndef __STDC_EXT__
#  define __STDC_EXT__
#endif /* !__STDC_EXT__ */

#ifndef POSIX_SOURCE
#define POSIX_SOURCE
#endif
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
#ifdef HAVE_DIRECT_H
#include <direct.h>
#endif /* HAVE_DIRECT_H */
#include <signal.h>

#ifndef __NT__
int sig_child(int arg)
{
#ifdef HAVE_WAITPID
  waitpid(-1,0,WNOHANG);
#else
#ifdef HAVE_WAIT3
  wait3(0,WNOHANG,0);
#else
#ifdef HAVE_WAIT4
  wait3(-1,0,WNOHANG,0);
#else

  /* Leave'em hanging */

#endif /* HAVE_WAIT4 */
#endif /* HAVE_WAIT3 */
#endif /* HAVE_WAITPID */

#ifdef SIGNAL_ONESHOT
  my_signal(SIGCHLD, sig_child);
#endif
}

int sig_alarm() { exit(1); }
#endif /* !__NT__ */

int main()
{
  char *tmp;
#ifndef __NT__
  signal(SIGCHLD,sig_child);
  signal(SIGALRM,sig_alarm);
  alarm(4);
#endif /* !__NT__ */
  tmp=getcwd(0,10000);
  if(tmp && strlen(tmp) <10000) exit(0);
  exit(1);
}
],pike_cv_func_working_getcwd=yes,pike_cv_func_working_getcwd=no,
  pike_cv_func_working_getcwd=yes)])

if test "$pike_cv_func_working_getcwd" = yes; then
  AC_MSG_RESULT(yes)
  AC_DEFINE(HAVE_WORKING_GETCWD)
else
  AC_MSG_RESULT(no)
fi

AC_MSG_CHECKING(if filesystem notifications exists)
AC_CACHE_VAL(pike_cv_have_notifications, [
  AC_TRY_COMPILE([
  #ifdef __linux__
  #define _GNU_SOURCE
  #include <fcntl.h>
  #endif
  ],[
       #ifdef __linux__
         int test = F_NOTIFY;
       #endif
  ], [ pike_cv_have_notifications=yes ], [ pike_cv_have_notifications=no ])
])
if test "$pike_cv_have_notifications" = "yes"; then
  AC_MSG_RESULT(yes)
  AC_DEFINE(HAVE_NOTIFICATIONS)
else
  AC_MSG_RESULT(no)
fi

if test yes = "$ac_cv_func_grantpt"; then
  pt_chmod_dirs=""
  case "$pike_cv_sys_os" in
    Solaris|HP-UX|OSF1) pt_chmod_dirs="/lib /usr/lib /lbin /usr/lbin" ;;
  esac
  if test x = x"$pt_chmod_dirs"; then
    :
  else
    AC_MSG_CHECKING(for pt_chmod or chgpt since OS is $pike_cv_sys_os)
    AC_CACHE_VAL(pike_cv_pt_chmod_path, [
      pike_cv_pt_chmod_path=no
      for i in $pt_chmod_dirs; do
	for j in pt_chmod cghpt; do
          if test -x ${i}/${j}; then
            pike_cv_pt_chmod_path="${i}/${j}"
	    break
          else
            :
          fi
	done
	if test no = "$pike_cv_pt_chmod_path"; then
	  :
	else
	  break
	fi
      done
    ])
    AC_MSG_RESULT($pike_cv_pt_chmod_path)
    if test "no" = pike_cv_pt_chmod_path; then
      :
    else
      AC_DEFINE_UNQUOTED(USE_PT_CHMOD,"$pike_cv_pt_chmod_path")
    fi
  fi
else
  :
fi

AC_OUTPUT(Makefile,echo FOO >stamp-h )


