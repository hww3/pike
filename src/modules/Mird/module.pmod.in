#pike __REAL_VERSION__

#if constant(@module@.Mird)

//!	The Mird module doubles as the Mird database class.
class Mird
{

   constant Glue=@module@;

   constant TABLE2ID_TABLE=1;
   constant ID2TABLE_TABLE=2;

   Glue.Mird mird;

#define NEXT_TABLE "_mird_magic_next_free_table"

   mapping table2id=([]); 
   mapping id2table=([]); 
   int next_table;

   function(int,int|string:string) _fetch;
      
   //!	Opens the database using the given filename. Note that
   //!	the file @tt{@[filename]+".journal"@} will be created too.
   //!	
   //!	Possible options:
   //!
   //!	@mapping
   //!
   //!	  @member string "flags"
   //!           Database flags, see below.
   //!
   //!    @member int "block_size"
   //!           Database block size; must be even 2^n.
   //!           Database size is limited to 2^32 blocks, ie block_size*2^32 
   //!           (8192*2^(32-5) is approximately 1Tb)
   //!           (2048)
   //!        
   //!    @member int "frag_bits"
   //!           This sets the number of fragments in a fragmented block,
   //!           and address bits to locate them.
   //!           The number of fragments in a fragmented block is equal
   //!           to 2^frag_bits-1, by default 2^5-1=32-1=31.
   //!          
   //!           This steals bits from the 32 bit address used to point out
   //!           a chunk.
   //!           (5)
   //!     
   //!    @member int "hashtrie_bits"
   //!           This is the number of bits in each hash-trie hash; 
   //!           4*2^n must be a lot less than block_size.
   //!           (5)
   //!     
   //!    @member int "cache_size"
   //!           This is the number of blocks cached from the database;
   //!           this is used for both the read- and the write cache.
   //!           Note that the memory usage is constant,
   //!           approximately block_size*cache_size bytes.
   //!           (32)
   //!     
   //!    @member int "cache_search_length"
   //!           This is the closed hash maximum search length to find
   //!           a block in the cache; note that this will result in 
   //!           linear time usage.
   //!           (8)
   //!     
   //!    @member int "max_free_frag_blocks"
   //!           This is how many blocks with free space that is 
   //!           kept in a list to be used when a transaction
   //!           is running. The closest fit of usage of these blocks are
   //!           where the data will be stored.
   //!           (10)
   //!     
   //!    @member int "file_mode"
   //!           This is the default mode the files are opened with;
   //!           although affected by UMASK
   //!           (0666)
   //!     
   //!    @member int "journal_readback_n"
   //!           This is how many journal entries are read back
   //!           at once at transaction finish, cancel or copy time.
   //!           Bytes needed is approximately 24*this number
   //!           (200)
   //!	@endmapping
   //! 
   //! 	@tt{"flags"@} is a string with any of these characters:
   //!  @string
   //!    @value 'r'
   //! 	    Readonly.
   //!    @value 'R'
   //! 	    Readonly in a live system (one process writes, many reads).
   //!    @value 'n'
   //! 	    Don't create if it doesn't exist.
   //!    @value 'x'
   //! 	    Exclusive (always create).
   //!    @value 's'
   //! 	    Call fsync(3) when finishing transactions.
   //!    @value 'S'
   //! 	    Call sync(2) after fsync(3).
   //!    @value 'j'
   //! 	    Complain if journal file is gone missing.
   //! 	@endstring
   void create(string filename, void|mapping options)
   {
      mird=Glue.Mird(filename,options||([]));

      mixed err=catch 
      { 
	 next_table=(int)mird->fetch(TABLE2ID_TABLE,NEXT_TABLE); 
      };
      if (err || !next_table)
      {
	 next_table=max(ID2TABLE_TABLE,TABLE2ID_TABLE)+1;
	 Glue.Transaction mtr=Glue.Transaction(mird);
	 mtr->new_stringkey_table(TABLE2ID_TABLE);
	 mtr->new_hashkey_table(ID2TABLE_TABLE);
	 mtr->store(TABLE2ID_TABLE,NEXT_TABLE,(string)next_table);
	 mtr->close();
      }

      _fetch=mird->fetch;

      call_out(sync_loop,60,60);
   }

   Glue.Scanner _scanner(int ... args)
   {
      return Glue.Scanner(mird,@args);
   }

   Mird _store(int table_id,int|string key,string data)
   {
      Transaction tr=transaction();
      tr->_store(table_id,key,data);
      tr->close();
      return this_object();
   }

   //!	Gives back the table object for the specified table
   //!	in the database.
   Table table(string name)
   {
      if (name==NEXT_TABLE) error("illegal name\n");
      if (!table2id[name]) 
      {
	 string d=mird->fetch(TABLE2ID_TABLE,name);
	 if (!d) error("no such table (%O)\n",name);
	 table2id[name]=(int)d;
      }
      return Table(this_object(),table2id[name]);
   }


   //! @decl vTable vtable(string name)
   //! @decl vzTable vtable(string name)
   //! 	A vTable is just like a @[Table], except that the
   //!     values can be anything, not just strings. The
   //!     data is @[encode_value()]'ed before storage.
   //!
   //! 	A vzTable is just like a @[vTable], except that the
   //!     values are both encoded and then packed using Gz.

   vTable vtable(string name)
   {
      if (name==NEXT_TABLE) error("illegal name\n");
      if (!table2id[name]) 
      {
	 string d=mird->fetch(TABLE2ID_TABLE,name);
	 if (!d) error("no such table (%O)\n",name);
	 table2id[name]=(int)d;
      }
      return vTable(this_object(),table2id[name]);
   }

   vzTable vztable(string name)
   {
      if (name==NEXT_TABLE) error("illegal name\n");
      if (!table2id[name]) 
      {
	 string d=mird->fetch(TABLE2ID_TABLE,name);
	 if (!d) error("no such table (%O)\n",name);
	 table2id[name]=(int)d;
      }
      return vzTable(this_object(),table2id[name]);
   }

   //! Returns the name of the table with id @[id].
   string table_name(int id)
   {
      if (id2table[id]) return id2table[id];
      string d=mird->fetch(ID2TABLE_TABLE,id);
      if (!d) return 0;
      return id2table[id]=d;
   }

   //! @decl Table new_stringkey_table(string name)
   //! @decl Table new_hashkey_table(string name)
   //!	Create a new table in the database.
   //! @note 
   //!	A transaction will be created when
   //!	calling these on the Database level.

   Table new_stringkey_table(string name)
   {
      Transaction tr=transaction();
      tr->new_stringkey_table(name);
      tr->close();
      return table(name);
   }

   Table new_hashkey_table(string name)
   {
      Transaction tr=transaction();
      tr->new_hashkey_table(name);
      tr->close();
      return table(name);
   }

   void delete_table(string name)
   {
      Transaction tr=transaction();
      tr->delete_table(name);
      tr->close();
   }

   //! 	Creates a new transaction
   Transaction transaction()
   {
      return Transaction(this_object());
   }

   Transaction ctransaction()
   {
      return cTransaction(this_object());
   }

   //!	Gives a list of all tables in the database.
   array(string) tables()
   {
      return indices(Table(this_object(),TABLE2ID_TABLE))-({NEXT_TABLE});
   }

   //! @decl object sync()
   //! @decl object sync_please()
   //!	Syncs the database (syncs against disc and 
   //!	starts to reuse any space that is freed),
   //!	sync_please() does this when the last living
   //!	transaction is finished.

   //! @decl object sync_loop(int seconds)
   //!	Starts a call_out loop that will call sync_please
   //!	once every given interval. 0 or fewer seconds will
   //!	shut down the loop.
   //!	Default is 1 minute (60 seconds).

   Mird sync()
   {
      gc(); // kill any leftover transactions
      mird->sync();
      return this_object();
   }

   Mird sync_please()
   {
      gc(); // kill any leftover transactions
      mird->sync_please();
      return this_object();
   }

   Mird sync_loop(int seconds)
   {
      remove_call_out(sync_loop);
      if (seconds<=0) return this_object();
      if (_refs(this_object())>4) // otherwise, we're last -> close()
	 call_out(sync_loop,seconds,seconds);
      return sync_please();
   }

   //! @decl void close()
   //! @decl void destroy()
   //!	Syncs and closes the database

   void close()
   {
      remove_call_out(sync_loop);
      if (mird) mird->close();
   }

   function destroy=close;

   //!	A Mird table has approximately the same
   //!	characteristics as a Pike mapping. You 
   //!	store key:value pairs in it, you get values from keys,
   //!	you delete keys.
   //!
   //!	For convinience, the Table object overloads @tt{`[]()@},
   //!	@tt{`[]=()@}, @tt{_indices()@} and @tt{_values()@}.
   class Table 
   {
      int table_id;
      object(Mird)|object(Transaction) parent;

      //! @decl void create(object parent, int table_id)
      void create(object _parent,int _table_id)
      {
	 parent=_parent;
	 table_id=_table_id;
      }

      //! @decl Mird.Glue.Scanner scanner()
      //! @decl Mird.Glue.Scanner scanner(int key)
      //!	Creates a scanner over the called table;
      //!	if @[key] is given, continue at that key
      //!	(as returned from @[Mird.Glue.Scanner.next_key()]).
      //!
      //!	A scanner can be used to loop over all elements in a table.
      Mird.Glue.Scanner scanner(int ... key)
      {
	 return parent->_scanner(table_id,@key);
      }

      //! @decl string `[](int|string key)
      //! @decl string `[]=(int|string key,string value)
      //! @decl array(int|string) _indices()
      //! @decl array(int|string) _values()
      //!	Get and store key:value pairs, list the table.
      //!
      //! @note
      //!	All storage in the table will create a transaction,
      //!	if we're not already in a transaction. 

      string `[](int|string key)
      {
	 string s=parent->_fetch(table_id,key);
	 return s;
      }

      string `[]=(int|string key,string value)
      {
	 parent->_store(table_id,key,value);
	 return value;
      }

      array(int|string) _indices()
      {
	 array keys=({});
	 Glue.Scanner sc=scanner();
	 mapping m;
	 while ( (m=sc->read(100)) ) keys+=indices(m);
	 return keys;
      }

      array(int|string) _values()
      {
	 array vals=({});
	 Glue.Scanner sc=scanner();
	 mapping m;
	 while ( (m=sc->read(100)) ) vals+=values(m);
	 return vals;
      }

      //! @decl mapping cast("mapping")
      //! @decl array cast("array")
      //!	It is possible to cast the Table to a mapping
      //!	or array; this will read all contents of the table,
      //!	so beware if you have a big table.

      array|mapping cast(string to)
      {
	 if (sscanf(to,"array%*s"))
	 {
	    array tupels=({});
	    Glue.Scanner sc=scanner();
	    mapping m;
	    while ( (m=sc->read(100)) ) tupels+=(array)m;
	    return tupels;
	 }
	 if (sscanf(to,"mapping%*s"))
	 {
	    mapping tupels=([]);
	    Glue.Scanner sc=scanner();
	    mapping m;
	    while ( (m=sc->read(100)) ) tupels+=m;
	    return tupels;
	 }
	 error("illegal argument 1 to cast\n");
      }
   }

   class v0Table
   {
      inherit Table;

      string pack(mixed v);
      mixed unpack(string s);

      mixed `[](int|string key)
      {
	 string s=parent->_fetch(table_id,key);
	 if (s) return unpack(s);
	 return ([])[0];
      }

      string `[]=(int|string key,mixed value)
      {
	 parent->_store(table_id,key,pack(value));
	 return value;
      }


      array(mixed) _values()
      {
	 array vals=({});
	 Glue.Scanner sc=parent->_scanner(table_id);
	 mapping m;
	 while ( (m=sc->read(100)) ) vals+=values(m);
	 return map(vals,unpack);
      }

      array|mapping cast(string to)
      {
	 if (sscanf(to,"array%*s"))
	 {
	    array tupels=({});
	    Glue.Scanner sc=parent->_scanner(table_id);
	    mapping m;
	    while ( (m=sc->read(100)) ) tupels+=(array)m;
	    return map(tupels,lambda(array(string) v)
			      {
				 return ({v[0],unpack(v[1])});
			      });
	 }
	 if (sscanf(to,"mapping%*s"))
	 {
	    mapping tupels=([]);
	    Glue.Scanner sc=parent->_scanner(table_id);
	    mapping m;
	    while ( (m=sc->read(100)) ) 
	       tupels+=m;
	    return (mapping)map((array)tupels,
				lambda(array(string) v)
				{
				   return ({v[0],unpack(v[1])});
				});
	 }
	 error("illegal argument 1 to cast\n");
      }
   }

   //! 	A @[vTable] is just like a @[Table], except that the
   //!     values can be anything, not just strings. The
   //!     data is @[encode_value()]'ed before storage.
   //!
   class vTable
   {
      //! inherits Table
      inherit v0Table;

      string pack(mixed v) 
      { 
	 return encode_value(v); 
      }

      mixed unpack(string s) 
      { 
	 return s?decode_value(s):([])[0];
      }
   }

   //!     This is just like a normal table, but all data is encode_value()ed,
   //!     and gzipped, and unpacked if reading, for convinience. 
   //!
   class vzTable
   {
      //! inherits Table
      inherit v0Table;

      string pack(mixed v) 
      { 
	 return Gz.deflate()->deflate(encode_value(v)); 
      }

      mixed unpack(string s) 
      { 
	 if (!s) return ([])[0];
	 return decode_value(Gz.inflate()->inflate(s)); 
      }
   }

   //!	A Transaction is the environment which in a change
   //!	to the database can be made. Simplified, the database
   //!	is not changed until the transaction is closed. More 
   //!	then one change to the database can be performed within
   //!	one transaction.
   //!
   //!	If the same entries in the database were changed during
   //!	the lifespan of the transaction, it cannot be closed but
   //!	has to be cancelled.
   class Transaction
   {
      Mird parent;
      Glue.Transaction mtr;
      mapping table2id=([]);
      int refresh_at_close=0;

      function(int,int|string:string) _fetch;
      function(int:Glue.Scanner) _scanner;
      
      void create(object _parent)
      {
	 parent=_parent;
	 mtr=Glue.Transaction(parent->mird);
	 _fetch=mtr->fetch;
	 _scanner=lambda(int ... args) 
		  { 
		     return Glue.Scanner(mtr,@args); 
		  };
      }

      Transaction _store(int table_id,int|string key,string value)
      {
	 if (!value) 
	    mtr->delete(table_id,key);
	 else
	    mtr->store(table_id,key,value);
	 return this_object();
      }

      //! @decl Table table(string name)
      //! @decl vTable vtable(string name)
      //! @decl vzTable vztable(string name)
      //!	Creates a @[Table], @[vTable] or @[vzTable]
      //!	object for the specified table,
      //!	which emulates a mapping and in which
      //!	you can make changes to the database or
      //!	do lookups.

      Table table(string name)
      {
	 if (name==NEXT_TABLE) error("illegal name\n");
	 int id;
	 if (!(id=table2id[name]))
	 {
	    if (parent->table2id[name])
	       id=table2id[name]=parent->table2id[name];
	    else
	    {
	       string d=mtr->fetch(TABLE2ID_TABLE,name);
	       if (!d) error("no such table (%O)\n",name);
	       id=table2id[name]=(int)d;
	    }
	 }
	 return Table(this_object(),id);
      }

      vTable vtable(string name)
      {
	 if (name==NEXT_TABLE) error("illegal name\n");
	 if (!table2id[name]) 
	 {
	    string d=mird->fetch(TABLE2ID_TABLE,name);
	    if (!d) error("no such table (%O)\n",name);
	    table2id[name]=(int)d;
	 }
	 return vTable(this_object(),table2id[name]);
      }

      //! @decl Table new_stringkey_table(string name)
      //! @decl Table new_hashkey_table(string name)
      //!	Creates a new table in the database.
      //!	A stringkey table is a mapping from string to string,
      //!	and a hashkey table is mapping from int to string.
      //!

      Table new_stringkey_table(string name)
      {
	 string d=mtr->fetch(TABLE2ID_TABLE,name);
	 if (d) error("table already exist");
	 int no=parent->next_table++;
	 mtr->store(TABLE2ID_TABLE,name,(string)no);
	 mtr->store(ID2TABLE_TABLE,no,name);
	 mtr->store(TABLE2ID_TABLE,NEXT_TABLE,(string)parent->next_table);
	 mtr->new_stringkey_table(no);
	 refresh_at_close=1;
	 return table(name);
      }

      Table new_hashkey_table(string name)
      {
	 string d=mtr->fetch(TABLE2ID_TABLE,name);
	 if (d) error("table already exist");
	 int no=parent->next_table++;
	 mtr->store(TABLE2ID_TABLE,name,(string)no);
	 mtr->store(ID2TABLE_TABLE,no,name);
	 mtr->store(TABLE2ID_TABLE,NEXT_TABLE,(string)parent->next_table);
	 mtr->new_hashkey_table(no);
	 refresh_at_close=1;
	 return table(name);
      }

      //!	Removes a table and all items in it
      void delete_table(string name)
      {
	 if (name==NEXT_TABLE) error("no such table (%O)\n",name);
      
	 int no;
	 if (!(no=table2id[name]))
	 {
	    string d=mtr->fetch(TABLE2ID_TABLE,name);
	    if (!d) error("no such table (%O)",name);
	    no=(int)d;
	 }
	 catch { mtr->delete_table(no); };
	 m_delete(table2id,name);
	 m_delete(id2table,no);
	 mtr->delete(TABLE2ID_TABLE,name);
	 mtr->delete(ID2TABLE_TABLE,no);
	 refresh_at_close=1;
      }

      //! Returns the names of the tables in the database.
      //!
      array(string) tables()
      {
	 return indices(Table(this_object(),TABLE2ID_TABLE));
      }

      //!	Finishes a transaction. This throws exceptions
      //!	if there were conflicts.
      //!
      void close()
      {
	 mtr->close();
	 if (refresh_at_close) 
	    parent->table2id=parent->id2table=([]);
      }

      //! @decl void cancel()
      //! @decl void destroy()
      //!	Cancels (rewinds) a transaction.
      //!

      void cancel()
      {
	 mtr->cancel();
      }

      void destroy()
      {
	 if (mtr) destruct(mtr);
      }
   }

   //! Caching transaction
   class cTransaction
   {
      inherit Transaction;

      mapping edited=([]);

      void create(object _parent)
      {
	 ::create(_parent);

	 _fetch=cfetch;
	 _scanner=lambda(int ... args) 
		  { 
	       // this'll do for now
		     flush();
		     return Glue.Scanner(mtr,@args); 
		  };
      }

      Transaction _store(int table_id,int|string key,string value)
      {
	 if ((<TABLE2ID_TABLE,ID2TABLE_TABLE>)[table_id])
	    return ::_store(table_id,key,value);
	 if (!edited[table_id]) edited[table_id]=([]);
	 edited[table_id][key]=value;
	 return this_object();
      }

      string cfetch(int table_id,int|string key)
      {
	 mixed m;
         // this will not be a TABLE table since we don't store those:
	 if ((m=edited[table_id]) &&
	     (m=m[key])) return m;
	 return mtr->fetch(table_id,key);
      }

      void flush()
      {
	 foreach (indices(edited),int table)
	    foreach ((array)(edited[table]),[int|string key,string value])
	       if (value)
		  mtr->store(table,key,value);
	       else
		  mtr->delete(table,key);
	 edited=([]);
      }

      void close()
      {
	 flush();
	 ::close();
      }

      void cancel()
      {
	 edited=([]);
	 ::cancel();
      }
   }
}

program _module_value=Mird;

#endif
