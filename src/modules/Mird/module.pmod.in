#pike __REAL_VERSION__

#if constant(@module@.Mird)

class Mird
{
//! class Mird
//!	The Mird module doubles as the Mird database class.

   constant Glue=@module@;

   constant TABLE2ID_TABLE=1;
   constant ID2TABLE_TABLE=2;

   Glue.Mird mird;

#define NEXT_TABLE "_mird_magic_next_free_table"

   mapping table2id=([]); 
   mapping id2table=([]); 
   int next_table;

   function(int,int|string:string) _fetch;
      
//! method void create(string filename,void|mapping options)
//!	Opens the database using the given filename. Note that
//!	the file filename+".journal" will be created too.
//!	
//!	Possible options:
//!
//!	<data_description type=mapping>
//!
//!	<elem type=string name=flags>database flags, see below</elem>
//!
//!     <elem type=int name=block_size>
//!           database block size; must be even 2^n
//!           database size is limited to 2^32 blocks, ie block_size*2^32 
//!           (8192*2^(32-5) is approximately 1Tb)
//!           (2048)
//!     </elem>
//!        
//!     <elem type=int name=frag_bits>
//!           this sets the number of frags in a fragmented block,
//!           and address bits to locate them.
//!           the number of frags in a fragmented block is equal
//!           to 2^frag_bits-1, per default 2^5-1=32-1=31
//!          
//!           This steals bits from the 32 bit address used to point out
//!           a chunk.
//!           (5)
//!     </elem>
//!     
//!     <elem type=int name=hashtrie_bits>
//!           this is the number of bits in each hash-trie hash; 
//!           4*2^n must be a lot less then block_size
//!           (5)
//!     </elem>
//!     
//!     <elem type=int name=cache_size>
//!           this is the number of blocks cached from the database;
//!           this is used for both read- and write cache.
//!           Note that the memory usage is constant, 
//!           approximately block_size*cache_size bytes.
//!           (32)
//!     </elem>
//!     
//!     <elem type=int name=cache_search_length>
//!           this is the closed hash maximum search length to find
//!           a block in the cache; note that this will result in 
//!           linear time usage.
//!           (8)
//!     </elem>
//!     
//!     <elem type=int name=max_free_frag_blocks>
//!           this is how many blocks with free space that is 
//!           kept in a list to be used when a transaction
//!           is running. The closest fit of usage of these blocks are
//!           where the data will be stored.
//!           (10)
//!     </elem>
//!     
//!     <elem type=int name=file_mode>
//!           this is the default mode the files are opened with;
//!           although affected by UMASK
//!           (0666)
//!     </elem>
//!     
//!     <elem type=int name=journal_readback_n>
//!           this is how many journal entries are read back
//!           at once at transaction finish, cancel or copy time
//!           bytes needed is approximately 24*this number
//!           (200)
//!     </elem>
//!	</data_description>
//! 
//! 	<pre>flags is a string with any of these characters:
//! 	"r" - readonly
//! 	"R" - readonly in a live system (one process writes, many reads)
//! 	"n" - don't create if it doesn't exist
//! 	"x" - exclusive (always create)
//! 	"s" - call fsync when finishing transactions
//! 	"S" - call sync(2) after fsync
//! 	"j" - complain if journal file is gone missing
//! 	</pre>

   void create(string filename,void|mapping options)
   {
      mird=Glue.Mird(filename,options||([]));

      mixed err=catch 
      { 
	 next_table=(int)mird->fetch(TABLE2ID_TABLE,NEXT_TABLE); 
      };
      if (err || !next_table)
      {
	 next_table=max(ID2TABLE_TABLE,TABLE2ID_TABLE)+1;
	 Glue.Transaction mtr=Glue.Transaction(mird);
	 mtr->new_stringkey_table(TABLE2ID_TABLE);
	 mtr->new_hashkey_table(ID2TABLE_TABLE);
	 mtr->store(TABLE2ID_TABLE,NEXT_TABLE,(string)next_table);
	 mtr->close();
      }

      _fetch=mird->fetch;

      call_out(sync_loop,60,60);
   }

   Glue.Scanner _scanner(int ... args)
   {
      return Glue.Scanner(mird,@args);
   }

   Mird _store(int table_id,int|string key,string data)
   {
      Transaction tr=transaction();
      tr->_store(table_id,key,data);
      tr->close();
      return this_object();
   }

//! method Table table(string name)
//!	Gives back the table object for the specified table
//!	in the database.

   Table table(string name)
   {
      if (name==NEXT_TABLE) error("illegal name\n");
      if (!table2id[name]) 
      {
	 string d=mird->fetch(TABLE2ID_TABLE,name);
	 if (!d) error("no such table (%O)\n",name);
	 table2id[name]=(int)d;
      }
      return Table(this_object(),table2id[name]);
   }


//! method vTable vtable(string name)
//! method vzTable vtable(string name)
//! 	A vTable is just like a <ref>Table</ref>, except that the
//!     values can be anything, not just strings. The
//!     data is encode_value()ed before storage.
//!
//! 	A vzTable is just like a <ref>vTable</ref>, except that the
//!     values is both encoded and packed, using Gz.

   vTable vtable(string name)
   {
      if (name==NEXT_TABLE) error("illegal name\n");
      if (!table2id[name]) 
      {
	 string d=mird->fetch(TABLE2ID_TABLE,name);
	 if (!d) error("no such table (%O)\n",name);
	 table2id[name]=(int)d;
      }
      return vTable(this_object(),table2id[name]);
   }

   vzTable vztable(string name)
   {
      if (name==NEXT_TABLE) error("illegal name\n");
      if (!table2id[name]) 
      {
	 string d=mird->fetch(TABLE2ID_TABLE,name);
	 if (!d) error("no such table (%O)\n",name);
	 table2id[name]=(int)d;
      }
      return vzTable(this_object(),table2id[name]);
   }

//! method table_name(int id)
//! returns the name of the table with id <i>id</i>

   string table_name(int id)
   {
      if (id2table[id]) return id2table[id];
      string d=mird->fetch(ID2TABLE_TABLE,id);
      if (!d) return 0;
      return id2table[id]=d;
   }

//!
//! method Table new_stringkey_table(string name)
//! method Table new_hashkey_table(string name)
//!	Create a new table in the database.
//! note: 
//!	a transaction will be created when
//!	calling these on the Database level.

   Table new_stringkey_table(string name)
   {
      Transaction tr=transaction();
      tr->new_stringkey_table(name);
      tr->close();
      return table(name);
   }

   Table new_hashkey_table(string name)
   {
      Transaction tr=transaction();
      tr->new_hashkey_table(name);
      tr->close();
      return table(name);
   }

   void delete_table(string name)
   {
      Transaction tr=transaction();
      tr->delete_table(name);
      tr->close();
   }

//!
//! method Transaction transaction()
//! 	creates a new transaction

   Transaction transaction()
   {
      return Transaction(this_object());
   }

   Transaction ctransaction()
   {
      return cTransaction(this_object());
   }

//!
//! method array(string) tables()
//!	Gives a list of all tables in the database.

   array(string) tables()
   {
      return indices(Table(this_object(),TABLE2ID_TABLE))-({NEXT_TABLE});
   }

//! method object sync()
//! method object sync_please()
//!	Syncs the database (syncs against disc and 
//!	starts to reuse any space that is freed),
//!	sync_please() does this when the last living
//!	transaction is finished.
//! method object sync_loop(int seconds)
//!	Starts a call_out loop that will call sync_please
//!	once every given interval. 0 or fewer seconds will
//!	shut down the loop.
//!	Default is 1 minute (60 seconds).

   Mird sync()
   {
      gc(); // kill any leftover transactions
      mird->sync();
      return this_object();
   }

   Mird sync_please()
   {
      gc(); // kill any leftover transactions
      mird->sync_please();
      return this_object();
   }

   Mird sync_loop(int seconds)
   {
      remove_call_out(sync_loop);
      if (seconds<=0) return this_object();
      if (_refs(this_object())>4) // otherwise, we're last -> close()
	 call_out(sync_loop,seconds,seconds);
      return sync_please();
   }

//! method void close()
//! method void destroy()
//!	syncs and closes the database

   void close()
   {
      remove_call_out(sync_loop);
      if (mird) mird->close();
   }

   function destroy=close;

//!
//! subclass Table
//!	A Mird table has approximately the same
//!	characteristics as a Pike mapping. You 
//!	store key:value pairs in it, you get values from keys,
//!	you delete keys.
//!
//!	For convinience, the Table object overloads `[],
//!	`[]=, _indices and _values.

   class Table 
   {
      int table_id;
      object(Mird)|object(Transaction) parent;

//! method void create(object parent,int table_id)
      void create(object _parent,int _table_id)
      {
	 parent=_parent;
	 table_id=_table_id;
      }

//! method Mird.Glue.Scanner scanner()
//! method Mird.Glue.Scanner scanner(int key)
//!	Creates a scanner over the called table;
//!	if a key is given, continue at that key
//!	(as returned from <ref to=Mird.Glue.Scanner.next_key>next_key</ref>).
//!
//!	A scanner can be used to loop over all elements in a table.

      Mird.Glue.Scanner scanner(int ... key)
      {
	 return parent->_scanner(table_id,@key);
      }

//! method string `[](int|string key)
//! method string `[]=(int|string key,string value)
//! method array(int|string) _indices()
//! method array(int|string) _values()
//!	Get and store key:value pairs, list the table.
//!
//! note:
//!	All storage in the table will create a transaction,
//!	if we're not already in a transaction. 

      string `[](int|string key)
      {
	 string s=parent->_fetch(table_id,key);
	 return s;
      }

      string `[]=(int|string key,string value)
      {
	 parent->_store(table_id,key,value);
	 return value;
      }

      array(int|string) _indices()
      {
	 array keys=({});
	 Glue.Scanner sc=scanner();
	 mapping m;
	 while ( (m=sc->read(100)) ) keys+=indices(m);
	 return keys;
      }

      array(int|string) _values()
      {
	 array vals=({});
	 Glue.Scanner sc=scanner();
	 mapping m;
	 while ( (m=sc->read(100)) ) vals+=values(m);
	 return vals;
      }

//! method array|mapping cast("mapping"|"array")
//!	It is possible to cast the Table to a mapping
//!	or array; this will read all contents of the table,
//!	so beware if you have a big table.

      array|mapping cast(string to)
      {
	 if (sscanf(to,"array%*s"))
	 {
	    array tupels=({});
	    Glue.Scanner sc=scanner();
	    mapping m;
	    while ( (m=sc->read(100)) ) tupels+=(array)m;
	    return tupels;
	 }
	 if (sscanf(to,"mapping%*s"))
	 {
	    mapping tupels=([]);
	    Glue.Scanner sc=scanner();
	    mapping m;
	    while ( (m=sc->read(100)) ) tupels+=m;
	    return tupels;
	 }
	 error("illegal argument 1 to cast\n");
      }
   }

//!
//! subclass vTable
//! inherits Table
//!     This is just like a normal table, but all data is encode_value()ed,
//!     and unpacked if reading, for convinience. 
//!

   class v0Table
   {
      inherit Table;

      string pack(mixed v);
      mixed unpack(string s);

      mixed `[](int|string key)
      {
	 string s=parent->_fetch(table_id,key);
	 if (s) return unpack(s);
	 return ([])[0];
      }

      string `[]=(int|string key,mixed value)
      {
	 parent->_store(table_id,key,pack(value));
	 return value;
      }


      array(mixed) _values()
      {
	 array vals=({});
	 Glue.Scanner sc=parent->_scanner(table_id);
	 mapping m;
	 while ( (m=sc->read(100)) ) vals+=values(m);
	 return map(vals,unpack);
      }

      array|mapping cast(string to)
      {
	 if (sscanf(to,"array%*s"))
	 {
	    array tupels=({});
	    Glue.Scanner sc=parent->_scanner(table_id);
	    mapping m;
	    while ( (m=sc->read(100)) ) tupels+=(array)m;
	    return map(tupels,lambda(array(string) v)
			      {
				 return ({v[0],unpack(v[1])});
			      });
	 }
	 if (sscanf(to,"mapping%*s"))
	 {
	    mapping tupels=([]);
	    Glue.Scanner sc=parent->_scanner(table_id);
	    mapping m;
	    while ( (m=sc->read(100)) ) 
	       tupels+=m;
	    return (mapping)map((array)tupels,
				lambda(array(string) v)
				{
				   return ({v[0],unpack(v[1])});
				});
	 }
	 error("illegal argument 1 to cast\n");
      }
   }

   class vTable
   {
      inherit v0Table;

      string pack(mixed v) 
      { 
	 return encode_value(v); 
      }

      mixed unpack(string s) 
      { 
	 return s?decode_value(s):([])[0];
      }
   }

//!
//! subclass vzTable
//! inherits Table
//!     This is just like a normal table, but all data is encode_value()ed,
//!     and gzipped, and unpacked if reading, for convinience. 
//!

   class vzTable
   {
      inherit v0Table;

      string pack(mixed v) 
      { 
	 return Gz.deflate()->deflate(encode_value(v)); 
      }

      mixed unpack(string s) 
      { 
	 if (!s) return ([])[0];
	 return decode_value(Gz.inflate()->inflate(s)); 
      }
   }

//!
//! subclass Transaction
//!	A Transaction is the environment which in a change
//!	to the database can be made. Simplified, the database
//!	is not changed until the transaction is closed. More 
//!	then one change to the database can be performed within
//!	one transaction.
//!
//!	If the same entries in the database were changed during
//!	the lifespan of the transaction, it cannot be closed but
//!	has to be cancelled.

   class Transaction
   {
      Mird parent;
      Glue.Transaction mtr;
      mapping table2id=([]);
      int refresh_at_close=0;

      function(int,int|string:string) _fetch;
      function(int:Glue.Scanner) _scanner;
      
      void create(object _parent)
      {
	 parent=_parent;
	 mtr=Glue.Transaction(parent->mird);
	 _fetch=mtr->fetch;
	 _scanner=lambda(int ... args) 
		  { 
		     return Glue.Scanner(mtr,@args); 
		  };
      }

      Transaction _store(int table_id,int|string key,string value)
      {
	 if (!value) 
	    mtr->delete(table_id,key);
	 else
	    mtr->store(table_id,key,value);
	 return this_object();
      }

//! method Table table(string name)
//! method vTable vtable(string name)
//! method vzTable vztable(string name)
//!	Creates a <ref to=Table>Table</ref>, <ref to=vTable>vTable</ref>
//!	or <ref to=vTable>vzTable</ref>
//!	object for that table,
//!	which emulates a mapping and in which
//!	you can make changes to the database or
//!	do lookups.

      Table table(string name)
      {
	 if (name==NEXT_TABLE) error("illegal name\n");
	 int id;
	 if (!(id=table2id[name]))
	 {
	    if (parent->table2id[name])
	       id=table2id[name]=parent->table2id[name];
	    else
	    {
	       string d=mtr->fetch(TABLE2ID_TABLE,name);
	       if (!d) error("no such table (%O)\n",name);
	       id=table2id[name]=(int)d;
	    }
	 }
	 return Table(this_object(),id);
      }

//! 	A vTable is just like a table, except that the
//!     values can be anything, not just strings. The
//!     data is encode_value()ed before storage.

      vTable vtable(string name)
      {
	 if (name==NEXT_TABLE) error("illegal name\n");
	 if (!table2id[name]) 
	 {
	    string d=mird->fetch(TABLE2ID_TABLE,name);
	    if (!d) error("no such table (%O)\n",name);
	    table2id[name]=(int)d;
	 }
	 return vTable(this_object(),table2id[name]);
      }

//!
//! method Table new_stringkey_table(string name)
//! method Table new_hashkey_table(string name)
//!	Creates a new table in the database.
//!	A stringkey table is a mapping from string to string,
//!	and a hashkey table is mapping from int to string.
//!

      Table new_stringkey_table(string name)
      {
	 string d=mtr->fetch(TABLE2ID_TABLE,name);
	 if (d) error("table already exist");
	 int no=parent->next_table++;
	 mtr->store(TABLE2ID_TABLE,name,(string)no);
	 mtr->store(ID2TABLE_TABLE,no,name);
	 mtr->store(TABLE2ID_TABLE,NEXT_TABLE,(string)parent->next_table);
	 mtr->new_stringkey_table(no);
	 refresh_at_close=1;
	 return table(name);
      }

      Table new_hashkey_table(string name)
      {
	 string d=mtr->fetch(TABLE2ID_TABLE,name);
	 if (d) error("table already exist");
	 int no=parent->next_table++;
	 mtr->store(TABLE2ID_TABLE,name,(string)no);
	 mtr->store(ID2TABLE_TABLE,no,name);
	 mtr->store(TABLE2ID_TABLE,NEXT_TABLE,(string)parent->next_table);
	 mtr->new_hashkey_table(no);
	 refresh_at_close=1;
	 return table(name);
      }

//! method void delete_table(string name)
//!	Removes a table and all items in it

      void delete_table(string name)
      {
	 if (name==NEXT_TABLE) error("no such table (%O)\n",name);
      
	 int no;
	 if (!(no=table2id[name]))
	 {
	    string d=mtr->fetch(TABLE2ID_TABLE,name);
	    if (!d) error("no such table (%O)",name);
	    no=(int)d;
	 }
	 catch { mtr->delete_table(no); };
	 m_delete(table2id,name);
	 m_delete(id2table,no);
	 mtr->delete(TABLE2ID_TABLE,name);
	 mtr->delete(ID2TABLE_TABLE,no);
	 refresh_at_close=1;
      }

//!
//! method array(string) tables()
//! returns the names of the tables in the database.
//!

      array(string) tables()
      {
	 return indices(Table(this_object(),TABLE2ID_TABLE));
      }

//!
//! method void close()
//!	Finishes a transaction. This throws exceptions
//!	if there were conflicts.
//!

      void close()
      {
	 mtr->close();
	 if (refresh_at_close) 
	    parent->table2id=parent->id2table=([]);
      }

//!
//! method void cancel()
//! method void destroy()
//!	Cancels (rewinds) a transaction.
//!

      void cancel()
      {
	 mtr->cancel();
      }

      void destroy()
      {
	 if (mtr) destruct(mtr);
      }
   }

// caching transaction

   class cTransaction
   {
      inherit Transaction;

      mapping edited=([]);

      void create(object _parent)
      {
	 ::create(_parent);

	 _fetch=cfetch;
	 _scanner=lambda(int ... args) 
		  { 
	       // this'll do for now
		     flush();
		     return Glue.Scanner(mtr,@args); 
		  };
      }

      Transaction _store(int table_id,int|string key,string value)
      {
	 if ((<TABLE2ID_TABLE,ID2TABLE_TABLE>)[table_id])
	    return ::_store(table_id,key,value);
	 if (!edited[table_id]) edited[table_id]=([]);
	 edited[table_id][key]=value;
	 return this_object();
      }

      string cfetch(int table_id,int|string key)
      {
	 mixed m;
         // this will not be a TABLE table since we don't store those:
	 if ((m=edited[table_id]) &&
	     (m=m[key])) return m;
	 return mtr->fetch(table_id,key);
      }

      void flush()
      {
	 foreach (indices(edited),int table)
	    foreach ((array)(edited[table]),[int|string key,string value])
	       if (value)
		  mtr->store(table,key,value);
	       else
		  mtr->delete(table,key);
	 edited=([]);
      }

      void close()
      {
	 flush();
	 ::close();
      }

      void cancel()
      {
	 edited=([]);
	 ::cancel();
      }
   }
}

program _module_value=Mird;

#endif
