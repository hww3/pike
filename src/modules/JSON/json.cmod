/* -*- c -*-
|| This file is part of Pike. For copyright information see COPYRIGHT.
|| Pike is distributed under GPL, LGPL and MPL. See the file COPYING
|| for more information.
|| $Id: json.cmod,v 1.11 2010/06/10 14:08:36 arne Exp $
*/

/* JSON encoder.
 *
 * Ref: RFC 4627
 *
 * Created May 2010 by Martin Stjernholm
 */

#include "array.h"
#include "cyclic.h"
#include "global.h"
#include "interpret.h"
#include "mapping.h"
#include "module.h"
#include "pike_error.h"
#include "pike_float.h"
#include "pike_types.h"
#include "stralloc.h"
#include "svalue.h"

#define DEFAULT_CMOD_STORAGE static

DECLARATIONS

/*! @module Standards */

/*! @module JSON */

#define ASCII_ONLY 1
#define HUMAN_READABLE 2
#define PIKE_CANONICAL 4

struct json_proc {
  struct string_builder buf;
  int flags;
  int indent;
};

static void json_encode_recur (struct json_proc *ctx, struct svalue *val);

static void encode_mapcont (struct json_proc *ctx, struct mapping *m)
/* Assumes there's at least one element. */
{
  struct string_builder *buf = &ctx->buf;
  int e, notfirst = 0;
  struct keypair *k;
  struct mapping_data *md = m->data;

  NEW_MAPPING_LOOP (md) {
    if (notfirst) {
      string_builder_putchar (buf, ',');
      if (ctx->indent >= 0) {
	int indent = ctx->indent;
	string_builder_putchar (buf, '\n');
	string_builder_putchars (buf, ' ', indent);
      }
    }
    else {
      if (ctx->indent >= 0) {
	int indent = ctx->indent = ctx->indent + 2;
	string_builder_putchar (buf, '\n');
	string_builder_putchars (buf, ' ', indent);
      }
      notfirst = 1;
    }

    if (k->ind.type != T_STRING)
      Pike_error ("Cannot json encode mapping with non-string index %O.\n",
		  &k->ind);
    json_encode_recur (ctx, &k->ind);

    string_builder_putchar (buf, ':');
    if (ctx->indent >= 0) string_builder_putchar (buf, ' ');
    json_encode_recur (ctx, &k->val);
  }
}

static void encode_mapcont_canon (struct json_proc *ctx, struct mapping *m)
/* Assumes there's at least one element. */
{
  struct string_builder *buf = &ctx->buf;
  int i, notfirst = 0;
  struct array *inds = mapping_indices (m);
  int size = inds->size;
  ONERROR uwp;
  SET_ONERROR (uwp, do_free_array, inds);

  /* encode_value_canonic uses get_switch_order, but this sort is good
   * enough considering we only have to deal (correctly) with strings. */
  sort_array_destructively (inds);

  for (i = 0; i < size; i++) {
    struct svalue *ind = ITEM (inds) + i;

    {
      /* Push the value on the stack so we know it's still there when
       * we get to formatting it. Probably not really necessary, but
       * better safe than sorry. */
      struct svalue *val = low_mapping_lookup (m, ind);
      if (val)
	push_svalue (val);
      else
	/* The entry has disappeared since the array was created.
	 * Ignore it and continue is the right thing to do. */
	continue;
    }

    if (notfirst) {
      int indent = ctx->indent;
      string_builder_putchar (buf, ',');
      if (indent >= 0) {
	string_builder_putchar (buf, '\n');
	string_builder_putchars (buf, ' ', indent);
      }
    }
    else {
      int indent = ctx->indent;
      if (indent >= 0) {
	ctx->indent = indent = indent + 2;
	string_builder_putchar (buf, '\n');
	string_builder_putchars (buf, ' ', indent);
      }
      notfirst = 1;
    }

    if (ind->type != T_STRING)
      Pike_error ("Cannot json encode mapping with non-string index %O.\n",
		  ind);
    json_encode_recur (ctx, ind);

    string_builder_putchar (buf, ':');
    if (ctx->indent >= 0) string_builder_putchar (buf, ' ');

    json_encode_recur (ctx, Pike_sp - 1);
    pop_stack();
  }

  UNSET_ONERROR (uwp);
  free_array (inds);
}

static void json_encode_recur (struct json_proc *ctx, struct svalue *val)
{
  DECLARE_CYCLIC();

  check_c_stack (1024);

  if (val->type <= MAX_COMPLEX && BEGIN_CYCLIC (val->u.ptr, 0))
    Pike_error ("Cyclic data structure - already visited %O.\n", val);

  switch (val->type) {
    case PIKE_T_STRING: {
      struct string_builder *buf = &ctx->buf;
      PCHARP str = MKPCHARP_STR (val->u.string);
      ptrdiff_t l = val->u.string->len, i, s;
      string_builder_putchar (buf, '"');
      for (s = 0, i = 0; i < l; i++) {
	p_wchar2 c = INDEX_PCHARP (str, i);
	if (c < 0 || c > 0x10ffff)
	  Pike_error ("Cannot json encode non-unicode char "
		      "0x%"PRINTPIKEINT"x.\n", (INT_TYPE) c);
	if (c == '"' || c == '\\' || c <= 0x1f ||
	    (c >= 0x7f && ctx->flags & ASCII_ONLY && c <= 0xffff)) {
	  if (s < i) {
	    PCHARP piece = ADD_PCHARP (str, s);
	    string_builder_append (buf, piece, i - s);
	  }
	  string_builder_putchar (buf, '\\');
	  switch (c) {
	    case '"': string_builder_putchar (buf, '"'); break;
	    case '\\': string_builder_putchar (buf, '\\'); break;
	    case '\b': string_builder_putchar (buf, 'b'); break;
	    case '\f': string_builder_putchar (buf, 'f'); break;
	    case '\n': string_builder_putchar (buf, 'n'); break;
	    case '\r': string_builder_putchar (buf, 'r'); break;
	    case '\t': string_builder_putchar (buf, 't'); break;
	    default:
	      string_builder_putchar (buf, 'u');
	      string_builder_append_integer (buf, c, 16, APPEND_ZERO_PAD, 4, 4);
	      break;
	  }
	  s = i + 1;
	}
      }
      if (s < i) {
	PCHARP piece = ADD_PCHARP (str, s);
	string_builder_append (buf, piece, i - s);
      }
      string_builder_putchar (buf, '"');
      break;
    }

    case PIKE_T_INT:
      string_builder_append_integer (&ctx->buf, val->u.integer,
				     10, APPEND_SIGNED, 0, 0);
      break;

    case PIKE_T_FLOAT: {
      FLOAT_TYPE f = val->u.float_number;
      char b[MAX_FLOAT_SPRINTF_LEN];
      if (PIKE_ISNAN (f))
	Pike_error ("Cannot json encode NaN.\n");
      if (PIKE_ISINF (f))
	Pike_error ("Cannot json encode infinity.\n");
      format_pike_float (b, f);
      string_builder_strcat (&ctx->buf, b);
      break;
    }

    case PIKE_T_ARRAY: {
      struct string_builder *buf = &ctx->buf;
      string_builder_putchar (buf, '[');
      {
	struct array *a = val->u.array;
	int size = a->size;
	if (size) {
	  int i;
	  if (ctx->indent >= 0 && size > 1) {
	    int indent = ctx->indent = ctx->indent + 2;
	    string_builder_putchar (buf, '\n');
	    string_builder_putchars (buf, ' ', indent);
	  }
	  json_encode_recur (ctx, ITEM (a));
	  for (i = 1; i < size; i++) {
	    string_builder_putchar (buf, ',');
	    if (ctx->indent >= 0) {
	      int indent = ctx->indent;
	      string_builder_putchar (buf, '\n');
	      string_builder_putchars (buf, ' ', indent);
	    }
	    json_encode_recur (ctx, ITEM (a) + i);
	  }
	  if (ctx->indent >= 0 && size > 1) {
	    int indent = ctx->indent = ctx->indent - 2;
	    string_builder_putchar (buf, '\n');
	    string_builder_putchars (buf, ' ', indent);
	  }
	}
      }
      string_builder_putchar (buf, ']');
      break;
    }

    case PIKE_T_MAPPING: {
      string_builder_putchar (&ctx->buf, '{');
      check_mapping_for_destruct (val->u.mapping);
      if (m_sizeof (val->u.mapping)) {
	if (ctx->flags & PIKE_CANONICAL)
	  encode_mapcont_canon (ctx, val->u.mapping);
	else
	  encode_mapcont (ctx, val->u.mapping);
	if (ctx->indent >= 0) {
	  int indent = ctx->indent = ctx->indent - 2;
	  string_builder_putchar (&ctx->buf, '\n');
	  string_builder_putchars (&ctx->buf, ' ', indent);
	}
      }
      string_builder_putchar (&ctx->buf, '}');
      break;
    }

    case PIKE_T_OBJECT: {
      struct object *o = val->u.object;
      if (o->prog) {
	int fun = find_identifier ("encode_json", o->prog);
	if (fun >= 0) {
	  int args = 1;
	  push_int (ctx->flags);
	  if (ctx->indent >= 0) {
	    push_int (ctx->indent);
	    args++;
	  }
	  apply_low (o, fun, args);
	  if (Pike_sp[-1].type != PIKE_T_STRING)
	    Pike_error ("Expected string from %O->encode_json(), got %s.\n",
			val, get_name_of_type (Pike_sp[-1].type));
	  string_builder_shared_strcat (&ctx->buf, Pike_sp[-1].u.string);
	  free_string ((--Pike_sp)->u.string);
	  break;
	}
      }
      Pike_error ("Cannot json encode object %O "
		  "without encode_json function.\n", val);
    }

    default:
      Pike_error ("Cannot json encode %s.\n", get_name_of_type (val->type));
  }

  if (val->type <= MAX_COMPLEX)
    END_CYCLIC();
}

/*! @decl constant ASCII_ONLY
 *! @decl constant HUMAN_READABLE
 *! @decl constant PIKE_CANONICAL
 *!
 *! Bit field flags for use with @[encode]:
 *!
 *! @dl
 *! @item Standards.JSON.ASCII_ONLY
 *!   Use @expr{\uxxxx@} escapes for all non-ascii characters and DEL
 *!   (U+007f). The default is to escape only the characters that must
 *!   be escaped. The flag value is 1.
 *!
 *!   Note however that the limited length of the escapes makes it
 *!   possible to escape chars up to U+ffff inclusive only. Chars
 *!   above that are still unescaped in the output (which can be
 *!   detected with @[String.width]).
 *!
 *! @item Standards.JSON.HUMAN_READABLE
 *!   Pretty print with indentation to make the result more easy on
 *!   human eyes. The default is to use no extra whitespace at all.
 *!   The flag value is 2.
 *!
 *! @item Standards.JSON.PIKE_CANONICAL
 *!   Make the output canonical, so that the same value always
 *!   generates the same char-by-char equal string. In practice this
 *!   means that mapping elements are sorted on their indices. Note
 *!   that the other flags take precedence, so e.g. the canonical form
 *!   with @[HUMAN_READABLE] is not the same as the canonical form
 *!   without it. The flag value is 4.
 *!
 *!   This canonical form is stable for the @[encode] function,
 *!   providing floats aren't used (their formatting is currently
 *!   affected by float size and libc formatting code). In the future
 *!   there may be a standardized canonical form which quite likely
 *!   will be different from this one. In that case a separate flag
 *!   has to be added so this one doesn't change - hence the name
 *!   @[PIKE_CANONICAL].
 *! @enddl
 */

/*! @decl string encode (int|float|string|array|mapping|object val, @
 *!                      void|int flags)
 *!
 *! Encodes a value to a JSON string.
 *!
 *! @param val
 *!   The value to encode. It can contain integers, floats (except the
 *!   special numbers NaN and infinity), strings, arrays, mappings
 *!   with string indices, and the special object values @[null],
 *!   @[true] and @[false] defined in this module (or really any
 *!   object that implements an @expr{encode_json@} callback).
 *!
 *! @param flags
 *!   Flag bit field to control formatting. See @[ASCII_ONLY],
 *!   @[HUMAN_READABLE] and @[PIKE_CANONICAL] for further details.
 *!
 *! @note
 *! 8-bit and wider characters in input strings are neither escaped
 *! nor utf-8 encoded by default. @[string_to_utf8] can be used safely
 *! on the returned string to get a valid transport encoded JSON
 *! string.
 */
PIKEFUN string encode (int|float|string|array|mapping|object val,
		       void|int flags)
  optflags OPT_TRY_OPTIMIZE;
{
  struct json_proc ctx;
  ONERROR uwp;
  ctx.flags = (flags ? flags->u.integer : 0);
  ctx.indent = (ctx.flags & HUMAN_READABLE ? 0 : -1);
  init_string_builder (&ctx.buf, 0);
  SET_ONERROR (uwp, free_string_builder, &ctx.buf);
  json_encode_recur (&ctx, val);
  UNSET_ONERROR (uwp);
  RETURN finish_string_builder (&ctx.buf);
}

#include "json_parser.c"

/*! @decl int validate(string s)
 *!
 *! Takes a string and checks if it is valid JSON.
 *! 
 *! @returns
 *! 	In case the string contains valid JSON @expr{-1@} is returned. It is then guarenteed to be parsed
 *! 	without errors by @[decode()].
 *! 	In case the string is not valid JSON, the integer position inside the string
 *! 	where the error occures is returned.
 */
PIKEFUN int validate(string data) {
    p_wchar2 *start;
    struct parser_state state;
    p_wchar2 *p;

    state.validate = 1;
    JSON_CONVERT(data, start);

    state.level = 0;
    state.data = data;

    pop_stack();

    p = _parse_JSON(start, start + data->len, &state);

    if (data->size_shift < 2)
		free(start);

	if (p != NULL) {
		if (p == start + data->len) {
			push_int(-1);
			return;
		}

		push_int((INT_TYPE)(p - start) / 4);
		return;
    }

    push_int((INT_TYPE)start);
    f_minus(2);
    push_int(4);
    o_divide();

    return;
}

/*! @decl array|mapping|string|float|int decode(string s)
 *!
 *! Parses a JSON-formatted string and returns the corresponding pike data type.
 *! 
 *! @throws
 *! 	Throws an exception in case the data contained in @expr{s@} is not valid
 *! 	JSON.
 */
PIKEFUN mixed decode(string data) {
    p_wchar2 *start, *stop;
    struct parser_state state;
    int error_offset;

    state.validate = 0;
    JSON_CONVERT(data, start);

    state.level = 0;
    state.data = data;

    stop = _parse_JSON(start, start + data->len, &state);

    if (data->size_shift < 2)
		free(start);

    if (stop != NULL) {
			
		if (stop == start + data->len) {
			stack_pop_keep_top(); // pop string data
			return;
		}

		pop_stack(); // pop unlegitimate result
		push_int((INT_TYPE)stop);
    }

    error_offset = (((struct svalue*)(Pike_sp - 1))->u.integer - (INT_TYPE)start) / 4;
    pop_stack();
    push_int(error_offset);
    push_int(error_offset+10);
    f_index(3);

    if (((struct svalue*)(Pike_sp - 1))->type != PIKE_T_STRING) {
		Pike_error("Parsing JSON failed and I dont know where.\n");
    } else {
		push_text("Parsing JSON failed in position %d (%O).\n");
		stack_swap();
		push_int(error_offset);
		stack_swap();
		f_sprintf(3);
		f_aggregate(1);
		f_throw(1);
    }

    return;
}

/*! @decl int validate_utf8(string s)
 *!
 *! Takes a utf8 encoded string and checks if it is valid JSON.
 *! 
 *! @returns
 *! 	In case the string contains valid JSON @expr{-1@} is returned. It is then guarenteed to be parsed
 *! 	without errors by @[decode()].
 *! 	In case the string is not valid JSON, the integer position inside the string
 *! 	where the error occures is returned.
 */
PIKEFUN int validate_utf8(string data) {
    char *start, *stop;
    struct parser_state state;

    switch (data->size_shift) {
    case 0:
        break;
    case 1:
    case 2:
		Pike_error("Strings wider than 1 byte are NOT valid UTF-8.\n");
        break;
    }

    start = (char *)STR0(data);

    state.validate = 1;
    state.level = 0;
    state.data = data;

    pop_stack();
    if ((stop = _parse_JSON_utf8(start, (start + data->len), &state)) == NULL) {

		push_int((INT_TYPE)start);
		f_minus(2);

	} else {
		if (stop == start + data->len) {
			push_int(-1);
		} else {
			push_int((INT_TYPE)(stop - start));
		}
    }

    return;
}

/*! @decl array|mapping|string|float|int decode(string s)
 *!
 *! Parses a utf8 encoded JSON-formatted string and returns the corresponding pike data type.
 *! Should give the same results as @expr{Standards.JSON.decode(utf8_to_string(s))@}.
 *! 
 *! @throws
 *! 	Throws an exception in case the data contained in @expr{s@} is not valid
 *! 	JSON.
 */
PIKEFUN mixed decode_utf8(string data) {
    char *start, *stop;
    struct parser_state state;
    INT_TYPE error_offset;

    switch (data->size_shift) {
    case 0:
        break;
    case 1:
    case 2:
	Pike_error("Strings wider than 1 byte are NOT valid UTF-8.\n");
        break;
    }

    start = (char *)STR0(data);

    state.validate = 0;
    state.level = 0;
    state.data = data;

    stop = _parse_JSON_utf8(start, (start + data->len), &state);

    if (stop != NULL) {
		if (stop == start + data->len) {
			stack_pop_keep_top(); // pop string data
			return;
		}

		pop_stack(); // pop the unlegitimate result
		push_int((INT_TYPE)stop);
    }

    error_offset = (((struct svalue*)(Pike_sp - 1))->u.integer - (INT_TYPE)start);
    pop_stack();
    push_int(error_offset);
    push_int(error_offset+10);
    f_index(3);
    if (((struct svalue*)(Pike_sp - 1))->type != PIKE_T_STRING) {
		Pike_error("Parsing JSON failed and I dont know where.\n");
    } else {
		push_text("Parsing JSON failed in position %d (%O).\n");
		stack_swap();
		push_int(error_offset);
		stack_swap();
		f_sprintf(3);
		f_aggregate(1);
		f_throw(1);
    }

    return;
}

/*! @endmodule */

/*! @endmodule */

PIKE_MODULE_INIT
{
  add_integer_constant ("ASCII_ONLY", ASCII_ONLY, 0);
  add_integer_constant ("HUMAN_READABLE", HUMAN_READABLE, 0);
  add_integer_constant ("PIKE_CANONICAL", PIKE_CANONICAL, 0);

  INIT;
}

PIKE_MODULE_EXIT
{
  EXIT;
}
