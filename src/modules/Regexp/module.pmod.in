// -*- Pike -*-

#pike __REAL_VERSION__

#if constant(_Regexp_PCRE)
constant PCRE=_Regexp_PCRE; // Regexp.PCRE
#endif

inherit @module@;

class SimpleRegexp
{
  inherit _SimpleRegexp;

  static private object repreg;
  static private string regexp_string;

  // Semi-optimal speed, yes, I agree, but it should work.
  string replace(string in, string|function(string:string) transform)
  {
    if(!repreg)
      repreg = this_program("("+regexp_string+")");

    for(string result = ""; ; )
    {
      if(!sizeof(in))
	return result;

      array a = repreg->split(in);
       
      if(!a)
	return result + in;

      int i = search(in, a[0]);

      if(i == -1)
	error("Split resulted in unknown substring %O of %O.", a[0], in);
       
      result += in[..i-1]+(functionp(transform)?transform(a[0]):transform);
      in = in[i+sizeof(a[0])..];
    }
  }
  
  static void create(string|void _regexp_string)
  {
    regexp_string = _regexp_string;
  
    if(regexp_string)
      ::create(regexp_string);
    else
      ::create();
  }

  static string _sprintf(int t)
  {
    switch(t)
    {
      case 'O':
	return sprintf("%O(%s)", this_program, regexp_string||"");

      case 's':
	return regexp_string;
    }
    return 0;
  }

  mixed _encode() { return regexp_string; }
  mixed _decode(string s) { create(s); }
}

SimpleRegexp `()(void|string regexp) { return SimpleRegexp(regexp); }

int(0..1) match(string regexp, string data) {
  return SimpleRegexp(regexp)->match(data);
}

array split(string regexp, string data) {
  return SimpleRegexp(regexp)->split(data);
}

string replace(string regexp, string data,
	       string|function(string:string) transform) {
  return SimpleRegexp(regexp)->replace(data, transform);
}

