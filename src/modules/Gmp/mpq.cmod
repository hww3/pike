/* -*- c -*-
|| This file is part of Pike. For copyright information see COPYRIGHT.
|| Pike is distributed under GPL, LGPL and MPL. See the file COPYING
|| for more information.
|| $Id: mpq.cmod,v 1.14 2002/10/21 17:06:12 marcus Exp $
*/

#include "global.h"
RCSID("$Id: mpq.cmod,v 1.14 2002/10/21 17:06:12 marcus Exp $");
#include "gmp_machine.h"

#if defined(HAVE_GMP2_GMP_H) && defined(HAVE_LIBGMP2)
#define USE_GMP2
#else /* !HAVE_GMP2_GMP_H || !HAVE_LIBGMP2 */
#if defined(HAVE_GMP_H) && defined(HAVE_LIBGMP)
#define USE_GMP
#endif /* HAVE_GMP_H && HAVE_LIBGMP */
#endif /* HAVE_GMP2_GMP_H && HAVE_LIBGMP2 */

#if defined(USE_GMP) || defined(USE_GMP2)

#include "interpret.h"
#include "svalue.h"
#include "stralloc.h"
#include "array.h"
#include "pike_macros.h"
#include "program.h"
#include "stralloc.h"
#include "object.h"
#include "pike_types.h"
#include "pike_error.h"
#include "builtin_functions.h"
#include "opcodes.h"
#include "module_support.h"
#include "bignum.h"
#include "operators.h"
#include "mapping.h"

#include "my_gmp.h"

#include <limits.h>
#include <math.h>


#define sp Pike_sp
#define fp Pike_fp

#define THISMPQ (&(THIS->n))

#define PUSH_REDUCED(o) push_object(o)

/*  id PROG_GMP_MPQ_ID; */
PIKECLASS mpq
{
  CVAR MP_RAT n;

  static void get_mpq_from_digits(MP_RAT *tmp,
				  struct pike_string *digits,
				  int base)
    {
      p_wchar0 *str;
  
      if(digits->size_shift)
	Pike_error("Illegal characters, cannot convert to Mpq.\n");
      str=STR0(digits);
      
      get_mpz_from_digits(mpq_numref(tmp), digits, base);
      
      if(!base || ((base >= 2) && (base <= 36)))
      {
	int offset = 0;
	int neg = 0;
	int dotfound = 0;
	
	if(digits->len > 1)
	{
	  if(str[0] == '+')
	    offset ++;
	  else if(str[0] == '-')
	  {
	    offset ++;
	    neg = 1;
	  }
	  
	  /* We need to fix the case with binary
	     0b101... and -0b101... numbers. */
	  if(!base && digits->len > 2)
	  {
	    if(str[offset] == '0')
	    {
	      switch(str[offset+1])
	      {
		case 'b':
		case 'B':
		  offset+=2;
		  base=2;
		  break;
		  
		case '0':
		  offset+=2;
		  base=8;
		  break;
		  
		case 'x':
		  offset+=2;
		  base=16;
		  break;
	      }
	    }
	  }
	}

	if(!base) base=10;
	
	mpq_set_ui(tmp, 0, 1);
	while(str[offset])
	{
	  int x=255;
	  if(str[offset] == '.')
	  {
	    offset++;
	    if(dotfound)
	      Pike_error("Invalid digits, cannot convert to mpq.\n");
	    dotfound++;
	    continue;
	  }
	  
	  if(str[offset] >= '0' && str[offset] <= '9')
	    x=str[offset]-'0';
	  else if(str[offset] >='a' && str[offset] <= 'z')
	    x=str[offset]-'a';
	  else if(str[offset] >='A' && str[offset] <= 'Z')
	    x=str[offset]-'A';
	  
	  if(x > base)
	    Pike_error("Invalid digits, cannot convert to mpq.\n");
	  
	  mpz_mul_ui(mpq_numref(tmp),
		     mpq_numref(tmp),
		     base);
	  if(dotfound)
	  {
	    mpz_mul_ui(mpq_denref(tmp),
		       mpq_denref(tmp),
		       base);
	  }
	  mpz_add_ui(mpq_numref(tmp),
		     mpq_numref(tmp),
		     x);
	  offset++;
	}

	if(dotfound)
	  mpq_canonicalize(tmp);

	if(neg)
	  mpz_neg(mpq_numref(tmp), mpq_numref(tmp));
      }
      else if(base == 256)
      {
	mpq_set_ui(tmp, 1, 1);
	get_mpz_from_digits(mpq_numref(tmp), digits, base);
      }
      else
      {
	Pike_error("invalid base.\n");
      }
    }

  static void get_new_mpq(MP_RAT *tmp, struct svalue *s)
    {
      switch(s->type)
      {
	case T_FLOAT:
	{
	  double t;
	  int y;
	  t=FREXP((double) s->u.float_number, &y);

	  t*=pow(2.0,48.0);
	  y-=48;

	  mpz_set_d(mpq_numref(tmp), t);
	  mpz_set_ui(mpq_denref(tmp), 1);
	  if(y>0)
	    mpz_mul_2exp(mpq_numref(tmp),mpq_numref(tmp),y);
	  else if(y<0)
	    mpz_mul_2exp(mpq_denref(tmp),mpq_denref(tmp),-y);

	  mpq_canonicalize(tmp);
	  break;
	}
	  
	case T_INT:
	  get_new_mpz(mpq_numref(tmp), s);
	  mpz_set_si(mpq_denref(tmp),1);
	  break;
	  
	case T_OBJECT:
	  if(s->u.object->prog == mpzmod_program)
	  {
	    mpq_set_z(tmp, OBTOMPZ(s->u.object));
	    break;
	  }
	  
	  if(s->u.object->prog == mpq_program)
	  {
	    mpq_set(tmp, OBTOMPQ(s->u.object));
	    break;
	  }
	  
	  if (s->u.object->prog) {
	    Pike_error("Wrong type of object (id:%d), cannot convert to mpq.\n",
		       s->u.object->prog->id);
	  } else {
	    /* Destructed object. Use as zero. */
	    mpq_set_si(tmp, 0, 1);
	  }
	  break;
	  
	default:
	  Pike_error("cannot convert argument to mpq.\n");
      }
    }
  
  PIKEFUN void create(void|string|int|float|object x, void|int base)
    type function(void|string|int|float|object:void)|function(string,int:void)|function(int,int:void);
    flags ID_STATIC;
  {
    switch(args)
    {
      case 1:
	if(sp[-args].type == T_STRING)
	  get_mpq_from_digits(THISMPQ, sp[-args].u.string, 0);
	else
	  get_new_mpq(THISMPQ, sp-args);
	break;
	
      case 2:
	/* Args are string of digits and integer base */
	/* or int num / den */
	
	if (sp[1-args].type != T_INT)
	  Pike_error("Bad arg 2 for Gmp.mpq(), expected integer.\n");

	switch(sp[-args].type)
	{
	  default:
	    Pike_error("bad argument 1 for Gmp.Mpq()\n");

	  case T_STRING:
	    get_mpq_from_digits(THISMPQ, sp[-args].u.string, sp[1-args].u.integer);
	    break;

	  case T_INT:
	    mpq_set_num(THISMPQ,get_mpz(sp-args,1));
	    mpq_set_den(THISMPQ,get_mpz(sp-args+1,1));
	    mpq_canonicalize(THISMPQ);
	    break;
	}
	break;
	
      default:
	Pike_error("Too many arguments to Mpq->create()\n");
	
      case 0:
	break;	/* Needed by AIX cc */
    }
  }
  
  PIKEFUN int get_int()
    {
      struct object *res = fast_clone_object(mpzmod_program, 0);
      mpz_tdiv_q(OBTOMPZ(res), mpq_numref(THISMPQ), mpq_denref(THISMPQ));
      /* FIXME */
#ifdef AUTO_BIGNUM
      mpzmod_reduce(res);
#else
      free_object(res);
      push_int(mpq_get_si(OBTOMPZ(res)));
#endif /* AUTO_BIGNUM */
    }

  PIKEFUN int __hash()
    flags ID_STATIC;
    {
      RETURN 
	mpz_get_si(mpq_numref(THISMPQ)) * 1000003 +
	mpz_get_si(mpq_denref(THISMPQ));
    }

  PIKEFUN float get_float()
    {
      RETURN (FLOAT_TYPE) mpq_get_d(THISMPQ);
    }


  PIKEFUN string get_string()
    {
      push_string(low_get_mpz_digits(mpq_numref(THISMPQ),10));
      push_constant_text("/");
      push_string(low_get_mpz_digits(mpq_denref(THISMPQ),10));
      f_add(3);
    }

  static int lookup(char *name,
		    struct mapping *m,
		    char *ind,
		    int def)
    {
      struct svalue *sv;
      if((sv=simple_mapping_string_lookup(m,ind)))
      {
	if(sv->type == T_INT)
	{
	  return sv->u.integer;
	}else{
	  Pike_error("\"%s\" argument to %s is not an integer.\n",ind,name);

	}
      }
      return def;
    }
		    

  PIKEFUN string _sprintf(int c, mapping flags)
    flags ID_STATIC;
    {
      INT_TYPE precision, width, base = 0, mask_shift = 0;
      struct pike_string *s = 0;
      INT_TYPE flag_left;

      precision=lookup("Gmp.Mpq->_sprintf",flags,"precision",7);
      width=lookup("Gmp.Mpq->_sprintf",flags,"width",-1);
      flag_left=lookup("Gmp.Mpq->_sprintf",flags,"flag_left",0);
      pop_n_elems(args);
      
      switch(c)
      {
	default:
	  Pike_error("Gmp.Mpq->_sprintf, bad format character.\n");

	case 'O':
	  f_mpq_get_string(0);
	  return;

	  /* Fixme: Support g/e/E */
	case 'g':
	case 'e':
	case 'E':
	case 'f':
	{
	  mpz_t tmp;
	  ptrdiff_t len;
	  base=10;

	  mpz_init(tmp);
	  mpz_ui_pow_ui(tmp, 10, precision);
	  mpz_mul(tmp, tmp, mpq_numref(THISMPQ));
	  mpz_tdiv_q(tmp, tmp, mpq_denref(THISMPQ));
	  /* present 'tmp' and insert dot */
	  len = mpz_sizeinbase(tmp, base) + 3;
	  s = begin_shared_string(len);
	  if(len/2 > precision)
	  {
	    mpz_get_str(s->str+1, base, tmp);
	    /* Find NULL character */
	    len-=4;
	    if (len < 0) len = 0;
	    while(s->str[len]) len++;
	    MEMMOVE(s->str, s->str+1, len-precision);
	  }else{
	    mpz_get_str(s->str, base, tmp);
	    /* Find NULL character */
	    len-=5;
	    if (len < 0) len = 0;
	    while(s->str[len]) len++;
	    MEMMOVE(s->str+len-precision+1,
		    s->str+len-precision,
		    precision+1);
	    len++;
	  }
	  mpz_clear(tmp);
	  s->str[len-precision]='.';
	  push_string(end_and_resize_shared_string(s, len));
	}
      }
    }
  

  PIKEFUN void _is_type(string arg)
    flags ID_STATIC;
    {
      push_constant_text("float");
      f_eq(2);
    }
  
  PIKEFUN void cast(string s)
    flags ID_STATIC;
    {
      add_ref(s);
      
      pop_n_elems(args);
      
      switch(s->str[0])
      {
	case 'i':
	  if(!strncmp(s->str, "int", 3))
	  {
	    free_string(s);
	    f_mpq_get_int(0);
	    return;
	  }
	  break;
	  
	case 's':
	  if(!strcmp(s->str, "string"))
	  {
	    free_string(s);
	    f_mpq_get_string(0);
	    return;
	  }
	  break;

	case 'f':
	  if(!strcmp(s->str, "float"))
	  {
	    free_string(s);
	    f_mpq_get_float(0);
	    return;
	  }
	  break;
	  
	case 'o':
	  if(!strcmp(s->str, "object"))
	  {
	    push_object(this_object());
	  }
	  break;
	  
	case 'm':
	  if(!strcmp(s->str, "mixed"))
	  {
	    push_object(this_object());
	  }
	  break;
	  
      }
      
      free_string(s);
      
      Pike_error("mpq->cast() to \"%s\" is other type than string, int or float.\n",
		 s->str);
    }

#ifdef DEBUG_MALLOC
#define get_mpq(X,Y) \
 (debug_get_mpq((X),(Y)),( (X)->type==T_OBJECT? debug_malloc_touch((X)->u.object) :0 ),debug_get_mpq((X),(Y)))
#else
#define get_mpq debug_get_mpq 
#endif

/* Converts an svalue, located on the stack, to an mpq object */
  static MP_RAT *debug_get_mpq(struct svalue *s, int throw_error)
    {
#define MPQ_ERROR(x) if (throw_error) Pike_error(x)
      struct object *o;
      switch(s->type)
      {
	default:
	  MPQ_ERROR("Wrong type of value, cannot convert to mpq.\n");
	  return 0;
	  
	case T_OBJECT:
	  if(s->u.object->prog == mpq_program)
	    return (MP_RAT *)s->u.object->storage;
	  
	  if(!throw_error && 
	     s->u.object->prog != mpzmod_program &&
	     s->u.object->prog)
	    return 0;
	  
	  /* Fall through */
	case T_INT:
	case T_FLOAT:
	  o=fast_clone_object(mpq_program,0);
	  get_new_mpq(OBTOMPQ(o), s);
	  free_svalue(s);
	  s->u.object=o;
	  s->type=T_OBJECT;
	  return (MP_RAT *)o->storage;
      }
    }


  PIKEFUN object `+(int|float|object ... a)
    flags ID_STATIC;
    {
      INT32 e;
      struct object *res;
      for(e=0; e<args; e++)
	get_mpq(sp+e-args, 1);
      res = fast_clone_object(mpq_program, 0);
      mpq_set(OBTOMPQ(res), THISMPQ);
      for(e=0;e<args;e++)
	mpq_add(OBTOMPQ(res), OBTOMPQ(res), OBTOMPQ(sp[e-args].u.object));
      
      RETURN res;
    }
  
  PIKEFUN object ``+(int|float|object ... a)
    flags ID_STATIC;
    {
      INT32 e;
      struct object *res;
      for(e=0; e<args; e++)
	get_mpq(sp+e-args, 1);
      res = fast_clone_object(mpq_program, 0);
      mpq_set(OBTOMPQ(res), THISMPQ);
      for(e=0;e<args;e++)
	mpq_add(OBTOMPQ(res), OBTOMPQ(res), OBTOMPQ(sp[e-args].u.object));
      
      RETURN res;
    }

  PIKEFUN object `+=(int|float|object ... a)
    flags ID_STATIC;
  {
    INT32 e;
    for(e=0; e<args; e++)
      get_mpq(sp+e-args, 1);
    for(e=0;e<args;e++)
      mpq_add(THISMPQ, THISMPQ, OBTOMPQ(sp[e-args].u.object));
    
    REF_RETURN fp->current_object;
  }
  

#ifdef BIG_PIKE_INT
#define TOOBIGTEST || sp[e-args].u.integer>MAX_INT32
#else
#define TOOBIGTEST 
#endif

  static void mult_convert_args(INT32 args)
    {
      INT32 e;
      for(e=0; e<args; e++)
      {
	if(sp[e-args].type == T_OBJECT)
	{
	  if(sp[e-args].u.object->prog == mpzmod_program)
	    continue;
#ifdef AUTO_BIGNUM
	  if(sp[e-args].u.object->prog == bignum_program)
	    continue;
#endif
	}
	
	if(sp[e-args].type != T_INT || sp[e-args].u.integer<=0 TOOBIGTEST)
	  get_mpq(sp+e-args, 1);
      }
    }
  
  static void mult_args(MP_RAT *res,
			INT32 e,
			INT32 args)
    {
      int norm=0;
      for(;e<args;e++)
      {
	if(sp[e-args].type == T_INT)
	{
	  mpz_mul_ui(mpq_numref(res),
		      mpq_numref(res),
		      sp[e-args].u.integer);
	  norm++;
	}
	else if(sp[e-args].u.object->prog == mpq_program)
	{
	  mpq_mul(res, res, OBTOMPQ(sp[e-args].u.object));
	}else{
	  norm++;
	  mpz_mul(mpq_numref(res),
		   mpq_numref(res),
		   OBTOMPZ(sp[e-args].u.object));
	}
      }
      
      if(norm) mpq_canonicalize(res);
    }
  
  PIKEFUN object `*(int|float|object ... a)
    flags ID_STATIC;
    {
      struct object *res;
      mult_convert_args(args);
      
      res = fast_clone_object(mpq_program, 0);
      mpq_set(OBTOMPQ(res), THISMPQ);
      mult_args(OBTOMPQ(res), 0,args);
      
      RETURN res;
    }

  PIKEFUN object ``*(int|float|object ... a)
    flags ID_STATIC;
    {
      struct object *res;
      mult_convert_args(args);
      
      res = fast_clone_object(mpq_program, 0);
      mpq_set(OBTOMPQ(res), THISMPQ);
      mult_args(OBTOMPQ(res), 0,args);
      
      RETURN res;
    }

  PIKEFUN object `*=(int|float|object ... a)
    flags ID_STATIC;
  {
    mult_convert_args(args);
    mult_args(THISMPQ, 0,args);
    REF_RETURN fp->current_object;
  }
  
  PIKEFUN object `-(int|float|object ... a)
    flags ID_STATIC;
    {
      INT32 e;
      struct object *res;
      
      if (args)
	for (e = 0; e<args; e++)
	  get_mpq(sp + e - args, 1);
      
      res = fast_clone_object(mpq_program, 0);
      mpq_set(OBTOMPQ(res), THISMPQ);
      
      if(args)
      {
	for(e=0;e<args;e++)
	  mpq_sub(OBTOMPQ(res), OBTOMPQ(res), OBTOMPQ(sp[e-args].u.object));
      }else{
	mpq_neg(OBTOMPQ(res), OBTOMPQ(res));
      }
      
      RETURN res;
    }

  PIKEFUN object ``-(int|float|object sv)
    flags ID_STATIC;
    {
      struct object *res;
      MP_RAT *a=get_mpq(sv,1);
      res = fast_clone_object(mpq_program, 0);
      mpq_sub(OBTOMPQ(res), a, THISMPQ);
      RETURN res;
    }
  
  PIKEFUN object `/(int|float|object ... a)
    flags ID_STATIC;
    {
      INT32 e;
      struct object *res;
      
      for(e=0;e<args;e++)
	if (!mpq_sgn(get_mpq(sp+e-args, 1)))
	  Pike_error("Division by zero.\n");
      
      res = fast_clone_object(mpq_program, 0);
      mpq_set(OBTOMPQ(res), THISMPQ);
      for(e=0;e<args;e++)	
	mpq_div(OBTOMPQ(res), OBTOMPQ(res), OBTOMPQ(sp[e-args].u.object));
      
      RETURN res;
    }
  
  PIKEFUN object ``/(int|float|object sv)
    flags ID_STATIC;
    {
      MP_RAT *a;
      struct object *res = NULL;
      if(!mpq_sgn(THISMPQ))
	Pike_error("Division by zero.\n");
      
      a=get_mpq(sv,1);
      
      res=fast_clone_object(mpq_program,0);
      mpq_div(OBTOMPQ(res), a, THISMPQ);
      
      RETURN res;
    }

  /* a%b =  a -  floor(a/b)*b */
  PIKEFUN object `%(int|float|object ... a)
    flags ID_STATIC;
    {
      INT32 e;
      struct object *res;
      mpq_t tmp;
      
      for(e=0;e<args;e++)
	if (!mpq_sgn(get_mpq(sp+e-args, 1)))
	  Pike_error("Modulo by zero.\n");	
  
      res = fast_clone_object(mpq_program, 0);
      
      mpq_init(tmp);
      mpq_set(OBTOMPQ(res), THISMPQ);
      
      for(e=0;e<args;e++)
      {
	mpz_mul(mpq_numref(tmp),
		mpq_numref(OBTOMPQ(res)),
		mpq_denref(OBTOMPQ(sp[e-args].u.object)));
	
	mpz_tdiv_q(mpq_numref(tmp),
		   mpq_numref(tmp),
		   mpq_denref(tmp));
	
	mpz_tdiv_q(mpq_numref(tmp),
		   mpq_numref(tmp),
		   mpq_numref(OBTOMPQ(sp[e-args].u.object)));
	
	mpz_set_si(mpq_denref(tmp),1);
	
	mpq_mul(tmp, tmp, OBTOMPQ(sp[e-args].u.object));
	mpq_sub(OBTOMPQ(res), OBTOMPQ(res), tmp);
      }
      mpq_clear(tmp);
      
      RETURN res;
    }

  PIKEFUN object ``%(int|float|object ... a)
    flags ID_STATIC;
    {
      MP_RAT *a;
      
      struct object *res;
      if(!mpq_sgn(THISMPQ))
	Pike_error("Modulo by zero.\n");
      
      if(args!=1)
	Pike_error("Gmp.mpq->``%%() called with more than one argument.\n");
      
      a=get_mpq(sp-1,1);
      
      res=fast_clone_object(mpq_program,0);
      
      mpz_mul(mpq_numref(OBTOMPQ(res)), mpq_numref(a), mpq_denref(THISMPQ));
      
      mpz_tdiv_q(mpq_numref(OBTOMPQ(res)),
		 mpq_numref(OBTOMPQ(res)),
		 mpq_denref(OBTOMPQ(res)));
		 
      mpz_tdiv_q(mpq_numref(OBTOMPQ(res)),
		 mpq_numref(OBTOMPQ(res)),
		 mpq_numref(a));
      
      mpz_set_si(mpq_denref(OBTOMPQ(res)),1);
      
      mpq_mul(OBTOMPQ(res), OBTOMPQ(res), THISMPQ);
      mpq_sub(OBTOMPQ(res), a, OBTOMPQ(res));
      
      RETURN res;
    }

  PIKEFUN object invert()
    {
      struct object *res;
      if (!mpq_sgn(THISMPQ))
	Pike_error("divide by zero in mpq->invert\n");
      res = fast_clone_object(mpq_program, 0);
      mpq_inv(OBTOMPQ(res), THISMPQ);
      RETURN res;
    }
  
  /* defined as -1-x */
  PIKEFUN object `~()
    flags ID_STATIC;
    {
      struct object *o;
      o=fast_clone_object(mpq_program,0);
      mpq_set_si(OBTOMPQ(o), -1, 1);
      mpq_sub(OBTOMPQ(o),OBTOMPQ(o), THISMPQ);
      
      RETURN o;
    }

  PIKEFUN int `>(mixed q)
    flags ID_STATIC;
    {
      RETURN mpq_cmp(THISMPQ, get_mpq(q, 1)) > 0;
    }

  PIKEFUN int `<(mixed q)
    flags ID_STATIC;
    {
      RETURN mpq_cmp(THISMPQ, get_mpq(q, 1)) < 0;
    }
  
  PIKEFUN int `>=(mixed q)
    flags ID_STATIC;
  {
    RETURN mpq_cmp(THISMPQ, get_mpq(q, 1)) >= 0;
  }
  
  PIKEFUN int `<=(mixed q)
    flags ID_STATIC;
  {
    RETURN mpq_cmp(THISMPQ, get_mpq(q, 1)) <= 0;
  }


  PIKEFUN int `==(mixed q)
    flags ID_STATIC;
  {
    MP_RAT *arg=get_mpq(q, 0);
    RETURN arg && !mpq_cmp(THISMPQ, arg);
  }

  PIKEFUN int `!=(mixed q)
    flags ID_STATIC;
  {
    MP_RAT *arg=get_mpq(q, 0);
    RETURN !(arg && !mpq_cmp(THISMPQ, arg));
  }

  PIKEFUN int sgn()
    {
      RETURN mpq_sgn(THISMPQ);
    }

  PIKEFUN int `!()
    flags ID_STATIC;
    {
      RETURN !mpq_sgn(THISMPQ);
    }

  INIT
    {
#ifdef PIKE_DEBUG
      if(!fp) Pike_fatal("ZERO FP\n");
      if(!THISMPQ) Pike_fatal("ZERO THISMPQ\n");
#endif
      mpq_init(THISMPQ);
    }
  
  EXIT
    {
#ifdef PIKE_DEBUG
      if(!fp) Pike_fatal("ZERO FP\n");
      if(!THISMPQ) Pike_fatal("ZERO THISMPQ\n");
#endif
      mpq_clear(THISMPQ);
    }
  
}

#endif /* USE_GMP */


void pike_init_mpq_module(void)
{
  INIT
}

void pike_exit_mpq_module(void)
{
  EXIT
}
