// -*- Pike -*-

// Callback arguments and return values
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return "<t2>";});
  p->add_tag ("t2", "a");
  return p->finish("<t>")->read();
]], "a");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({"<t>"});});
  return p->finish("<t>")->read();
]], "<t>");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return "<t>";});
  if (catch {
    return p->finish("<t>")->read();
  }) return 1;
]], 1);
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", "<t>");
  if (catch {
    return p->finish("<t>")->read();
  }) return 1;
]], "<t>");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", "t");
  return p->finish("<t a=b c>")->read();
]], "t");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->finish("<t a>")->read();
]], "a");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({sort(indices(a))*","});});
  return p->finish("<t a=b 1=2>")->read();
]], [["1,a"]]);
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({sort(values(a))*","});});
  return p->finish("<t a=b 1=2>")->read();
]], [["2,b"]]);
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return p;});
  if (catch {
    return p->finish("<t>")->read();
  }) return 1;
]], 1);
test_any([[
  object p = Parser.HTML();
  p->add_entity ("e", lambda (object p) {return "<t>";});
  p->add_tag ("t", "a");
  return p->finish("&e;")->read();
]], "a");
test_any([[
  object p = Parser.HTML();
  p->add_entity ("e", lambda (object p) {return ({"&e;"});});
  return p->finish("&e;")->read();
]], "&e;");
test_any([[
  object p = Parser.HTML();
  p->add_entity ("e", lambda (object p) {return "&e;";});
  if (catch {
    return p->finish("&e;")->read();
  }) return 1;
]], 1);
test_any([[
  object p = Parser.HTML();
  p->add_entity ("e", "e");
  return p->finish("&e;")->read();
]], "e");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", "&e;");
  p->add_entity ("e", "<t>");
  if (catch {
    return p->finish("<t>&e;")->read();
  }) return 1;
]], "&e;<t>");
test_any_equal([[
  object p = Parser.HTML();
  p->mixed_mode (1);
  p->add_tag ("t", ({lambda (object p, mixed... e) {return e;}, 17, (<>)}));
  p->add_container ("c", ({lambda (object p, mixed... e) {return e;}, ({}), 0, 0}));
  p->add_entity ("e", ({lambda (object p, mixed... e) {return e;}, "f"}));
  p->set_extra (4711);
  return p->finish("<t a><c>x</c>&e;")->read();
]], ({(["a": "a"]), 17, (<>), 4711,
      ([]), "x", ({}), 0, 0, 4711,
      "f", 4711}));
test_any([[
  object p = Parser.HTML();
  p->_set_tag_callback (
    lambda (object p, string str) {
      p->add_container (p->tag_name(),
			lambda (object p, mapping a, string c) {
			  return ({"C(", p->tag_name(), "|", c, ")"});
			});
      return 1;
    });
  return p->finish ("<t>x</t>")->read();
]], "C(t|x)");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", "x");
  p->add_quote_tag ("!--",
		    lambda (object p, string s) {
		      return ({"[", s, "]"});
		    },
		    "--");
  p->add_quote_tag ("!-",
		    lambda (object p, string s) {
		      return ({"{", s, "}"});
		    },
		    "\'");
  return p->finish ("<t> <!-- <t a='> -- --> <!-<t a='> -->")->read();
]], "x [ <t a='> -- ] {<t a=} -->");
test_any([[
  object p = Parser.HTML();
  p->lazy_entity_end (1);
  p->_set_entity_callback (lambda (object p, string s) {return ({"[",s,"]"});});
  return p->finish ("&abc|&abc<>&abc;")->read();
]], "[&abc|][&abc]<>[&abc;]");

// Current context functions
test_any([[
  object p = Parser.HTML();
  p->lazy_entity_end (1);
  p->add_tag (
    "t", lambda (object p, mapping a) {
	   return ({"T(", p->current(), "|", p->tag_name(), "|",
		    (string) p->tag_content(), ")"});
	 });
  p->add_container (
    "c", lambda (object p, mapping a, string c) {
	   return ({"C(", p->current(), "|", p->tag_name(), "|",
		    (string) p->tag_content(), ")"});
	 });
  p->add_entity (
    "e", lambda (object p) {
	   return ({"E(", p->current(), "|", p->tag_name(), "|",
		    (string) p->tag_content(), ")"});
	 });
  p->add_quote_tag (
    "q", lambda (object p, string c) {
	   return ({"Q(", p->current(), "|", p->tag_name(), "|",
		    (string) p->tag_content(), ")"});
	 }, "p");
  return p->finish ("<t a=&e; <t>> <q <\"' &e; p> &e<c x=y -- >x</c> &e; ")->read();
]], "T(<t a=&e; <t>>|t|0) Q(<q <\"' &e; p>|q| <\"' &e; ) E(&e|e|0)C(<c x=y -- >x</c>|c|x) E(&e;|e|0) ");

// Argument quoting
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->finish("<t a=\"f'o\">")->read();
]], "f'o");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->finish("<t a='f\"o'>")->read();
]], "f\"o");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->finish("<t a=\"\\\">")->read();
]], "\\");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->finish("<t a='f'\"'\"'o'>")->read();
]], "f'o");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->finish("<t a=\"f\"'\"'\"o\">")->read();
]], "f\"o");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({"(", a->a, ")"});});
  return p->finish("<t a=f>oo>")->read();
]], "(f)oo>");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->finish("<t a=\"f'o><t>")->read();
]], "f'o><t>");

// Local feeds
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a)
		     {p->feed_insert("<t2>"); return ({"<t3>"});});
  p->add_tags ((["t2": "2", "t3": "3"]));
  return p->finish("a<t>b<t>c")->read();
]], "a<t3>2b<t3>2c");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a)
		     {p->feed_insert("<t2>"); return "<t3>";});
  p->add_tags ((["t2": "2", "t3": "3"]));
  return p->finish("a<t>b<t>c")->read();
]], "a32b32c");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a)
		     {p->feed_insert("<t2>"); return "<t3>";});
  p->add_tag ("t2", lambda (object p, mapping a)
		      {p->feed_insert("A<t3>B"); return "2";});
  p->add_tag ("t3", "3");
  return p->finish("a<t>b<t>c")->read();
]], "a32A3Bb32A3Bc");
test_any([[
  object p = Parser.HTML();
  p->add_container ("t", lambda (object p, mapping a, string s)
			   {p->feed_insert("<t2>"); return s;});
  p->add_tags ((["t2": "2", "t3": "3"]));
  return p->finish("a<t>b<t3>c</t>d")->read();
]], "ab3c2d");

// Streaming
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->feed("<t a=1>2")->feed("<t a=3>")->read();
]], "123");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->feed("<t a=1>2")->read() + " " + p->feed("<t a=3>")->read();
]], "12 3");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->feed("<t a='f")->feed("oo'>")->read();
]], "foo");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->feed("<t a='f")->read() + " " + p->feed("oo'>")->read();
]], " foo");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->feed("<t a='f>")->read();
]], "");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->finish("<t a='f>")->read();
]], "f>");
test_any([[
  object p = Parser.HTML();
  p->add_entity ("e", lambda (object p) {return "e";});
  return p->feed("&e")->read() + " " + p->feed(";")->read();
]], " e");
test_any([[
  object p = Parser.HTML();
  p->add_quote_tag ("!--", lambda (object p, string s) {return ({s});}, "--");
  p->add_quote_tag ("!--[", lambda (object p, string s) {return ({s});}, "]--");
  p->add_quote_tag ("![", lambda (object p, string s) {return ({s});}, "]");
  return (p->feed("<!")->read() + " " +
	  p->feed("--")->read() + " " +
	  p->feed("x-->")->read());
]], "  x");
test_any([[
  object p = Parser.HTML();
  p->add_quote_tag ("!--", lambda (object p, string s) {return ({s});}, "--");
  p->add_quote_tag ("!--[", lambda (object p, string s) {return ({s});}, "]--");
  p->add_quote_tag ("![", lambda (object p, string s) {return ({s});}, "]");
  return (p->feed("<!")->read() + " " +
	  p->feed("--")->read() + " " +
	  p->feed("x--")->read() + " " +
	  p->feed("->")->read());
]], "   x-");

// Exception handling
test_any([[{
  object p = Parser.HTML();
  int t, c, e, q;
  p->add_tag ("t", lambda (object p, mapping a) {
		     if (t++ < 3) {p->write_out ((string) t); throw (t);}
		     return ({"|", (string) t});
		   });
  p->add_container ("c", lambda (object p, mapping a, string s) {
			   if (c++ < 3) {p->write_out ((string) c); throw (c);}
			   return ({"|", (string) c});
			 });
  p->add_entity ("e", lambda (object p) {
			if (e++ < 3) {p->write_out ((string) e); throw (e);}
			return ({"|", (string) e});
		      });
  p->add_quote_tag ("q", lambda (object p, string s) {
			   if (q++ < 3) {p->write_out ((string) q); throw (q);}
			   return ({"|", (string) q});
			 },
		    "q");
  if (catch (p->finish ("<t> <c> <t> &e; </c> &e; <q &e; q>")))
    for (int i; i < 20; i++)
      if (!catch (p->finish())) break;
  return p->read();
}]], "123|4 123|4 123|4 123|4")

// Mixed mode
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({1});});
  return !!catch (p->finish("a<t>b")->read());
]], 1);
test_any_equal([[
  object p = Parser.HTML();
  p->mixed_mode (1);
  p->add_tag ("t", lambda (object p, mapping a) {p->write_out(1); return ({2});});
  return p->finish("a<t>b")->read();
]], ({"a",1,2,"b"}));
test_any_equal([[
  object p = Parser.HTML();
  p->mixed_mode (1);
  p->add_tag ("t", lambda (object p, mapping a) {return ({a});});
  return p->finish("<t a=b>")->read();
]], ({(["a": "b"])}));

// Unbalanced tags and quotes
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", "b");
  p->add_tag ("t>", "c");
  p->_set_tag_callback (lambda (object p, string s)
			  {p->feed_insert(s[1..]); return ({s[..0]});});
  return p->finish("<a href=\"<t\">")->read();
]], "<a href=\"c");
test_any_equal([[
  object p = Parser.HTML();
  p->match_tag (0);
  p->add_container ("c", lambda (object p, mapping a, string s)
			   {return ({"[",s,"]"});});
  return p->finish("<c></c </c>>")->read();
]], "[</c ]>");
test_any_equal([[
  object p = Parser.HTML();
  p->match_tag (0);
  p->add_container ("c", lambda (object p, mapping a, string s) {return ({s});});
  return p->finish("<c><</c>")->read();
]], "<");
test_any([[
  object p = Parser.HTML();
  p->add_container ("c", "C");
  return p->finish("<c> <!-- \" </c> --> </c> <c> <!-- \" --> </c> ")->read();
]], "C ");
test_any([[
  object p = Parser.HTML();
  p->ignore_unknown (1);
  p->add_container ("c", "C");
  return p->finish("<c> <!-- \" </c> --> </c> <c> <!-- \" --> </c> ")->read();
]], "C --> </c> C ");
test_any([[
  object p = Parser.HTML();
  p->add_quote_tag ("!--", ".", "--");
  p->add_container ("c", "C");
  return p->finish("<c> <!-- \" </c> --> </c> <c> <!-- \" --> </c> ")->read();
]], "C C ");
test_any_equal([[
  object p = Parser.HTML();
  p->mixed_mode (1);
  p->add_tag ("t", lambda (object p, mapping a) {return p->tag();});
  return p->finish("<t a b='b>")->read();
]], ({"t", (["a": "a", "b": "b>"]), 0}));
test_any_equal([[
  object p = Parser.HTML();
  p->mixed_mode (1);
  p->add_tag ("t", lambda (object p, mapping a) {return p->tag((<>));});
  return p->finish("<t a b='b>")->read();
]], ({"t", (["a": (<>), "b": "b>"]), 0}));

// Redefinition during parsing
test_any([[
  object p = Parser.HTML();
  p->add_tag ("a", lambda (object p, mapping a)
		     {p->add_tag ("b", "B"); return ({"A"});});
  return p->finish("<b><a><b>")->read();
]], "<b>AB");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("a", lambda (object p, mapping a)
		     {p->add_tag ("b", 0); return ({"A"});});
  p->add_tag ("b", "B");
  return p->finish("<b><a><b>")->read();
]], "BA<b>");

// Delimiters
test_any([[
  object p = Parser.HTML();
  p->lazy_entity_end (1);
  p->add_entity ("e", "x");
  return p->finish("&e; &e<t> &e <t> a='&e&e' &e=f; b=\"&e\" &e>")->read();
]], "x x<t> &e <t> a='xx' &e=f; b=\"x\" x>");

// Recursive parsing in tags
test_any([[
  object p = Parser.HTML();
  p->add_entity ("e", "e");
  p->add_tag ("t", lambda (object p, mapping a) {return ({sort(values(a))*","});});
  return p->finish("<t a=\"&e;\">")->read();
]], "&e;");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", "b");
  return p->finish("<!-- <t> -->")->read();
]], "<!-- <t> -->");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", "b");
  p->ignore_unknown (1);
  return p->finish("<!-- <t> -->")->read();
]], "<!-- b -->");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", "b");
  return p->finish("<a href=\"<t>\">")->read();
]], "<a href=\"<t>\">");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", "b");
  p->ignore_unknown (1);
  return p->finish("<a href=\"<t>\">")->read();
]], "<a href=\"b\">");

// Misc
test_any([[
  object p = Parser.HTML();
  p->add_container ("t", lambda (object p, mapping a, string s)
			   {p->write_out("|"); return s;});
  p->add_tag ("t2", "2");
  p->ignore_unknown (1);
  p->_set_data_callback (lambda (object p, string s)
			   {return ({"[",s,"]"});});
  return p->finish("<f <t2>=<t2>><t><t2><a<t2>></t><o>")->read();
]], "[<f ]2[=]2[>]|2[<a]2[>][<o>]");
test_any([[
  object p = Parser.HTML();
  p->add_container ("t", lambda (object p, mapping a, string s)
			   {p->write_out("|"); return s;});
  p->add_tag ("t2", "2");
  p->_set_tag_callback (lambda (object p, string s)
			  {p->feed_insert(s[1..]); return ({s[..0]});});
  p->_set_data_callback (lambda (object p, string s)
			   {return ({"[",s,"]"});});
  return p->finish("<f <t2>=<t2>><t><t2><a<t2>></t><o>")->read();
]], "<[f ]2[=]2[>]|2<[a]2[>]<[o>]");
test_any([[
  object p = Parser.HTML();
  p->add_container ("t", lambda (object p, mapping a, string s)
			   {p->write_out("|"); return s;});
  p->add_tag ("t2", "2");
  p->ignore_unknown (1);
  p->_set_data_callback (lambda (object p, string s)
			   {return ({"[",s,"]"});});
  return p->finish("x<f x<t2>=<t2>x>x<t>x<t2>x<a<t2>x>x</t>x<o>x")->read();
]], "[x][<f x]2[=]2[x>x]|[x]2[x][<a]2[x>xx][<o>x]");
test_any([[
  object p = Parser.HTML();
  p->add_container ("t", lambda (object p, mapping a, string s)
			   {p->write_out("|"); return s;});
  p->add_tag ("t2", "2");
  p->_set_tag_callback (lambda (object p, string s)
			  {p->feed_insert(s[1..]); return ({s[..0]});});
  p->_set_data_callback (lambda (object p, string s)
			   {return ({"[",s,"]"});});
  return p->finish("x<f x<t2>=<t2>x>x<t>x<t2>x<a<t2>x>x</t>x<o>x")->read();
]], "[x]<[f x]2[=]2[x>x]|[x]2[x]<[a]2[x>xx]<[o>x]");
test_any([[
  object p = Parser.HTML();
  p->case_insensitive_tag (1);
  p->add_tag ("aA","[a]");
  p->add_container ("Bb","[b]");
  p->add_entity ("cC","[c]");
  return p->finish("<aa><AA><bb></Bb><BB></bB>&cc;&CC;")->read();
]], "[a][a][b][b]&cc;&CC;");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("aA","[a]");
  p->add_container ("Bb","[b]");
  p->add_entity ("cC","[c]");
  return p->finish("<aa><AA><bb></Bb><BB></bB>&cc;&CC;")->read();
]], "<aa><AA><bb></Bb><BB></bB>&cc;&CC;");
