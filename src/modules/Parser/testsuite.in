// -*- Pike -*-

// Callback arguments and return values
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return "<t2>";});
  p->add_tag ("t2", "a");
  return p->finish("<t>")->read();
]], "a");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({"<t>"});});
  return p->finish("<t>")->read();
]], "<t>");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return "<t>";});
  if (catch {
    return p->finish("<t>")->read();
  }) return 1;
]], 1);
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", "<t>");
  if (catch {
    return p->finish("<t>")->read();
  }) return 1;
]], "<t>");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", "t");
  return p->finish("<t a=b c>")->read();
]], "t");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->finish("<t a>")->read();
]], "a");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({sort(indices(a))*","});});
  return p->finish("<t a=b 1=2>")->read();
]], [["1,a"]]);
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({sort(values(a))*","});});
  return p->finish("<t a=b 1=2>")->read();
]], [["2,b"]]);
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return p;});
  if (catch {
    return p->finish("<t>")->read();
  }) return 1;
]], 1);
test_any([[
  object p = Parser.HTML();
  p->add_entity ("e", lambda (object p) {return "<t>";});
  p->add_tag ("t", "a");
  return p->finish("&e;")->read();
]], "a");
test_any([[
  object p = Parser.HTML();
  p->add_entity ("e", lambda (object p) {return ({"&e;"});});
  return p->finish("&e;")->read();
]], "&e;");
test_any([[
  object p = Parser.HTML();
  p->add_entity ("e", lambda (object p) {return "&e;";});
  if (catch {
    return p->finish("&e;")->read();
  }) return 1;
]], 1);
test_any([[
  object p = Parser.HTML();
  p->add_entity ("e", "e");
  return p->finish("&e;")->read();
]], "e");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", "&e;");
  p->add_entity ("e", "<t>");
  if (catch {
    return p->finish("<t>&e;")->read();
  }) return 1;
]], "&e;<t>");
test_any_equal([[
  object p = Parser.HTML();
  p->mixed_mode (1);
  p->add_tag ("t", ({lambda (object p, mixed... e) {return e;}, 17, (<>)}));
  p->add_container ("c", ({lambda (object p, mixed... e) {return e;}, ({}), 0, 0}));
  p->add_entity ("e", ({lambda (object p, mixed... e) {return e;}, "f"}));
  p->set_extra (4711);
  return p->finish("<t a><c>x</c>&e;")->read();
]], ({(["a": "a"]), 17, (<>), 4711,
      ([]), "x", ({}), 0, 0, 4711,
      "f", 4711}));
test_any([[
  object p = Parser.HTML();
  p->_set_tag_callback (
    lambda (object p, string str) {
      p->add_container (p->tag_name(),
			lambda (object p, mapping a, string c) {
			  return ({"C(", p->tag_name(), "|", c, ")"});
			});
      return 1;
    });
  return p->finish ("<t>x</t>")->read();
]], "C(t|x)");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", "x");
  p->add_quote_tag ("!--",
		    lambda (object p, string s) {
		      return ({"[", s, "]"});
		    },
		    "--");
  p->add_quote_tag ("!-",
		    lambda (object p, string s) {
		      return ({"{", s, "}"});
		    },
		    "\'");
  return p->finish ("<t> <!-- <t a='> -- --> <!-<t a='> -->")->read();
]], "x [ <t a='> -- ] {<t a=} -->");
test_any_equal([[
  object p = Parser.HTML();
  array a = ({ });
  p->_set_tag_callback (
    lambda (object p, string str) {
      a += ({ p->tag_name() });
      return 0;
    });
  p->finish("<t>x</t>");
  return a;
]], ({ "t", "/t" }));

// Current context functions
test_any([[{
  object p = Parser.HTML();
  p->lazy_entity_end (1);
  p->add_tag (
    "t", lambda (object p, mapping a) {
	   return ({"T(", p->current(), "|", p->tag_name(), "|",
		    (string) p->tag_content(), ")"});
	 });
  p->add_container (
    "c", lambda (object p, mapping a, string c) {
	   return ({"C(", p->current(), "|", p->tag_name(), "|",
		    (string) p->tag_content(), ")"});
	 });
  p->add_entity (
    "e", lambda (object p) {
	   return ({"E(", p->current(), "|", p->tag_name(), "|",
		    (string) p->tag_content(), ")"});
	 });
  p->add_quote_tag (
    "q", lambda (object p, string c) {
	   return ({"Q(", p->current(), "|", p->tag_name(), "|",
		    (string) p->tag_content(), ")"});
	 }, "p");
  return p->finish ("<t a=&e; <t>> <q <\"' &e; p> "
		    "&e<c x=y -- >x</c> &e; <x &e; q=&e;>")->read();
}]], ("T(<t a=&e; <t>>|t|0) Q(<q <\"' &e; p>|q| <\"' &e; ) "
      "&eC(<c x=y -- >x</c>|c|x) E(&e;|e|0) <x &e; q=E(&e;|e|0)>"));

// Argument quoting
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->finish("<t a=\"f'o\">")->read();
]], "f'o");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->finish("<t a='f\"o'>")->read();
]], "f\"o");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->finish("<t a=\"\\\">")->read();
]], "\\");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->finish("<t a='f'\"'\"'o'>")->read();
]], "f'o");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->finish("<t a=\"f\"'\"'\"o\">")->read();
]], "f\"o");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({"(", a->a, ")"});});
  return p->finish("<t a=f>oo>")->read();
]], "(f)oo>");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->finish("<t a=\"f'o><t>")->read();
]], "f'o><t>");
test_any([[{
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a)
		     {return ({a["b/a"]+"|"+a["/a"]+"|"+a["a/"]+"|"+a["a"]});});
  return p->finish("<t b/a> <t b /a> <t b a/> "
		   "<t b /a=fo> <t b a/=fo> <t b a=/fo> "
		   "<t b a=f/o> <t b a=fo/> <t b a='fo/'>")->read();
}]], ("b/a|0|0|0 0|/a|0|0 0|0|0|a "
      "0|fo|0|0 0|0|fo|0 0|0|0|/fo "
      "0|0|0|f/o 0|0|0|fo 0|0|0|fo/"));
test_any([[{
  object p = Parser.HTML();
  p->xml_tag_syntax (0);
  p->add_tag ("t", lambda (object p, mapping a)
		     {return ({a["b/a"]+"|"+a["/a"]+"|"+a["a/"]+"|"+a["a"]});});
  return p->finish("<t b/a> <t b /a> <t b a/> "
		   "<t b /a=fo> <t b a/=fo> <t b a=/fo> "
		   "<t b a=f/o> <t b a=fo/> <t b a='fo/'>")->read();
}]], ("b/a|0|0|0 0|/a|0|0 0|0|a/|0 "
      "0|fo|0|0 0|0|fo|0 0|0|0|/fo "
      "0|0|0|f/o 0|0|0|fo/ 0|0|0|fo/"));

// Local feeds
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a)
		     {p->feed_insert("<t2>"); return ({"<t3>"});});
  p->add_tags ((["t2": "2", "t3": "3"]));
  return p->finish("a<t>b<t>c")->read();
]], "a<t3>2b<t3>2c");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a)
		     {p->feed_insert("<t2>"); return "<t3>";});
  p->add_tags ((["t2": "2", "t3": "3"]));
  return p->finish("a<t>b<t>c")->read();
]], "a32b32c");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a)
		     {p->feed_insert("<t2>"); return "<t3>";});
  p->add_tag ("t2", lambda (object p, mapping a)
		      {p->feed_insert("A<t3>B"); return "2";});
  p->add_tag ("t3", "3");
  return p->finish("a<t>b<t>c")->read();
]], "a32A3Bb32A3Bc");
test_any([[
  object p = Parser.HTML();
  p->add_container ("t", lambda (object p, mapping a, string s)
			   {p->feed_insert("<t2>"); return s;});
  p->add_tags ((["t2": "2", "t3": "3"]));
  return p->finish("a<t>b<t3>c</t>d")->read();
]], "ab3c2d");

// Streaming
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->feed("<t a=1>2")->feed("<t a=3>")->read();
]], "123");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->feed("<t a=1>2")->read() + " " + p->feed("<t a=3>")->read();
]], "12 3");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->feed("<t a='f")->feed("oo'>")->read();
]], "foo");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->feed("<t a='f")->read() + " " + p->feed("oo'>")->read();
]], " foo");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->feed("<t a='f>")->read();
]], "");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->finish("<t a='f>")->read();
]], "f>");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return (p->feed("<")->feed("t")->feed(" ")->feed("a")->feed("=")->feed("'")->
	  feed("f")->feed("o")->feed("o")->feed("'")->feed(">")->read());
]], "foo");
test_any([[{
  object p = Parser.HTML();
  p->add_container ("c", lambda (object p, mapping a, string c)
			   {return ({"[", a->a, "|", c, "]"});});
  return (p->feed("<")->feed("c")->feed(" ")->feed("a")->feed("=")->feed("'")->
	  feed("f")->feed("o")->feed("o")->feed("'")->feed(">")->feed("x")->
	  feed("y")->feed("<")->feed("c")->feed(">")->feed("z")->feed("<")->
	  feed("t")->feed(">")->feed("<")->feed("/")->feed("c")->feed(">")->
	  feed("q")->feed("<")->feed("/")->feed("c")->feed(">")->feed(".")->read());
}]], "[foo|xy<c>z<t></c>q].");
test_any([[
  object p = Parser.HTML();
  p->add_entity ("e", lambda (object p) {return "e";});
  return p->feed("&e")->read() + " " + p->feed(";")->read();
]], " e");
test_any([[
  object p = Parser.HTML();
  p->add_quote_tag ("!--", lambda (object p, string s) {return ({s});}, "--");
  p->add_quote_tag ("!--[", lambda (object p, string s) {return ({s});}, "]--");
  p->add_quote_tag ("![", lambda (object p, string s) {return ({s});}, "]");
  return (p->feed("<!")->read() + " " +
	  p->feed("--")->read() + " " +
	  p->feed("x-->")->read());
]], "  x");
test_any([[
  object p = Parser.HTML();
  p->add_quote_tag ("!--", lambda (object p, string s) {return ({s});}, "--");
  p->add_quote_tag ("!--[", lambda (object p, string s) {return ({s});}, "]--");
  p->add_quote_tag ("![", lambda (object p, string s) {return ({s});}, "]");
  return (p->feed("<!")->read() + " " +
	  p->feed("--")->read() + " " +
	  p->feed("x--")->read() + " " +
	  p->feed("->")->read());
]], "   x-");
test_any([[{
  object p = Parser.HTML();
  p->add_quote_tag ("!--", lambda (object p, string s) {return ({"1",s});}, "--");
  p->add_quote_tag ("!--[", lambda (object p, string s) {return ({"2",s});}, "]-");
  p->add_quote_tag ("![", lambda (object p, string s) {return ({"3",s});}, "]");
  return (p->feed("<")->read() + "a" + p->feed("!")->read() + "b" +
	  p->feed("-")->read() + "c" + p->feed("-")->read() + "d" +
	  p->feed("X")->read() + "e" + p->feed("Y")->read() + "f" +
	  p->feed("]")->read() + "g" + p->feed(">")->read() + "h" +
	  p->feed("]")->read() + "i" + p->feed("-")->read() + "j" +
	  p->feed(">")->read() + "k" + p->feed("-")->read() + "l" +
	  p->feed("-")->read() + "m" + p->feed("-")->read() + "n" +
	  p->feed(">")->read());
}]], "abcdefghijklmn1XY]>]->-");

// Exception handling
test_any([[{
  object p = Parser.HTML();
  int t, c, e, q;
  p->add_tag ("t", lambda (object p, mapping a) {
		     if (t++ < 3) {p->write_out ((string) t); throw (t);}
		     return ({"|", (string) t});
		   });
  p->add_container ("c", lambda (object p, mapping a, string s) {
			   if (c++ < 3) {p->write_out ((string) c); throw (c);}
			   return ({"|", (string) c});
			 });
  p->add_entity ("e", lambda (object p) {
			if (e++ < 3) {p->write_out ((string) e); throw (e);}
			array res = ({"|", (string) e});
			e = 0;
			return res;
		      });
  p->add_quote_tag ("q", lambda (object p, string s) {
			   if (q++ < 3) {p->write_out ((string) q); throw (q);}
			   return ({"|", (string) q});
			 },
		    "q");
  if (catch (p->finish ("<t> <c> <t> &e; </c> &e; <q &e; q> <x a=&e; &e;>")))
    for (int i; i < 20; i++)
      if (!catch (p->finish())) break;
  return p->read();
}]], "123|4 123|4 123|4 123|4 123<x a=|4 &e;>")

// Mixed mode
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({1});});
  return !!catch (p->finish("a<t>b")->read());
]], 1);
test_any_equal([[
  object p = Parser.HTML();
  p->mixed_mode (1);
  p->add_tag ("t", lambda (object p, mapping a) {p->write_out(1); return ({2});});
  return p->finish("a<t>b")->read();
]], ({"a",1,2,"b"}));
test_any_equal([[
  object p = Parser.HTML();
  p->mixed_mode (1);
  p->add_tag ("t", lambda (object p, mapping a) {return ({a});});
  return p->finish("<t a=b>")->read();
]], ({(["a": "b"])}));

// Unbalanced tags and quotes
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", "b");
  p->add_tag ("t>", "c");
  p->_set_tag_callback (lambda (object p, string s)
			  {p->feed_insert(s[1..]); return ({s[..0]});});
  return p->finish("<a href=\"<t\">")->read();
]], "<a href=\"c");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a)
		     {return ({"[",a->test,"]"});});
  return p->finish("<t test=\">")->read();
]], "[>]");
test_any([[
  object p = Parser.HTML();
  p->add_container ("c", lambda (object p, mapping a, string s)
			   {return ({"[",a->test,"|",s,"]"});});
  return p->finish("<c test=\">")->read();
]], "[>|]");
test_any_equal([[
  object p = Parser.HTML();
  p->match_tag (0);
  p->add_container ("c", lambda (object p, mapping a, string s)
			   {return ({"[",s,"]"});});
  return p->finish("<c></c </c>>")->read();
]], "[</c ]>");
test_any_equal([[
  object p = Parser.HTML();
  p->match_tag (0);
  p->add_container ("c", lambda (object p, mapping a, string s) {return ({s});});
  return p->finish("<c><</c>")->read();
]], "<");
test_any([[
  object p = Parser.HTML();
  p->add_container ("c", "C");
  return p->finish("<c> <!-- \" </c> --> </c> <c> <!-- \" --> </c> ")->read();
]], "C ");
test_any([[
  object p = Parser.HTML();
  p->ignore_unknown (1);
  p->add_container ("c", "C");
  return p->finish("<c> <!-- \" </c> --> </c> <c> <!-- \" --> </c> ")->read();
]], "C --> </c> C ");
test_any([[
  object p = Parser.HTML();
  p->add_quote_tag ("!--", ".", "--");
  p->add_container ("c", "C");
  return p->finish("<c> <!-- \" </c> --> </c> <c> <!-- \" --> </c> ")->read();
]], "C C ");
test_any_equal([[
  object p = Parser.HTML();
  p->mixed_mode (1);
  p->add_tag ("t", lambda (object p, mapping a) {return p->tag();});
  return p->finish("<t a b='b>")->read();
]], ({"t", (["a": "a", "b": "b>"]), 0}));
test_any_equal([[
  object p = Parser.HTML();
  p->mixed_mode (1);
  p->add_tag ("t", lambda (object p, mapping a) {return p->tag((<>));});
  return p->finish("<t a b='b>")->read();
]], ({"t", (["a": (<>), "b": "b>"]), 0}));

// Redefinition during parsing
test_any([[
  object p = Parser.HTML();
  p->add_tag ("a", lambda (object p, mapping a)
		     {p->add_tag ("b", "B"); return ({"A"});});
  return p->finish("<b><a><b>")->read();
]], "<b>AB");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("a", lambda (object p, mapping a)
		     {p->add_tag ("b", 0); return ({"A"});});
  p->add_tag ("b", "B");
  return p->finish("<b><a><b>")->read();
]], "BA<b>");

// Delimiters
test_any([[
  object p = Parser.HTML();
  p->lazy_entity_end (1);
  p->add_entity ("e", "x");
  return p->finish("&e; &e<t> &e <t> a='&e;&e' &e=f; b=\"&e\" &e>")->read();
]], "x &e<t> &e <t> a='x&e' &e=f; b=\"&e\" &e>");
test_any([[
  object p = Parser.HTML();
  p->lazy_entity_end (1);
  p->_set_entity_callback (lambda (object p, string s) {return ({"[",s,"]"});});
  return p->finish ("&abc|&abc<>&abc;")->read();
]], "&abc|&abc<>[&abc;]");
test_any([[
  object p = Parser.HTML();
  p->lazy_entity_end (1);
  p->_set_entity_callback (lambda (object p, string s) {return ({"[",s,"]"});});
  p->_set_data_callback (lambda (object p, string s) {return ({"{",s,"}"});});
  return p->finish ("&abc|&abc<>&abc;")->read();
]], "{&abc|}{&abc}<>[&abc;]{}");
test_any([[{
  object p = Parser.HTML();
  p->add_entity ("e", "x");
  return p->finish("&e")->read();
}]], "&e");
test_any([[{
  object p = Parser.HTML();
  p->lazy_entity_end (1);
  p->add_entity ("e", "x");
  return p->finish("&e")->read();
}]], "&e");

// Recursive parsing in tags
test_any([[
  object p = Parser.HTML();
  p->add_entity ("e", "e");
  p->add_tag ("t", lambda (object p, mapping a) {return ({sort(values(a))*","});});
  return p->finish("<t a=\"&e;\">")->read();
]], "&e;");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", "b");
  return p->finish("<!-- <t> -->")->read();
]], "<!-- <t> -->");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", "b");
  p->ignore_unknown (1);
  return p->finish("<!-- <t> -->")->read();
]], "<!-- b -->");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", "b");
  return p->finish("<a href=\"<t>\">")->read();
]], "<a href=\"<t>\">");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", "b");
  p->ignore_unknown (1);
  return p->finish("<a href=\"<t>\">")->read();
]], "<a href=\"b\">");

// XML syntax
test_any([[{
  object p = Parser.HTML();
  p->add_tag ("t", "()");
  p->add_container ("c", lambda (object p, mapping a, string s) {return ({"[",s,"]"});});
  return p->finish ("a<t>b</t>c<c>d</c>e<t/>f</t>g<c/>h</c>i")->read();
}]], "a()b</t>c[d]e()f</t>g[h]i");
test_any([[{
  object p = Parser.HTML();
  p->add_tag ("t", "()");
  p->add_container ("c", lambda (object p, mapping a, string s) {return ({"[",s,"]"});});
  p->xml_tag_syntax (2);
  return p->finish ("a<t>b</t>c<c>d</c>e<t/>f</t>g<c/>h</c>i")->read();
}]], "a()b</t>c[d]e()f</t>g[]h</c>i");
test_any([[{
  object p = Parser.HTML();
  p->add_tag ("t", "()");
  p->add_container ("c", lambda (object p, mapping a, string s) {return ({"[",s,"]"});});
  p->xml_tag_syntax (3);
  return p->finish ("a<t>b</t>c<c>d</c>e<t/>f</t>g<c/>h</c>i")->read();
}]], "a()c[d]e()f</t>g[]h</c>i");
test_any([[{
  object p = Parser.HTML();
  p->add_tag ("t", "()");
  return p->finish ("a<t>b</t>c<t/>d</t>e")->read();
}]], "a()b</t>c()d</t>e");
test_any([[{
  object p = Parser.HTML();
  p->add_container ("t", lambda (object p, mapping a, string s) {return ({"[",s,"]"});});
  return p->finish ("a<t>b</t>c<t/>d</t>e")->read();
}]], "a[b]c[d]e");
test_any([[{
  object p = Parser.HTML();
  p->add_tag ("t", "()");
  p->add_container ("t", lambda (object p, mapping a, string s) {return ({"[",s,"]"});});
  return p->finish ("a<t>b</t>c<t/>d</t>e")->read();
}]], "a()b</t>c()d</t>e");
test_any([[{
  object p = Parser.HTML();
  p->add_tag ("t", "()");
  p->xml_tag_syntax (2);
  return p->finish ("a<t>b</t>c<t/>d</t>e")->read();
}]], "a()b</t>c()d</t>e");
test_any([[{
  object p = Parser.HTML();
  p->add_container ("t", lambda (object p, mapping a, string s) {return ({"[",s,"]"});});
  p->xml_tag_syntax (2);
  return p->finish ("a<t>b</t>c<t/>d</t>e")->read();
}]], "a[b]c[]d</t>e");
test_any([[{
  object p = Parser.HTML();
  p->add_tag ("t", "()");
  p->add_container ("t", lambda (object p, mapping a, string s) {return ({"[",s,"]"});});
  p->xml_tag_syntax (2);
  return p->finish ("a<t>b</t>c<t/>d</t>e")->read();
}]], "a[b]c()d</t>e");
test_any([[{
  object p = Parser.HTML();
  p->add_tag ("t", "()");
  p->xml_tag_syntax (3);
  return p->finish ("a<t>b</t>c<t/>d</t>e")->read();
}]], "a()c()d</t>e");
test_any([[{
  object p = Parser.HTML();
  p->add_container ("t", lambda (object p, mapping a, string s) {return ({"[",s,"]"});});
  p->xml_tag_syntax (3);
  return p->finish ("a<t>b</t>c<t/>d</t>e")->read();
}]], "a[b]c[]d</t>e");
test_any([[{
  object p = Parser.HTML();
  p->add_tag ("t", "()");
  p->add_container ("t", lambda (object p, mapping a, string s) {return ({"[",s,"]"});});
  p->xml_tag_syntax (3);
  return p->finish ("a<t>b</t>c<t/>d</t>e")->read();
}]], "a[b]c()d</t>e");

// Misc
test_any([[
  object p = Parser.HTML();
  p->add_container ("t", lambda (object p, mapping a, string s)
			   {p->write_out("|"); return s;});
  p->add_tag ("t2", "2");
  p->ignore_unknown (1);
  p->_set_data_callback (lambda (object p, string s)
			   {return ({"[",s,"]"});});
  return p->finish("<f <t2>=<t2>><t><t2><a<t2>></t><o>")->read();
]], "[<f ]2[=]2[>]|2[<a]2[>][<o>]");
test_any([[
  object p = Parser.HTML();
  p->add_container ("t", lambda (object p, mapping a, string s)
			   {p->write_out("|"); return s;});
  p->add_tag ("t2", "2");
  p->_set_tag_callback (lambda (object p, string s)
			  {p->feed_insert(s[1..]); return ({s[..0]});});
  p->_set_data_callback (lambda (object p, string s)
			   {return ({"[",s,"]"});});
  return p->finish("<f <t2>=<t2>><t><t2><a<t2>></t><o>")->read();
]], "<[f ]2[=]2[>]|2<[a]2[>]<[o>]");
test_any([[
  object p = Parser.HTML();
  p->add_container ("t", lambda (object p, mapping a, string s)
			   {p->write_out("|"); return s;});
  p->add_tag ("t2", "2");
  p->ignore_unknown (1);
  p->_set_data_callback (lambda (object p, string s)
			   {return ({"[",s,"]"});});
  return p->finish("x<f x<t2>=<t2>x>x<t>x<t2>x<a<t2>x>x</t>x<o>x")->read();
]], "[x][<f x]2[=]2[x>x]|[x]2[x][<a]2[x>xx][<o>x]");
test_any([[
  object p = Parser.HTML();
  p->add_container ("t", lambda (object p, mapping a, string s)
			   {p->write_out("|"); return s;});
  p->add_tag ("t2", "2");
  p->_set_tag_callback (lambda (object p, string s)
			  {p->feed_insert(s[1..]); return ({s[..0]});});
  p->_set_data_callback (lambda (object p, string s)
			   {return ({"[",s,"]"});});
  return p->finish("x<f x<t2>=<t2>x>x<t>x<t2>x<a<t2>x>x</t>x<o>x")->read();
]], "[x]<[f x]2[=]2[x>x]|[x]2[x]<[a]2[x>xx]<[o>x]");
test_any([[
  object p = Parser.HTML();
  p->case_insensitive_tag (1);
  p->add_tag ("aA","[a]");
  p->add_container ("Bb","[b]");
  p->add_entity ("cC","[c]");
  return p->finish("<aa><AA><bb></Bb><BB></bB>&cc;&CC;")->read();
]], "[a][a][b][b]&cc;&CC;");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("aA","[a]");
  p->add_container ("Bb","[b]");
  p->add_entity ("cC","[c]");
  return p->finish("<aa><AA><bb></Bb><BB></bB>&cc;&CC;")->read();
]], "<aa><AA><bb></Bb><BB></bB>&cc;&CC;");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {
		     return ({"[",p->current(),"|",sort(indices(a))*",","]"});
		   });
  p->match_tag (0);
  return p->finish("<t bar <foo>>")->read();
  //                       ^ bogus char that we should jump over.
]], [["[<t bar <foo>|bar,foo]>"]]);
test_any([[{
  object p = Parser.HTML();
  p->add_tag ("t", "T");
  p->add_tag ("", "E");
  return p->finish("< t>")->read();
}]], "E");
test_any([[{
  object p = Parser.HTML();
  p->add_tag ("t", "T");
  p->add_tag ("", "E");
  p->ws_before_tag_name (1);
  return p->finish("< t>")->read();
}]], "T");
