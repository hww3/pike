// -*- Pike -*-

// Callback arguments and return values
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return "<t2>";});
  p->add_tag ("t2", "a");
  return p->finish("<t>")->read();
]], "a");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({"<t>"});});
  return p->finish("<t>")->read();
]], "<t>");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return "<t>";});
  if (catch {
    return p->finish("<t>")->read();
  }) return 1;
]], 1);
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", "<t>");
  if (catch {
    return p->finish("<t>")->read();
  }) return 1;
]], "<t>");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", "t");
  return p->finish("<t a=b c>")->read();
]], "t");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->finish("<t a>")->read();
]], "a");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({sort(indices(a))*","});});
  return p->finish("<t a=b 1=2>")->read();
]], [["1,a"]]);
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({sort(values(a))*","});});
  return p->finish("<t a=b 1=2>")->read();
]], [["2,b"]]);
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return p;});
  if (catch {
    return p->finish("<t>")->read();
  }) return 1;
]], 1);
test_any([[
  object p = Parser.HTML();
  p->add_entity ("e", lambda (object p) {return "<t>";});
  p->add_tag ("t", "a");
  return p->finish("&e;<x x =  &e;'&e;' &e;>&e;")->read();
]], "a<x x =  <t>'<t>' &e;>a");
test_any([[
  object p = Parser.HTML();
  p->splice_arg ("::");
  p->add_entity ("e", lambda (object p) {return "<t>";});
  p->add_tag ("t", "a");
  return p->finish("&e;<x x =  &e;'&e;' &e;>&e;")->read();
]], "a<x x =  <t>'<t>' &e;>a");
test_any([[
  object p = Parser.HTML();
  p->add_entity ("e", lambda (object p) {return ({"&e;"});});
  return p->finish("&e;<x x=&e;>")->read();
]], "&e;<x x=&e;>");
test_any([[
  object p = Parser.HTML();
  p->add_entity ("e", lambda (object p) {return "&e;";});
  if (catch {
    return p->finish("&e;")->read();
  }) return 1;
]], 1);
test_any([[
  object p = Parser.HTML();
  p->add_entity ("e", lambda (object p) {return "&e;";});
  if (catch {
    return p->finish("<x x=&e;>")->read();
  }) return 1;
]], 1);
test_any([[
  object p = Parser.HTML();
  p->add_entity ("e", "e");
  return p->finish("&e;<x x=&e;>")->read();
]], "e<x x=e>");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", "&e;");
  p->add_entity ("e", "<t>");
  if (catch {
    return p->finish("<t>&e;<x x  = &e;>")->read();
  }) return 1;
]], "&e;<t><x x  = <t>>");
test_any_equal([[
  object p = Parser.HTML();
  p->mixed_mode (1);
  p->add_tag ("t", ({lambda (object p, mixed... e) {return e;}, 17, (<>)}));
  p->add_container ("c", ({lambda (object p, mixed... e) {return e;}, ({}), 0, 0}));
  p->add_entity ("e", ({lambda (object p, mixed... e) {return e;}, "f"}));
  p->set_extra (4711);
  return p->finish("<t a><c>x</c>&e;<x x=&e;>")->read();
]], ({(["a": "a"]), 17, (<>), 4711,
      ([]), "x", ({}), 0, 0, 4711,
      "f", 4711, "<x x=", "f", 4711, ">"}));
test_any([[
  object p = Parser.HTML();
  p->_set_tag_callback (
    lambda (object p, string str) {
      p->add_container (p->tag_name(),
			lambda (object p, mapping a, string c) {
			  return ({"C(", p->tag_name(), "|", c, ")"});
			});
      return 1;
    });
  return p->finish ("<t>x</t>")->read();
]], "C(t|x)");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", "x");
  p->add_quote_tag ("!--",
		    lambda (object p, string s) {
		      return ({"[", s, "]"});
		    },
		    "--");
  p->add_quote_tag ("!-",
		    lambda (object p, string s) {
		      return ({"{", s, "}"});
		    },
		    "\'");
  return p->finish ("<t> <!-- <t a='> -- --> <!-<t a='> -->")->read();
]], "x [ <t a='> -- ] {<t a=} -->");
test_any([[{
  object p = Parser.HTML();
  p->add_entity ("e", "x");
  p->add_tag ("t", lambda (object p, mapping a)
		     {p->write_out ("[" + a->x + "]"); return 0;});
  return p->finish ("&e; <t x='&e;' &e;=&e;>")->read();
}]], "x [&e;]<t x='x' &e;=x>");
test_any([[{
  object p = Parser.HTML();
  p->splice_arg ("&e;");
  p->add_entity ("e", "x");
  p->add_tag ("t", lambda (object p, mapping a)
		     {p->write_out ("[" + a["&e;"] + "]"); return 0;});
  return p->finish ("&e; <t x='&e;' &e;=&e;>")->read();
}]], "x [&e;]<t x='x' x>");

// Current context functions
test_any([[{
  object p = Parser.HTML();
  p->lazy_entity_end (1);
  p->splice_arg ("::");
  p->add_tag (
    "t", lambda (object p, mapping a) {
	   return ({"T(", p->current(), "|", p->tag_name(), "|",
		    (string) p->tag_content(), "|", p->context(), ")"});
	 });
  p->add_container (
    "c", lambda (object p, mapping a, string c) {
	   return ({"C(", p->current(), "|", p->tag_name(), "|",
		    (string) p->tag_content(), "|", p->context(), ")"});
	 });
  p->add_entity (
    "e", lambda (object p) {
	   return ({"E(", p->current(), "|", p->tag_name(), "|",
		    (string) p->tag_content(), "|", p->context(), ")"});
	 });
  p->add_quote_tag (
    "q", lambda (object p, string c) {
	   return ({"Q(", p->current(), "|", p->tag_name(), "|",
		    (string) p->tag_content(), "|", p->context(), ")"});
	 }, "p");
  return p->finish ("<t a=&e; <t>> <q <\"' &e; p> "
		    "&e<c x=y -- >x</c> &e; "
		    "<x &e; q=&e;> <x q='&e;'> <x ::='&e;'>")->read();
}]], ("T(<t a=&e; <t>>|t|0|data) Q(<q <\"' &e; p>|q| <\"' &e; |data) "
      "&eC(<c x=y -- >x</c>|c|x|data) E(&e;|e|0|data) "
      "<x &e; q=E(&e;|e|0|arg)> <x q='E(&e;|e|0|')'> <x E(&e;|e|0|splice_arg)>"));
test_any([[{
  object p = Parser.HTML();
  p->lazy_entity_end (1);
  p->splice_arg ("::");
  p->_set_tag_callback (
    lambda (object p, string s) {
      return ({"T(", p->current(), "|", p->tag_name(), "|",
	       (string) p->tag_content(), "|", p->context(), ")"});
    });
  return p->finish ("<x &e; q=&f;> &g; "
		    "<x q='&h;'/> <x ::='&i;'>")->read();
}]], ("T(<x &e; q=&f;>|x|0|data) &g; "
      "T(<x q='&h;'/>|x|0|data) T(<x ::='&i;'>|x|0|data)"));
test_any([[{
  object p = Parser.HTML();
  p->lazy_entity_end (1);
  p->splice_arg ("::");
  p->_set_entity_callback (
    lambda (object p, string s) {
      return ({"E(", p->current(), "|", p->tag_name(), "|",
	       (string) p->tag_content(), "|", p->context(), ")"});
    });
  return p->finish ("<x &e; q=&f;> &g; "
		    "<x q='&h;'/> <x ::='&i;'>")->read();
}]], ("<x &e; q=E(&f;|f|0|arg)> E(&g;|g|0|data) "
      "<x q='E(&h;|h|0|')'/> <x E(&i;|i|0|splice_arg)>"));
test_any_equal([[
  object p = Parser.HTML();
  array a = ({ });
  p->_set_tag_callback (
    lambda (object p, string str) {
      a += ({ p->tag_name() });
      return 0;
    });
  p->finish("<t>x</t>");
  return a;
]], ({ "t", "/t" }));

// Argument quoting
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->finish("<t a=\"f'o\">")->read();
]], "f'o");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->finish("<t a='f\"o'>")->read();
]], "f\"o");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->finish("<t a=\"\\\">")->read();
]], "\\");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->finish("<t a='f'\"'\"'o'>")->read();
]], "f'o");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->finish("<t a=\"f\"'\"'\"o\">")->read();
]], "f\"o");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({"(", a->a, ")"});});
  return p->finish("<t a=f>oo>")->read();
]], "(f)oo>");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->finish("<t a=\"f'o><t>")->read();
]], "f'o><t>");
test_any([[{
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a)
		     {return ({a["b/a"]+"|"+a["/a"]+"|"+a["a/"]+"|"+a["a"]});});
  return p->finish("<t b/a> <t b /a> <t b a/> "
		   "<t b /a=fo> <t b a/=fo> <t b a=/fo> "
		   "<t b a=f/o> <t b a=fo/> <t b a='fo/'>")->read();
}]], ("b/a|0|0|0 0|/a|0|0 0|0|0|a "
      "0|fo|0|0 0|0|fo|0 0|0|0|/fo "
      "0|0|0|f/o 0|0|0|fo 0|0|0|fo/"));
test_any([[{
  object p = Parser.HTML();
  p->xml_tag_syntax (0);
  p->add_tag ("t", lambda (object p, mapping a)
		     {return ({a["b/a"]+"|"+a["/a"]+"|"+a["a/"]+"|"+a["a"]});});
  return p->finish("<t b/a> <t b /a> <t b a/> "
		   "<t b /a=fo> <t b a/=fo> <t b a=/fo> "
		   "<t b a=f/o> <t b a=fo/> <t b a='fo/'>")->read();
}]], ("b/a|0|0|0 0|/a|0|0 0|0|a/|0 "
      "0|fo|0|0 0|0|fo|0 0|0|0|/fo "
      "0|0|0|f/o 0|0|0|fo/ 0|0|0|fo/"));

// Local feeds
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a)
		     {p->feed_insert("<t2>"); return ({"<t3>"});});
  p->add_tags ((["t2": "2", "t3": "3"]));
  return p->finish("a<t>b<t>c")->read();
]], "a<t3>2b<t3>2c");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a)
		     {p->feed_insert("<t2>"); return "<t3>";});
  p->add_tags ((["t2": "2", "t3": "3"]));
  return p->finish("a<t>b<t>c")->read();
]], "a32b32c");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a)
		     {p->feed_insert("<t2>"); return "<t3>";});
  p->add_tag ("t2", lambda (object p, mapping a)
		      {p->feed_insert("A<t3>B"); return "2";});
  p->add_tag ("t3", "3");
  return p->finish("a<t>b<t>c")->read();
]], "a32A3Bb32A3Bc");
test_any([[
  object p = Parser.HTML();
  p->add_container ("t", lambda (object p, mapping a, string s)
			   {p->feed_insert("<t2>"); return s;});
  p->add_tags ((["t2": "2", "t3": "3"]));
  return p->finish("a<t>b<t3>c</t>d")->read();
]], "ab3c2d");

// Streaming
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->feed("<t a=1>2")->feed("<t a=3>")->read();
]], "123");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->feed("<t a=1>2")->read() + " " + p->feed("<t a=3>")->read();
]], "12 3");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->feed("<t a='f")->feed("oo'>")->read();
]], "foo");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->feed("<t a='f")->read() + " " + p->feed("oo'>")->read();
]], " foo");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->feed("<t a='f>")->read();
]], "");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->finish("<t a='f>")->read();
]], "f>");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return (p->feed("<")->feed("t")->feed(" ")->feed("a")->feed("=")->feed("'")->
	  feed("f")->feed("o")->feed("o")->feed("'")->feed(">")->read());
]], "foo");
test_any([[{
  object p = Parser.HTML();
  p->add_container ("c", lambda (object p, mapping a, string c)
			   {return ({"[", a->a, "|", c, "]"});});
  return (p->feed("<")->feed("c")->feed(" ")->feed("a")->feed("=")->feed("'")->
	  feed("f")->feed("o")->feed("o")->feed("'")->feed(">")->feed("x")->
	  feed("y")->feed("<")->feed("c")->feed(">")->feed("z")->feed("<")->
	  feed("t")->feed(">")->feed("<")->feed("/")->feed("c")->feed(">")->
	  feed("q")->feed("<")->feed("/")->feed("c")->feed(">")->feed(".")->read());
}]], "[foo|xy<c>z<t></c>q].");
test_any([[
  object p = Parser.HTML();
  p->add_entity ("e", lambda (object p) {return "e";});
  return p->feed("&e")->read() + " " + p->feed(";")->read();
]], " e");
test_any([[{
  object p = Parser.HTML();
  p->add_entity ("e", lambda (object p) {return "e";});
  return (p->feed("<x x=&e")->read() + " " +
	  p->feed(";")->read() + " " +
	  p->feed(">")->read());
}]], "<x x= e >");
test_any([[
  object p = Parser.HTML();
  p->add_quote_tag ("!--", lambda (object p, string s) {return ({s});}, "--");
  p->add_quote_tag ("!--[", lambda (object p, string s) {return ({s});}, "]--");
  p->add_quote_tag ("![", lambda (object p, string s) {return ({s});}, "]");
  return (p->feed("<!")->read() + " " +
	  p->feed("--")->read() + " " +
	  p->feed("x-->")->read());
]], "  x");
test_any([[
  object p = Parser.HTML();
  p->add_quote_tag ("!--", lambda (object p, string s) {return ({s});}, "--");
  p->add_quote_tag ("!--[", lambda (object p, string s) {return ({s});}, "]--");
  p->add_quote_tag ("![", lambda (object p, string s) {return ({s});}, "]");
  return (p->feed("<!")->read() + " " +
	  p->feed("--")->read() + " " +
	  p->feed("x--")->read() + " " +
	  p->feed("->")->read());
]], "   x-");
test_any([[{
  object p = Parser.HTML();
  p->add_quote_tag ("!--", lambda (object p, string s) {return ({"1",s});}, "--");
  p->add_quote_tag ("!--[", lambda (object p, string s) {return ({"2",s});}, "]-");
  p->add_quote_tag ("![", lambda (object p, string s) {return ({"3",s});}, "]");
  return (p->feed("<")->read() + "a" + p->feed("!")->read() + "b" +
	  p->feed("-")->read() + "c" + p->feed("-")->read() + "d" +
	  p->feed("X")->read() + "e" + p->feed("Y")->read() + "f" +
	  p->feed("]")->read() + "g" + p->feed(">")->read() + "h" +
	  p->feed("]")->read() + "i" + p->feed("-")->read() + "j" +
	  p->feed(">")->read() + "k" + p->feed("-")->read() + "l" +
	  p->feed("-")->read() + "m" + p->feed("-")->read() + "n" +
	  p->feed(">")->read());
}]], "abcdefghijklmn1XY]>]->-");

// Exception handling
test_any([[{
  object p = Parser.HTML();
  int t, c, e, q;
  p->splice_arg ("::");
  p->add_tag ("t", lambda (object p, mapping a) {
		     if (t++ < 3) {p->write_out ((string) t); throw (t);}
		     return ({"|", (string) t});
		   });
  p->add_container ("c", lambda (object p, mapping a, string s) {
			   if (c++ < 3) {p->write_out ((string) c); throw (c);}
			   return ({"|", (string) c});
			 });
  p->add_entity ("e", lambda (object p) {
			if (e++ < 3) {p->write_out ((string) e); throw (e);}
			array res = ({"|", (string) e});
			e = 0;
			return res;
		      });
  p->add_quote_tag ("q", lambda (object p, string s) {
			   if (q++ < 3) {p->write_out ((string) q); throw (q);}
			   return ({"|", (string) q});
			 },
		    "q");
  if (catch (p->finish ("<t> <c> <t> &e; </c> &e; <q &e; q> "
			"<x a=&e; &e; b='<t>&e;' ::='abc&e;def'>")))
    for (int i; i < 50; i++)
      if (!catch (p->finish())) break;
  return p->read();
}]], ("123|4 123|4 123|4 123|4 "
      "<x a=123|4 &e; b='<t>123|4' abc123|4def>"))

// Mixed mode
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({1});});
  return !!catch (p->finish("a<t>b")) + p->read();
]], "1a");
test_any_equal([[
  object p = Parser.HTML();
  p->mixed_mode (1);
  p->add_tag ("t", lambda (object p, mapping a) {p->write_out(1); return ({2});});
  return p->finish("a<t>b")->read();
]], ({"a",1,2,"b"}));
test_any_equal([[
  object p = Parser.HTML();
  p->mixed_mode (1);
  p->add_tag ("t", lambda (object p, mapping a) {return ({a});});
  return p->finish("<t a=b>")->read();
]], ({(["a": "b"])}));
test_any_equal([[{
  object p = Parser.HTML();
  p->mixed_mode (1);
  p->add_tag ("t", lambda (object p, mapping a) {return ({1});});
  p->feed ("a<t>b");
  return ({!!catch (p->mixed_mode (0))}) + p->read();
}]], ({1, "a", 1, "b"}));
test_any_equal([[{
  object p = Parser.HTML();
  p->mixed_mode (1);
  p->add_tag ("t", lambda (object p, mapping a) {return ({"x"});});
  p->feed ("a<")->feed ("t>")->feed ("b");
  return !!catch (p->mixed_mode (0)) + p->read();
}]], "0axb");

// Matching tags and quotes
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", "b");
  p->add_tag ("t>", "c");
  p->_set_tag_callback (lambda (object p, string s)
			  {p->feed_insert(s[1..]); return ({s[..0]});});
  return p->finish("<a href=\"<t\">")->read();
]], "<a href=\"c");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a)
		     {return ({"[",a->test,"]"});});
  return p->finish("<t test=\">")->read();
]], "[>]");
test_any([[
  object p = Parser.HTML();
  p->add_container ("c", lambda (object p, mapping a, string s)
			   {return ({"[",a->test,"|",s,"]"});});
  return p->finish("<c test=\">")->read();
]], "[>|]");
test_any_equal([[
  object p = Parser.HTML();
  p->match_tag (0);
  p->add_container ("c", lambda (object p, mapping a, string s)
			   {return ({"[",s,"]"});});
  return p->finish("<c></c </c>>")->read();
]], "[</c ]>");
test_any_equal([[
  object p = Parser.HTML();
  p->match_tag (0);
  p->add_container ("c", lambda (object p, mapping a, string s) {return ({s});});
  return p->finish("<c><</c>")->read();
]], "<");
test_any([[
  object p = Parser.HTML();
  p->add_container ("c", "C");
  return p->finish("<c> <!-- \" </c> --> </c> <c> <!-- \" --> </c> ")->read();
]], "C ");
test_any([[
  object p = Parser.HTML();
  p->ignore_unknown (1);
  p->add_container ("c", "C");
  return p->finish("<c> <!-- \" </c> --> </c> <c> <!-- \" --> </c> ")->read();
]], "C --> </c> C ");
test_any([[
  object p = Parser.HTML();
  p->add_quote_tag ("!--", ".", "--");
  p->add_container ("c", "C");
  return p->finish("<c> <!-- \" </c> --> </c> <c> <!-- \" --> </c> ")->read();
]], "C C ");
test_any_equal([[
  object p = Parser.HTML();
  p->mixed_mode (1);
  p->add_tag ("t", lambda (object p, mapping a) {return p->tag();});
  return p->finish("<t a b='b>")->read();
]], ({"t", (["a": "a", "b": "b>"]), 0}));
test_any_equal([[
  object p = Parser.HTML();
  p->mixed_mode (1);
  p->add_tag ("t", lambda (object p, mapping a) {return p->tag((<>));});
  return p->finish("<t a b='b>")->read();
]], ({"t", (["a": (<>), "b": "b>"]), 0}));
test_any([[{
  object p = Parser.HTML();
  p->_set_tag_callback (lambda (object p, string s) {return ({"[",s,"]"});});
  return p->finish ("<t <bar // > >xab")->read();
}]],"[<t <bar // > >]xab");
test_any([[{
  object p = Parser.HTML();
  p->_set_tag_callback (lambda (object p, string s) {return ({"[",s,"]"});});
  return p->finish ("<t <bar/>>xab")->read();
}]],"[<t <bar/>>]xab");
test_any([[{
  object p = Parser.HTML();
  p->_set_tag_callback (lambda (object p, string s) {return ({"[",s,"]"});});
  return p->finish ("<t </bar>/>xab")->read();
}]],"[<t </bar>/>]xab");
test_any([[{
  object p = Parser.HTML();
  p->add_container ("t", lambda (object p, mapping a, string s) {return ({"[",s,"]"});});
  return p->finish ("a<t>b<t/>c</t>d</t>e")->read();
}]], "a[b<t/>c</t>d]e");
test_any([[{
  object p = Parser.HTML();
  p->add_container ("t", lambda (object p, mapping a, string s) {return ({"[",s,"]"});});
  return p->finish ("a<t>b<t>c</t>d</t>e")->read();
}]], "a[b<t>c</t>d]e");
test_any([[{
  object p = Parser.HTML();
  p->ignore_unknown (1);
  p->match_tag (0);
  p->add_container ("c", "");
  p->add_tag ("X", "");
  p->add_container ("Y", "");
  p->add_tag ("/x", "");
  p->add_container ("/y", "");
  return p->finish ("1<c>-<a </c>-</c>-"
		    "2<c>-<X </c>-</c>-"
		    "3<c>-</X </c>-</c>-"
		    "4<c>-<//X </c>-</c>-"
		    "5<c>-<Y </c>-</c>-"
		    "6<c>-</Y </c>-</c>-"
		    "7<c>-<//Y </c>-</c>-"
		    "8<c>-<x </c>-</c>-"
		    "9<c>-</x </c>-</c>-"
		    "10<c>-<//x </c>-</c>-"
		    "11<c>-<y </c>-</c>-"
		    "12<c>-</y </c>-</c>-"
		    "13<c>-<//y </c>-</c>-"
		    "14<c>-<c </c>-</c>-</c>-")->read();
}]],               ("1-</c>-"
		    "2-"
		    "3-</c>-"
		    "4-</c>-"
		    "5-"
		    "6-"
		    "7-</c>-"
		    "8-</c>-"
		    "9-"
		    "10-</c>-"
		    "11-</c>-"
		    "12-"
		    "13-"
		    "14-"));
test_any([[{
  object p = Parser.HTML();
  p->match_tag (0);
  p->add_container ("foo", "");
  return p->finish ("<foo></foobar</foo>")->read();
}]], "");
test_any([[{
  object p = Parser.HTML();
  p->add_container ("foo", lambda (object p, mapping a, string s)
			     {return ({"[",s,"]"});});
  p->add_quote_tag ("?", "y", "?");
  return p->finish ("<foo><? sadf </foo>z")->read();
}]], "[<? sadf </foo>z]");
test_any([[{
  object p = Parser.HTML();
  p->add_container ("foo", lambda (object p, mapping a, string s)
			     {return ({"[",s,"]"});});
  p->add_quote_tag ("?", "y", "?");
  return p->finish ("<t><foo><? sadf </foo>z")->read();
}]], "<t>[<? sadf </foo>z]");

// Redefinition during parsing
test_any([[
  object p = Parser.HTML();
  p->add_tag ("a", lambda (object p, mapping a)
		     {p->add_tag ("b", "B"); return ({"A"});});
  return p->finish("<b><a><b>")->read();
]], "<b>AB");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("a", lambda (object p, mapping a)
		     {p->add_tag ("b", 0); return ({"A"});});
  p->add_tag ("b", "B");
  return p->finish("<b><a><b>")->read();
]], "BA<b>");

// Delimiters
test_any([[
  object p = Parser.HTML();
  p->lazy_entity_end (1);
  p->add_entity ("e", "x");
  return p->finish("&e; &e<t> &e <t> a='&e;&e' &e=f; b=\"&e\" &e>")->read();
]], "x &e<t> &e <t> a='x&e' &e=f; b=\"&e\" &e>");
test_any([[
  object p = Parser.HTML();
  p->add_entity ("e", "x");
  return p->finish("<t a='&e;&e' \"&e;'&e; >\" &e; >")->read();
]], "<t a='x&e' \"&e;'x >\" x >");
test_any([[
  object p = Parser.HTML();
  p->lazy_entity_end (1);
  p->add_entity ("e", "x");
  return p->finish("<t a='&e;&e' \"&e;'&e; >\" &e; >")->read();
]], "<t a='x&e' \"&e;'&e; >\" &e; >");
test_any([[
  object p = Parser.HTML();
  p->add_entity ("e", "x");
  return p->finish("<t a='&e;&e' \"&e;'&e; >\" &e; ")->read();
]], "<t a='x&e' \"&e;'x >\" x ");
test_any([[
  object p = Parser.HTML();
  p->lazy_entity_end (1);
  p->add_entity ("e", "x");
  return p->finish("<t a='&e;&e' \"&e;'&e; >\" &e; ")->read();
]], "<t a='x&e' \"&e;'&e; >\" &e; ");
test_any([[
  object p = Parser.HTML();
  p->lazy_entity_end (1);
  p->_set_entity_callback (lambda (object p, string s) {return ({"[",s,"]"});});
  return p->finish ("&abc|&abc<>&abc;<x x='&abc|&abc<>&abc;'>")->read();
]], "&abc|&abc<>[&abc;]<x x='&abc|&abc<>[&abc;]'>");
test_any([[
  object p = Parser.HTML();
  p->lazy_entity_end (1);
  p->_set_entity_callback (lambda (object p, string s) {return ({"[",s,"]"});});
  p->_set_data_callback (lambda (object p, string s) {return ({"{",s,"}"});});
  return p->finish ("&abc|&abc<>&abc;")->read();
]], "{&abc|}{&abc}<>[&abc;]{}");
test_any([[{
  object p = Parser.HTML();
  p->add_entity ("e", "x");
  return p->finish("&e")->read();
}]], "&e");
test_any([[{
  object p = Parser.HTML();
  p->lazy_entity_end (1);
  p->add_entity ("e", "x");
  return p->finish("&e")->read();
}]], "&e");
test_any([[{
  object p = Parser.HTML();
  p->add_entity ("e", "x");
  return p->finish("<x x=&e")->read();
}]], "<x x=&e");
test_any([[{
  object p = Parser.HTML();
  p->lazy_entity_end (1);
  p->add_entity ("e", "x");
  return p->finish("<x x=&e")->read();
}]], "<x x=&e");
test_any([[
  object p = Parser.HTML();
  p->add_entity ("e", "x");
  return p->finish("<t &e; a=\"&f&e;'&e&e;o\">")->read();
]], "<t &e; a=\"&f&e;'&e&e;o\">");
test_any([[
  object p = Parser.HTML();
  p->lazy_entity_end (1);
  p->add_entity ("e", "x");
  return p->finish("<t &e; a=\"&f&e;'&e&e;o\">")->read();
]], "<t &e; a=\"&fx'&exo\">");
test_any([[
  object p = Parser.HTML();
  p->add_entity ("e", "x");
  return p->finish("<t a=&e;'f\"o' &e>")->read();
]], "<t a=x'f\"o' &e>");
test_any([[
  object p = Parser.HTML();
  p->add_entity ("e", "x");
  return p->finish("<t a='f\"o'&e/>")->read();
]], "<t a='f\"o'&e/>");
test_any([[
  object p = Parser.HTML();
  p->add_entity ("e", "x");
  return p->finish("<t a='f\"o'&e;>")->read();
]], "<t a='f\"o'x>");
test_any([[
  object p = Parser.HTML();
  p->add_entity ("e", "x");
  return p->finish("<t a='f\"o'&e;/>")->read();
]], "<t a='f\"o'x/>");
test_any([[
  object p = Parser.HTML();
  p->add_entity ("e", "x");
  return p->finish("<t a=&e;'f\"o' &e>")->read();
]], "<t a=x'f\"o' &e>");
test_any([[
  object p = Parser.HTML();
  p->add_entity ("e", "x");
  return p->finish("<t a='&e;'\"&e;\"&e;>")->read();
]], "<t a='x'\"x\"x>");
test_any([[
  object p = Parser.HTML();
  p->add_entity ("e", "x");
  return p->finish("<t a='&e;'\" &e;\"&e;>")->read();
]], "<t a='x'\" x\"x>");
test_any([[
  object p = Parser.HTML();
  p->add_entity ("e", "x");
  return p->finish("<t a='&e;'\"&e;\" &e;>")->read();
]], "<t a='x'\"x\" &e;>");
test_any([[
  object p = Parser.HTML();
  p->add_entity ("e", "x");
  return p->finish("<t a='&e;'\"&e ;\"&e;>")->read();
]], "<t a='x'\"&e ;\"x>");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", "T");
  p->add_entity ("e", lambda (object p, string c) {return "'> &f; <t y='";});
  p->add_entity ("f", "foo");
  return p->finish("<x a='&e;'>")->read();
]], "<x a=''> foo <t y=''>");

// Splice argument
test_any([[{
  object p = Parser.HTML();
  p->splice_arg ("::");
  p->add_entity ("e", "x");
  return p->finish ("<x ::  = \"foo bar='gnu' &e;\"&e; a='&e;' &e;:: "
		    "::=&e; :::=\"&e;y\" ::  ::  =  ''&e;\"\" :/: ::/>")->read();
}]], "<x foo bar='gnu' xx a='x' &e;:: x :::=\"xy\"   x :/: />");
test_any([[{
  object p = Parser.HTML();
  p->xml_tag_syntax (0);
  p->splice_arg ("::");
  p->add_entity ("e", "x");
  return p->finish ("<x ::  = \"foo bar='gnu' &e;\"&e; a='&e;' &e;:: "
		    "::=&e; :::=\"&e;y\" ::  ::  =  ''&e;\"\" :/: ::/>")->read();
}]], "<x foo bar='gnu' xx a='x' &e;:: x :::=\"xy\"   x :/: ::/>");
test_any([[{
  object p = Parser.HTML();
  p->splice_arg (":/:");
  p->add_entity ("e", "x");
  return p->finish ("<x/x /::  = &e; :/: =&e; ::/= &e;>")->read();
}]], "<x/x /::  = x x ::/= x>");
test_any([[{
  object p = Parser.HTML();
  p->splice_arg ("::");
  p->add_entity ("e", "x");
  return p->finish ("<x/x /::  = &e; :/: =&e; ::/= &e;>")->read();
}]], "<x/x /::  = x :/: =x ::/= x>");

// Recursive parsing in tags
test_any([[
  object p = Parser.HTML();
  p->add_entity ("e", "e");
  p->add_tag ("t", lambda (object p, mapping a) {return ({sort(values(a))*","});});
  return p->finish("<t a=\"&e;\">")->read();
]], "&e;");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", "b");
  return p->finish("<!-- <t> -->")->read();
]], "<!-- <t> -->");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", "b");
  p->ignore_unknown (1);
  return p->finish("<!-- <t> -->")->read();
]], "<!-- b -->");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", "b");
  return p->finish("<a href=\"<t>\">")->read();
]], "<a href=\"<t>\">");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", "b");
  p->ignore_unknown (1);
  return p->finish("<a href=\"<t>\">")->read();
]], "<a href=\"b\">");

// XML syntax
test_any([[{
  object p = Parser.HTML();
  p->add_tag ("t", "()");
  p->add_container ("c", lambda (object p, mapping a, string s) {return ({"[",s,"]"});});
  return p->finish ("a<t>b</t>c<c>d</c>e<t/>f</t>g<c/>h</c>i")->read();
}]], "a()b</t>c[d]e()f</t>g[h]i");
test_any([[{
  object p = Parser.HTML();
  p->add_tag ("t", "()");
  p->add_container ("c", lambda (object p, mapping a, string s) {return ({"[",s,"]"});});
  p->xml_tag_syntax (2);
  return p->finish ("a<t>b</t>c<c>d</c>e<t/>f</t>g<c/>h</c>i")->read();
}]], "a()b</t>c[d]e()f</t>g[]h</c>i");
test_any([[{
  object p = Parser.HTML();
  p->add_tag ("t", "()");
  p->add_container ("c", lambda (object p, mapping a, string s) {return ({"[",s,"]"});});
  p->xml_tag_syntax (3);
  return p->finish ("a<t>b</t>c<c>d</c>e<t/>f</t>g<c/>h</c>i")->read();
}]], "a()c[d]e()f</t>g[]h</c>i");
test_any([[{
  object p = Parser.HTML();
  p->add_tag ("t", "()");
  return p->finish ("a<t>b</t>c<t/>d</t>e")->read();
}]], "a()b</t>c()d</t>e");
test_any([[{
  object p = Parser.HTML();
  p->add_container ("t", lambda (object p, mapping a, string s) {return ({"[",s,"]"});});
  return p->finish ("a<t>b</t>c<t/>d</t>e")->read();
}]], "a[b]c[d]e");
test_any([[{
  object p = Parser.HTML();
  p->add_tag ("t", "()");
  p->add_container ("t", lambda (object p, mapping a, string s) {return ({"[",s,"]"});});
  return p->finish ("a<t>b</t>c<t/>d</t>e")->read();
}]], "a()b</t>c()d</t>e");
test_any([[{
  object p = Parser.HTML();
  p->add_tag ("t", "()");
  p->xml_tag_syntax (2);
  return p->finish ("a<t>b</t>c<t/>d</t>e")->read();
}]], "a()b</t>c()d</t>e");
test_any([[{
  object p = Parser.HTML();
  p->add_container ("t", lambda (object p, mapping a, string s) {return ({"[",s,"]"});});
  p->xml_tag_syntax (2);
  return p->finish ("a<t>b</t>c<t/>d</t>e")->read();
}]], "a[b]c[]d</t>e");
test_any([[{
  object p = Parser.HTML();
  p->add_tag ("t", "()");
  p->add_container ("t", lambda (object p, mapping a, string s) {return ({"[",s,"]"});});
  p->xml_tag_syntax (2);
  return p->finish ("a<t>b</t>c<t/>d</t>e")->read();
}]], "a[b]c()d</t>e");
test_any([[{
  object p = Parser.HTML();
  p->add_tag ("t", "()");
  p->xml_tag_syntax (3);
  return p->finish ("a<t>b</t>c<t/>d</t>e")->read();
}]], "a()c()d</t>e");
test_any([[{
  object p = Parser.HTML();
  p->add_container ("t", lambda (object p, mapping a, string s) {return ({"[",s,"]"});});
  p->xml_tag_syntax (3);
  return p->finish ("a<t>b</t>c<t/>d</t>e")->read();
}]], "a[b]c[]d</t>e");
test_any([[{
  object p = Parser.HTML();
  p->add_tag ("t", "()");
  p->add_container ("t", lambda (object p, mapping a, string s) {return ({"[",s,"]"});});
  p->xml_tag_syntax (3);
  return p->finish ("a<t>b</t>c<t/>d</t>e")->read();
}]], "a[b]c()d</t>e");
test_any([[{
  object p = Parser.HTML();
  p->add_container ("t", lambda (object p, mapping a, string s) {return ({"[",s,"]"});});
  p->xml_tag_syntax (3);
  return p->finish ("a<t>b<t/>c</t>d</t>e")->read();
}]], "a[b<t/>c]d</t>e");
test_any([[{
  object p = Parser.HTML();
  p->add_container ("t", lambda (object p, mapping a, string s) {return ({"[",s,"]"});});
  p->xml_tag_syntax (3);
  return p->finish ("a<t>b<t>c</t>d</t>e")->read();
}]], "a[b<t>c</t>d]e");
test_any([[{
  object p = Parser.HTML();
  p->add_container ("t", lambda (object p, mapping a, string s) {return ({"[",s,"]"});});
  p->xml_tag_syntax (3);
  return p->finish ("a<t>b<x/>c</t>d</t>e")->read();
}]], "a[b<x/>c]d</t>e");
test_any([[{
  object p = Parser.HTML();
  p->add_container ("t", lambda (object p, mapping a, string s) {return ({"[",s,"]"});});
  p->xml_tag_syntax (3);
  return p->finish ("a<t>b<x>c</x>d</t>e")->read();
}]], "a[b<x>c</x>d]e");
test_any([[{
  object p = Parser.HTML();
  p->add_container ("t", lambda (object p, mapping a, string s) {return ({"[",s,"]"});});
  p->xml_tag_syntax (3);
  return p->finish ("a<t>b<x>c</t>d</t>e")->read();
}]], "a[b<x>c]d</t>e");

// parse_tag_args
test_equal(Parser.HTML()->parse_tag_args("<"), ([]));
test_equal(Parser.HTML()->parse_tag_args(">"), ([]));
test_equal(Parser.HTML()->parse_tag_args("br"), (["br": "br"]));
test_equal(Parser.HTML()->parse_tag_args("<br>"), (["br": "br"]));
test_equal(Parser.HTML()->parse_tag_args("<br/>"), (["br/": "br/"]));

// Misc
test_any([[
  object p = Parser.HTML();
  p->add_container ("t", lambda (object p, mapping a, string s)
			   {p->write_out("|"); return s;});
  p->add_tag ("t2", "2");
  p->ignore_unknown (1);
  p->_set_data_callback (lambda (object p, string s)
			   {return ({"[",s,"]"});});
  return p->finish("<f <t2>=<t2>><t><t2><a<t2>></t><o>")->read();
]], "[<f ]2[=]2[>]|2[<a]2[>][<o>]");
test_any([[
  object p = Parser.HTML();
  p->add_container ("t", lambda (object p, mapping a, string s)
			   {p->write_out("|"); return s;});
  p->add_tag ("t2", "2");
  p->_set_tag_callback (lambda (object p, string s)
			  {p->feed_insert(s[1..]); return ({s[..0]});});
  p->_set_data_callback (lambda (object p, string s)
			   {return ({"[",s,"]"});});
  return p->finish("<f <t2>=<t2>><t><t2><a<t2>></t><o>")->read();
]], "<[f ]2[=]2[>]|2<[a]2[>]<[o>]");
test_any([[
  object p = Parser.HTML();
  p->add_container ("t", lambda (object p, mapping a, string s)
			   {p->write_out("|"); return s;});
  p->add_tag ("t2", "2");
  p->ignore_unknown (1);
  p->_set_data_callback (lambda (object p, string s)
			   {return ({"[",s,"]"});});
  return p->finish("x<f x<t2>=<t2>x>x<t>x<t2>x<a<t2>x>x</t>x<o>x")->read();
]], "[x][<f x]2[=]2[x>x]|[x]2[x][<a]2[x>xx][<o>x]");
test_any([[
  object p = Parser.HTML();
  p->add_container ("t", lambda (object p, mapping a, string s)
			   {p->write_out("|"); return s;});
  p->add_tag ("t2", "2");
  p->_set_tag_callback (lambda (object p, string s)
			  {p->feed_insert(s[1..]); return ({s[..0]});});
  p->_set_data_callback (lambda (object p, string s)
			   {return ({"[",s,"]"});});
  return p->finish("x<f x<t2>=<t2>x>x<t>x<t2>x<a<t2>x>x</t>x<o>x")->read();
]], "[x]<[f x]2[=]2[x>x]|[x]2[x]<[a]2[x>xx]<[o>x]");
test_any([[
  object p = Parser.HTML();
  p->case_insensitive_tag (1);
  p->add_tag ("aA","[a]");
  p->add_container ("Bb","[b]");
  p->add_entity ("cC","[c]");
  return p->finish("<aa><AA><bb></Bb><BB></bB>&cc;&CC;")->read();
]], "[a][a][b][b]&cc;&CC;");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("aA","[a]");
  p->add_container ("Bb","[b]");
  p->add_entity ("cC","[c]");
  return p->finish("<aa><AA><bb></Bb><BB></bB>&cc;&CC;")->read();
]], "<aa><AA><bb></Bb><BB></bB>&cc;&CC;");
test_any([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {
		     return ({"[",p->current(),"|",sort(indices(a))*",","]"});
		   });
  p->match_tag (0);
  return p->finish("<t bar <foo>>")->read();
  //                       ^ bogus char that we should jump over.
]], [["[<t bar <foo>|bar,foo]>"]]);
test_any([[{
  object p = Parser.HTML();
  p->add_tag ("t", "T");
  p->add_tag ("", "E");
  return p->finish("< t>")->read();
}]], "E");
test_any([[{
  object p = Parser.HTML();
  p->add_tag ("t", "T");
  p->add_tag ("", "E");
  p->ws_before_tag_name (1);
  return p->finish("< t>")->read();
}]], "T");
test_any([[{
  object p = Parser.HTML();
  p->add_tag ("/t", "T");
  return p->finish("</t>")->read();
}]], "T");
test_any([[{
  object p = Parser.HTML();
  p->add_tag ("t", "T");
  p->add_container ("c", "C");
  p->add_entity ("e", "E");
  p->ignore_tags (1);
  return p->finish("<t &e;><&e;><c>&e;</c><t>")->read();
}]], "<t E><E><c>E</c><t>");
test_any([[{
  object p = Parser.HTML();
  p->add_tag ("t", "T");
  p->add_container ("c", "C");
  p->add_entity ("e", "E");
  p->ignore_tags (1);
  return p->clone()->finish("<t &e;><&e;><c>&e;</c><t>")->read();
}]], "<t E><E><c>E</c><t>");
test_any([[{
  return
    Parser.HTML()->
    add_quote_tag("?", lambda() {}, "?")->
    feed("<? ? >")->
    finish()->read();
}]], "<? ? >");
test_any([[{
  object p = Parser.HTML();
  p->_set_tag_callback (lambda () {return "T";});
  p->add_quote_tag ("?", "X", "?");
  return p->finish ("<")->read();
}]], "T");
test_any([[{
  object p = Parser.HTML();
  p->_set_data_callback (lambda () {});
  return p->finish ("<x>")->read();
}]], "<x>");
test_any([[{
  object p = Parser.HTML();
  p->feed("foo");
  return p->read(0) + " " + p->read(1) + " " + p->read(2) + " " + p->read(3);
}]], " f oo ");
test_any([[{
  object p = Parser.HTML();
  p->feed("f")->feed("o")->feed("")->feed("o");
  return p->read(0) + " " + p->read(1) + " " + p->read(2) + " " + p->read(3);
}]], " f oo ");
