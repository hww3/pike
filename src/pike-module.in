#!¤pike¤

// Source directory
string srcdir;
string pike="¤pike¤";
string prefix="¤prefix¤";
string lib_prefix="¤lib_prefix¤";
string share_prefix="¤share_prefix¤";
string make="¤make¤";
string make_flags="¤make_flags¤";
string include_path="¤include_path¤";
string configure_command="configure";


#define NOT 0
#define AUTO 1
#define ALWAYS 2

mapping(string:int) run=
([
  "automake":AUTO,
  "autoheader":AUTO,
  "autoconf":AUTO,
  "configure":AUTO,
  "depend":AUTO,
  "make":AUTO,
  ]);

string fix(string path)
{
  if(search(path,"$src")==-1) return path;
  if(!srcdir)
  {
    string s=Stdio.read_file("Makefile");
    if(s)
    {
      sscanf(s,"%*s\nSRCDIR=%s\n",srcdir);
    }
    if(!srcdir && file_stat("configure.in"))
    {
      srcdir=".";
    }
    
    if(!srcdir)
    {
      werror("You must provide --source=<source dir>\n");
      exit(1);
    }
  }
  return replace(path,"$src",srcdir);
}

void do_zero()
{
  foreach(indices(run), string x) if(run[x]==1) m_delete(run,x);
}

int max_time_of_files(string ... a)
{
  int t=0;
  foreach(a,string file)
    {
      mixed s=file_stat(fix(file));
      if(!s) return 0;
      t=max(t,s[3]);
    }
  return t;
}


int just_run(mapping options, string ... cmd)
{
  werror(" %s\n",cmd*" ");
  return Process.create_process(cmd,options)->wait();
}

void run_or_fail(mapping options,string ... cmd)
{
  werror(" %s\n",cmd*" ");
  int ret=Process.create_process(cmd,options)->wait();
  if(ret)
    exit(ret);
}


void do_make(string *cmd)
{
  int tmp1;
  string *makecmd=(
    ({make})+
    Process.split_quoted_string(make_flags)-({""})+
    ({"PIKE_INCLUDES=-I"+include_path,
      "PIKE_SRC_DIR="+include_path,
      "BUILD_BASE="+include_path,
      "MODULE_BASE="+include_path,
    })+
    cmd);

  if(tmp1=max_time_of_files("Makefile"))
  {
    rm("remake");
    tmp1=just_run(([]),@makecmd);
    if(tmp1)
    {
      if(max_time_of_files("remake"))
      {
	run_or_fail(([]),@makecmd);
      }else{
	exit(tmp1);
      }
    }
  }else{
    werror("No Makefile.\n");
  }
}

int main(int argc, string *argv)
{
  foreach(Getopt.find_all_options(argv,aggregate(
    ({"fixate",Getopt.NO_ARG,({"--fixate"}) }),
    ({"set",Getopt.NO_ARG,({"--set"}) }),
    ({"output",Getopt.NO_ARG,({"--output"}) }),
    ({"autoconf",Getopt.NO_ARG,({"--autoconf"}) }),
    ({"configure",Getopt.NO_ARG,({"--configure"}) }),
    ({"autoheader",Getopt.NO_ARG,({"--autoheader"}) }),
    ({"automake",Getopt.NO_ARG,({"--automake"}) }),
    ({"depend",Getopt.HAS_ARG,({"--depend"}) }),
    ({"all",Getopt.NO_ARG,({"--all"}) }),
    ({"make",Getopt.NO_ARG,({"--make"}) }),
    ({"auto",Getopt.NO_ARG,({"--auto"}) }),
    ({"source",Getopt.HAS_ARG,({"--source"}) }),
    ({"query",Getopt.HAS_ARG,({"--query"}) }),
    )),array opt)
    {
      switch(opt[0])
      {
	case "query":
	  write("%s\n",this_object()[opt[1]]);
	  exit(0);

	case "fixate":
	  string file=Stdio.read_file(opt[1]);
	  break;
	case "set":
	  if(sscanf(opt[1],"%s=%s",string var, string value))
	  {
	    file=replace(file,"¤"+var+"¤",
			 replace(value,"\"","\\\""));
	  }
	  break;
	  
	case "output":
	  rm(opt[1]);
	  Stdio.write_file(opt[1],file);
	  exit(0);
	  
	case "source": srcdir=opt[1]; break;
	case "automake": run->automake=ALWAYS; do_zero(); break;
	case "autoheader": run->autoheader=ALWAYS; do_zero(); break;
	case "autoconf": run->autoconf=ALWAYS; do_zero(); break;
	case "configure": run->configure=ALWAYS; do_zero(); break;
	case "make": run->make=ALWAYS; do_zero(); break;
	case "depend": run->depend=ALWAYS; do_zero(); break;
	  
	case "all": 
	  run->depend=run->autoheader=run->autoconf=run->configure=run->make=ALWAYS;
	  break;
	  
	case "auto":
	  run->depend=run->autoheader=run->autoconf=run->configure=run->make=1;
	  break;
      }
    }

  argv=Getopt.get_args(argv);
  
  int tmp1;
  if(run->automake)
  {
    if(tmp1=max_time_of_files("$src/Makefile.am","$src/configure.in"))
    {
      if(run->automake == ALWAYS ||
	 max_time_of_files("$src/Makefile.in") < tmp1)
      {
	run_or_fail((["dir":srcdir]),"aclocal");
	run_or_fail((["dir":srcdir]),"automake");
	rm(fix("$src/stamp-h.in"));
      }
    }
  }

  if(run->autoheader)
  {
    if(tmp1=max_time_of_files("$src/acconfig.h","$src/configure.in"))
    {
      if(run->autoheader==ALWAYS ||
	 max_time_of_files("$src/stamp-h.in") <= tmp1)
      {
	run_or_fail((["dir":srcdir]),"autoheader");
	rm(fix("$src/stamp-h.in"));
	Stdio.write_file(fix("$src/stamp-h.in"),"foo\n");
      }
    }
  }

  if(run->autoconf)
  {
    if(tmp1=max_time_of_files("$src/configure.in"))
    {
      if(run->autoconf==ALWAYS ||
	 max_time_of_files("$src/configure") <= tmp1)
      {
	run_or_fail((["dir":srcdir]),"autoconf","--localdir="+include_path);
      }
    }
  }

  if(run->configure)
  {
    // If there is a makefile, we can use the auto-run-configure
    // feature...
    if(run->configure == ALWAYS || !max_time_of_files("Makefile"))
    {
      if(max_time_of_files("$src/configure"))
      {
	if(!max_time_of_files("config.cache") &&
	   max_time_of_files(include_path+"/config.cache"))
	{
	  Stdio.cp(include_path+"/config.cache","config.cache");
	}
	run_or_fail(([]),srcdir+"/"+configure_command);
      }
    }
  }

  if(run->depend)
  {
    if(run->depend == ALWAYS || !max_time_of_files("$src/dependencies"))
    {
      // Create an empty file first..
      Stdio.write_file(srcdir+"/dependencies","");
      do_make( ({"depend"}) );
      do_make( ({"Makefile"}) );
    }
  }

  if(run->make)
  {
    do_make(argv[1..]);
  }
}
