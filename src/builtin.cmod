/* -*- c -*-
 * $Id: builtin.cmod,v 1.39 2001/06/19 21:41:01 grubba Exp $
 */

#include "global.h"
#include "interpret.h"
#include "svalue.h"
#include "opcodes.h"
#include "pike_macros.h"
#include "object.h"
#include "program.h"
#include "array.h"
#include "pike_error.h"
#include "constants.h"
#include "mapping.h"
#include "stralloc.h"
#include "multiset.h"
#include "pike_types.h"
#include "pike_memory.h"
#include "threads.h"
#include <math.h>
#include <ctype.h>
#include "module_support.h"
#include "cyclic.h"
#include "bignum.h"
#include "main.h"
#include "operators.h"
#include "builtin_functions.h"

/*! @decl array column(array data, mixed index)
 *!
 *! Extract a column from a two-dimensional array.
 *!
 *! This function is exactly equivalent to:
 *! @code{map(@[data], lambda(mixed x,mixed y) { return x[y]; }, @[index])@}
 *!
 *! Except of course it is a lot shorter and faster.
 *! That is, it indices every index in the array data on the value of
 *! the argument index and returns an array with the results.
 *!
 *! @seealso
 *! @[rows()]
 */
PIKEFUN array column(array data, mixed index)
  efun;
  optflags OPT_TRY_OPTIMIZE;
{
  INT32 e;
  struct array *a;

  DECLARE_CYCLIC();

  /* Optimization */
  if(data->refs == 1)
  {
    /* An array with one ref cannot possibly be cyclic */
    struct svalue sval;
    data->type_field = BIT_MIXED | BIT_UNFINISHED;
    for(e=0;e<data->size;e++)
    {
      index_no_free(&sval, ITEM(data)+e, index);
      free_svalue(ITEM(data)+e);
      ITEM(data)[e]=sval;
    }
    pop_stack();
    return;
  }

  if((a=(struct array *)BEGIN_CYCLIC(data,0)))
  {
    add_ref(a);
  }else{
    push_array(a=allocate_array(data->size));
    SET_CYCLIC_RET(a);

    for(e=0;e<a->size;e++)
      index_no_free(ITEM(a)+e, ITEM(data)+e, index);

    sp--;
  }
  END_CYCLIC();
  RETURN a;
}

/*! @decl multiset mkmultiset(array a)
 *!
 *! This function creates a multiset from an array.
 *!
 *! @seealso
 *! @[aggregate_multiset()]
 *!
 */
PIKEFUN multiset(1) mkmultiset(array(1=mixed) a)
  efun;
  optflags OPT_TRY_OPTIMIZE|OPT_EXTERNAL_DEPEND;
{
  RETURN mkmultiset(a);
}

/*! @decl int trace(int t)
 *!
 *! This function changes the debug trace level.
 *!
 *! The old level is returned.
 *!
 *! Trace level 1 or higher means that calls to Pike functions are
 *! printed to stderr, level 2 or higher means calls to builtin functions
 *! are printed, 3 means every opcode interpreted is printed, 4 means
 *! arguments to these opcodes are printed as well.
 *!
 *! See the @tt{-t@} command-line option for more information.
 */
PIKEFUN int trace(int t)
  efun;
  optflags OPT_SIDE_EFFECT;
{
  pop_n_elems(args);
  push_int(t_flag);
  t_flag=t;
}

/*! @decl string ctime(int timestamp)
 *!
 *! Convert the output from a previous call to @[time()] into a readable
 *! string containing the current year, month, day and time.
 *!
 *! @seealso
 *! @[time()], @[localtime()], @[mktime()], @[gmtime()]
 */
PIKEFUN string ctime(int timestamp)
  efun;
  optflags OPT_TRY_OPTIMIZE;
{
  time_t i=(time_t)timestamp;
  RETURN make_shared_string(ctime(&i));
}

/*! @decl mapping mkmapping(array ind, array val)
 *!
 *! Make a mapping from two arrays.
 *!
 *! Makes a mapping @[ind[x]]:@[val[x]], @tt{0 <= x < sizeof(ind)@}.
 *!
 *! @[ind] and @[val] must have the same size.
 *!
 *! This is the inverse operation of @[indices()] and @[values()].
 *!
 *! @seealso
 *! @[indices()], @[values()]
 */
PIKEFUN mapping(1:2) mkmapping(array(1=mixed) ind, array(2=mixed) val)
  efun;
  optflags OPT_TRY_OPTIMIZE|OPT_EXTERNAL_DEPEND;
{
  if(ind->size != val->size)
    bad_arg_error("mkmapping", sp-args, args, 2, "array", sp+1-args,
		  "mkmapping called on arrays of different sizes (%d != %d)\n",
		  ind->size, val->size);

  RETURN mkmapping(ind, val);
}

/*! @decl int String.count(string haystack, string needle)
 *!
 *! Count the number of non-overlapping times the string @[needle] occurrs
 *! in the string @[haystack].
 *!
 *! @seealso
 *! @[search()], @[`/()]
 */
PIKEFUN int string_count(string haystack, string needle)
  errname String.count;
  optflags OPT_TRY_OPTIMIZE;
{
   ptrdiff_t c = 0;
   ptrdiff_t i, j;

   switch (needle->len)
   {
     case 0:
       switch (haystack->len)
       {
	 case 0: c=1; break; /* "" appears one time in "" */
	 case 1: c=0; break; /* "" doesn't appear in "x" */
	 default: c=haystack->len-1; /* one time between each character */
       }
       break;
     case 1:
       /* maybe optimize? */
     default:
       for (i=0; i<haystack->len; i++)
       {
	 j=string_search(haystack,needle,i);
	 if (j==-1) break;
	 i=j+needle->len-1;
	 c++;
       }
       break;
   }
   RETURN DO_NOT_WARN((INT_TYPE)c);
}

/*! @decl string String.trim_whites (string s)
 *!
 *! Trim leading and trailing spaces and tabs from the string @[s].
 */
PIKEFUN string string_trim_whites (string s)
  errname String.trim_whites;
  optflags OPT_TRY_OPTIMIZE;
{
  ptrdiff_t start = 0, end = s->len;
  int chr;
  switch (s->size_shift) {
#define DO_IT(TYPE)							\
    {									\
      for (; start < s->len; start++) {					\
	chr = ((TYPE *) s->str)[start];					\
	if (chr != ' ' && chr != '\t') break;				\
      }									\
      while (--end > start) {						\
	chr = ((TYPE *) s->str)[end];					\
	if (chr != ' ' && chr != '\t') break;				\
      }									\
    }
    case 0: DO_IT (p_wchar0); break;
    case 1: DO_IT (p_wchar1); break;
    case 2: DO_IT (p_wchar2); break;
#undef DO_IT
  }
  RETURN string_slice (s, start, end + 1 - start);
}

/*! @decl string String.trim_all_whites (string s)
 *!
 *! Trim leading and trailing white spaces characters (space, tab,
 *! newline and carriage return) from the string @[s].
 */
PIKEFUN string string_trim_all_whites (string s)
  errname String.trim_all_whites;
  optflags OPT_TRY_OPTIMIZE;
{
  ptrdiff_t start = 0, end = s->len;
  int chr;
  switch (s->size_shift) {
#define DO_IT(TYPE)							\
    {									\
      for (; start < s->len; start++) {					\
	chr = ((TYPE *) s->str)[start];					\
	if (chr != ' ' && chr != '\t' && chr != '\n' && chr != '\r')	\
	  break;							\
      }									\
      while (--end > start) {						\
	chr = ((TYPE *) s->str)[end];					\
	if (chr != ' ' && chr != '\t' && chr != '\n' && chr != '\r')	\
	  break;							\
      }									\
    }
    case 0: DO_IT (p_wchar0); break;
    case 1: DO_IT (p_wchar1); break;
    case 2: DO_IT (p_wchar2); break;
#undef DO_IT
  }
  RETURN string_slice (s, start, end + 1 - start);
}

/*! @decl int program_implements(program prog, program api)
 *!
 *! Returns 1 if @[prog] implements @[api].
 */
PIKEFUN int program_implements(program prog, program api)
  errname Program.implements;
  optflags OPT_TRY_OPTIMIZE;
{
  RETURN implements(prog, api);
}

/*! @decl int program_inherits(program child, program parent)
 *!
 *! Returns 1 if @[child] has inherited @[parent].
 */
PIKEFUN int program_inherits(program parent, program child)
  errname Program.inherits;
  optflags OPT_TRY_OPTIMIZE;
{
  RETURN low_get_storage(parent, child) != -1;
}

/*! @decl string program_defined(program p)
 *!
 *! Returns a string with filename and linenumber describing where
 *! the program @[p] was defined.
 *!
 *! The returned string is of the format @tt{"@i{filename@}:@i{linenumber@}"@}.
 *!
 *! If it cannot be determined where the program was defined, @tt{0@} (zero)
 *! will be returned.
 */
PIKEFUN string program_defined(program p)
  errname Program.defined;
  optflags OPT_TRY_OPTIMIZE;
{
  if(p && p->num_linenumbers)
  {
    char *tmp;
    INT32 line;
    if((tmp=get_line(p->program, p, &line)))
    {
      struct pike_string *tmp2;
      tmp2=make_shared_string(tmp);
      pop_n_elems(args);

      push_string(tmp2);
      if(line > 1)
      {
	push_constant_text(":");
	push_int(line);
	f_add(3);
      }
      return;
    }
  }

  pop_n_elems(args);
  push_int(0);
}

/*! @decl int(8..8)|int(16..16)|int(32..32) String.width(string s)
 *!
 *! Returns the width of a string.
 *!
 *! Three return values are possible:
 *! @int
 *!   @value 8
 *!     The string @[s] only contains characters <= 255.
 *!   @value 16
 *!     The string @[s] only contains characters <= 65535.
 *!   @value 32
 *!     The string @[s] contains characters >= 65536.
 *! @endint
 */
PIKEFUN int(8 .. 8)|int(16 .. 16)|int(32 .. 32) string_width(string s)
  errname String.width;
  optflags OPT_TRY_OPTIMIZE;
{
  RETURN 8 * (1 << s->size_shift);
}

/*! @decl mixed m_delete(object|mapping map, mixed index)
 *!
 *! If @[map] is an object that implements @[lfun::_m_delete()],
 *! that function will be called with @[index] as the signle argument.
 *!
 *! Other wise if @[map] is a mapping the entry with index @[index]
 *! will be removed from @[map] destructively.
 *!
 *! If the mapping does not have an entry with index @[index], nothing is done.
 *!
 *! @returns
 *!   The value that was removed will be returned.
 *!
 *! @note
 *!   Note that @[m_delete()] changes @[map] destructively.
 *!
 *! @seealso
 *!   @[mappingp()]
 */
PIKEFUN mixed m_delete(object|mapping map, mixed index)
  efun;
  optflags OPT_SIDE_EFFECT;
{
  /*FIXME: Should be
   *     type function(mapping(1=mixed:2=mixed),1:2)|
   *     function(object,mixed:mixed);
   *
   *     or similar
   */
  if( map->type == T_MAPPING )
  {
    struct svalue s;
    map_delete_no_free(map->u.mapping, index, &s);
    pop_n_elems(args);
    *sp=s;
    sp++;
  }
  else if (map->type == T_OBJECT && map->u.object->prog)
  {
    int id = FIND_LFUN(map->u.object->prog, LFUN__M_DELETE);

    if( id == -1 )
      SIMPLE_BAD_ARG_ERROR("m_delete", 1, "object with _m_delete");
    
    apply_low( map->u.object, id, 1 );
    stack_swap();
    pop_stack();
  } else {
    SIMPLE_BAD_ARG_ERROR("m_delete", 1, "object|mapping");
  }
}

/*! @decl int get_weak_flag(array|mapping|multiset m)
 *!
 *! Returns the weak flag settings for @[m]. It's a combination of
 *! @[Pike.WEAK_INDICES] and @[Pike.WEAK_VALUES].
 */
PIKEFUN int get_weak_flag(array m)
  efun;
  optflags OPT_EXTERNAL_DEPEND;
{
  RETURN (m->flags & ARRAY_WEAK_FLAG) ? PIKE_WEAK_VALUES : 0;
}

PIKEFUN int get_weak_flag(mapping m)
{
  RETURN  mapping_get_flags(m) & MAPPING_WEAK;
}

PIKEFUN int get_weak_flag(multiset m)
{
  RETURN (m->ind->flags & (ARRAY_WEAK_FLAG|ARRAY_WEAK_SHRINK)) ?
	PIKE_WEAK_INDICES : 0;
}

PIKEFUN program __empty_program()
  efun;
  optflags OPT_EXTERNAL_DEPEND;
{
  RETURN low_allocate_program();
}

/*! @decl string function_name(function f)
 *!
 *! Return the name of the function @[f].
 *!
 *! If @[f] is a global function defined in the runtime @tt{0@} (zero)
 *! will be returned.
 *!
 *! @seealso
 *! @[function_object()]
 */
PIKEFUN string function_name(program|function func)
  efun;
  optflags OPT_TRY_OPTIMIZE;
{
  struct pike_string *s;
  switch(func->type)
  {
    default:
      if(!func->u.object->prog)
	bad_arg_error("function_name", Pike_sp-args, args, 1,
		      "function|program", Pike_sp-args,
		      "Bad argument.\n");
      return; /* NOTREACHED */
	
    case PIKE_T_PROGRAM:
    {
      struct program *p=func->u.program;

      if(p->parent)
      {
	int e;
	p=p->parent;
	/* search constants in parent for this
	 * program...
	 */
	
	for(e = p->num_identifier_references; e--; )
	{
	  struct identifier *id;
	  if (p->identifier_references[e].id_flags & ID_HIDDEN)
	    continue;

	  id = ID_FROM_INT(p, e);
	  if (IDENTIFIER_IS_CONSTANT(id->identifier_flags) &&
	      is_eq( & PROG_FROM_INT(p, e)->constants[id->func.offset].sval,
		     func))
	    REF_RETURN id->name;
	}
      }
      break;
    }

    case PIKE_T_FUNCTION:
      if(func->subtype == FUNCTION_BUILTIN) break;
      if(!func->u.object->prog)
	bad_arg_error("function_name", Pike_sp-args, args, 1,
		      "function", Pike_sp-args,
		      "Destructed object.\n");
      if(func->u.object->prog == pike_trampoline_program)
      {
	struct pike_trampoline *t;
	t=((struct pike_trampoline *)func->u.object->storage);
	if(t->frame->current_object->prog)
	  REF_RETURN ID_FROM_INT(t->frame->current_object->prog,
				 t->func)->name;
      }
      
      REF_RETURN ID_FROM_INT(func->u.object->prog, func->subtype)->name;
  }
  pop_n_elems(args);
  push_int(0);
}

/*! @decl object function_object(function|program f)
 *!
 *! Return the object the function @[f] is in.
 *!
 *! If @[f] is a global function defined in the runtime @tt{0@} (zero)
 *! will be returned.
 *!
 *! @seealso
 *! @[function_name()]
 */
PIKEFUN object|program function_object(object|program|function func)
  efun;
  optflags OPT_TRY_OPTIMIZE;
  type function(function|object:object)|function(program:program);
{
  switch(func->type)
  {
    case PIKE_T_PROGRAM:
    {
      struct program *p;
      if(!(p=func->u.program->parent)) break;
      add_ref(p);
      free_program(func->u.program);
      func->u.program=p;
      return;
    }
      
    case PIKE_T_FUNCTION:
      if(func->subtype == FUNCTION_BUILTIN) break;
      if(func->u.object->prog == pike_trampoline_program)
      {
	struct object *o;
	o=((struct pike_trampoline *)func->u.object->storage)->frame->current_object;
	add_ref(o);
	pop_n_elems(args);
	push_object(o);
	return;
      }
      func->type=T_OBJECT;
      return;


    default:
      SIMPLE_BAD_ARG_ERROR("function_object",1,"function");
  }
  pop_n_elems(args);
  push_int(0);
}



/*! @decl int random(int max)
 *!
 *!   This function returns a random number in the range 0 - @[max]-1.
 *!
 *! @seealso
 *!   @[random_seed()]
 */


PIKEFUN mixed random(object o)
  efun;
  optflags OPT_TRY_OPTIMIZE|OPT_EXTERNAL_DEPEND;
{
  apply(o,"_random",0);
  stack_swap();
  pop_stack();
}

PIKEFUN int random(int i)
{
  if(i <= 0) RETURN 0;
  RETURN  my_rand() % i;
}      

PIKEFUN float random(float f)
{
  if(f<=0.0) RETURN 0.0;
#define N 1048576
  RETURN f * (my_rand()%N/((float)N)) +
    f * (my_rand()%N/( ((float)N) * ((float)N) ));
		   
}

PIKEFUN mixed random(array a)
{
  if(!a->size)
    SIMPLE_BAD_ARG_ERROR("random", 1, "array with elements in it");
  push_svalue(a->item + (my_rand() % a->size));
  stack_swap();
  pop_stack();
}

PIKEFUN mixed random(multiset m)
{
  if(!m->ind->size)
    SIMPLE_BAD_ARG_ERROR("random", 1, "multiset with elements in it");
  push_svalue(m->ind->item + (my_rand() % m->ind->size));
  stack_swap();
  pop_stack();
}

PIKEFUN mapping random(mapping m)
{
  struct mapping_data *md=m->data;
  size_t bucket, count;
  struct keypair *k;
  
  if(!m_sizeof(m))
    SIMPLE_BAD_ARG_ERROR("random", 1, "mapping with elements in it");
  
  /* Find a random, nonempty bucket */
  bucket=my_rand() % md->hashsize;
  while(! md->hash[bucket] )
    if(++bucket > (size_t)md->hashsize)
      bucket=0;
  
  /* Count entries in bucket */
  count=0;
  for(k=md->hash[bucket];k;k=k->next) count++;
  
  /* Select a random entry in this bucket */
  count = my_rand() % count;
  k=md->hash[bucket];
  while(count-- > 0) k=k->next;
  
  /* Push result and return */
  push_svalue(&k->ind);
  push_svalue(&k->val);
  f_aggregate(2);
  stack_swap();
  pop_stack();
}

/*
 * Backtrace handling.
 */

/*! @class BacktraceFrame
 */

PIKECLASS backtrace_frame
{
  PIKEVAR mixed fun;
  PIKEVAR array args;
  CVAR struct program *prog;
  CVAR unsigned char *pc;
  CVAR struct pike_string *filename;
  CVAR INT_TYPE lineno;

  INIT
  {
    THIS->fun.type = T_INT;
    THIS->fun.u.integer = 0;
    THIS->prog = NULL;
    THIS->pc = 0;
    THIS->lineno = 0;
    THIS->args = NULL;
    THIS->filename = NULL;
  }

  EXIT
  {
    if (THIS->prog) {
      free_program(THIS->prog);
      THIS->prog = NULL;
    }
    if (THIS->args) {
      free_array(THIS->args);
      THIS->args = NULL;
    }
    if (THIS->filename) {
      free_string(THIS->filename);
      THIS->filename = NULL;
    }
    THIS->pc = 0;
    THIS->lineno = 0;
    free_svalue(&THIS->fun);
    THIS->fun.type = T_INT;
  }

  PIKEFUN int(0..1) _is_type(string t)
  {
    INT_TYPE res = (t == findstring("array"));
    pop_n_elems(args);
    push_int(res);
  }

  PIKEFUN string _sprintf(int c, mapping|void opts)
  {
    pop_n_elems(args);

    push_text("backtrace_frame(");
    if (THIS->pc) {
      if (!THIS->filename) {
	THIS->filename =
	  make_shared_string(get_line(THIS->pc, THIS->prog, &THIS->lineno));
      }
      ref_push_string(THIS->filename);
      push_text(":");
      push_int(THIS->lineno);
      push_text(", ");
      f_add(4);
    } else {
      push_text("Unknown file, ");
    }
    if (THIS->fun.type == PIKE_T_FUNCTION) {
      if (THIS->fun.u.object->prog) {
	push_svalue(&THIS->fun);
	f_function_name(1);
	push_text("(), ");
	f_add(2);
      } else {
	free_svalue(&THIS->fun);
	THIS->fun.type = PIKE_T_INT;
	THIS->fun.u.integer = 0;
	THIS->fun.subtype = NUMBER_DESTRUCTED;
	push_text("destructed_function(), ");	
      }
    } else {
      push_text("destructed_function(), ");
    }

    if (THIS->args) {
      push_text("Args: ");
      push_int(THIS->args->size);
      f_add(2);
    } else {
      push_text("No args");
    }
    push_text(")");
    f_add(5);
  }

  PIKEFUN int _sizeof()
  {
    if (THIS->args) {
      push_int(THIS->args->size + 3);
    } else {
      push_int(3);
    }
  }

  PIKEFUN mixed `[](int index, int|void end_or_none)
  {
    INT_TYPE end = index;
    INT32 numargs = 0;
    INT32 i;

    if (THIS->args) {
      numargs = THIS->args->size;
    }

    numargs += 3;

    if (!end_or_none) {
      if (index < 0) {
	index_error("pike_frame->`[]", Pike_sp-args, args, NULL, Pike_sp-args,
		    "Indexing with negative index (%"PRINTPIKEINT"d)\n", index);
      } else if (index >= numargs) {
	index_error("pike_frame->`[]", Pike_sp-args, args, NULL, Pike_sp-args,
		    "Indexing with too large index (%"PRINTPIKEINT"d)\n", index);
      }
    } else {
      if (end_or_none->type != PIKE_T_INT) {
	SIMPLE_BAD_ARG_ERROR("`[]",2,"int|void");
      }
      end = end_or_none->u.integer;
    }

    pop_n_elems(args);

    if (end_or_none) {
      if ((end < 0) || (end < index) || (index >= numargs)) {
	f_aggregate(0);
	return;
      }

      if (end >= numargs) {
	end = numargs-1;
      }
    }

    for (i = index; i <= end; i++) {
      switch(i) {
      case 0:	/* Filename */
	if (THIS->pc) {
	  if (!THIS->filename) {
	    THIS->filename =
	      make_shared_string(get_line(THIS->pc, THIS->prog,
					  &THIS->lineno));
	  }
	  ref_push_string(THIS->filename);
	} else {
	  push_int(0);
	}
	break;
      case 1:	/* Linenumber */
	if (THIS->pc) {
	  if (!THIS->filename) {
	    THIS->filename =
	      make_shared_string(get_line(THIS->pc, THIS->prog,
					  &THIS->lineno));
	  }
	  push_int(THIS->lineno);
	} else {
	  push_int(0);
	}
        break;
      case 2:	/* Function */
        push_svalue(&THIS->fun);
        break;
      default:	/* Arguments */
        {
	  if ((i > 2) && (THIS->args) && (i-3 < THIS->args->size)) {
	    push_svalue(THIS->args->item + (i - 3));
	    break;
	  }
	  bad_arg_error("backtrace_frame->`[]", Pike_sp-args, args, 1,
			"int(0..)", Pike_sp-args,
			"Bad argument 1 to backtrace_frame->`[](): "
			"Expected int(0..%d)\n",
			numargs + 2);
	}
        /* NOT_REACHED */
        break;
      }
    }
    if (end_or_none) {
      f_aggregate(1 + end - index);
    }
  }

};

/*! @endclass
 */

/*! @decl array(array) backtrace()
 *!
 *!   Get a description of the current call stack.
 *!
 *!   The description is returned as an array with one entry for each call
 *!   frame on the stack.
 *!
 *!   Each entry has this format:
 *!   @array
 *!     @elem string file
 *!       A string with the filename if known, else zero.
 *!     @elem int line
 *!       An integer containing the linenumber if known, else zero.
 *!     @elem function fun
 *!       The function that was called at this level.
 *!     @elem mixed|void ... args
 *!       The arguments that the function was called with.
 *!   @endarray
 *!
 *!   The current call frame will be last in the array.
 *!
 *! @note
 *!   Please note that the frame order may be reversed in a later version
 *!   (than 7.1) of Pike to accomodate for deferred backtraces.
 *!
 *!   Note that the arguments reported in the backtrace are the current
 *!   values of the variables, and not the ones that were at call-time.
 *!   This can be used to hide sensitive information from backtraces
 *!   (eg passwords).
 *!
 *! @seealso
 *!   @[catch()], @[throw()]
 */
PMOD_EXPORT
PIKEFUN array(mixed) backtrace()
     efun;
     optflags OPT_EXTERNAL_DEPEND;
{
  struct pike_frame *f;
  int size = 0;

  for (f = Pike_fp; f; f = f->next) {
    struct object *o = low_clone(backtrace_frame_program);
    struct backtrace_frame_struct *bf;

    call_c_initializers(o);

    bf = OBJ2_BACKTRACE_FRAME(o);

    if ((bf->prog = f->context.prog)) {
      add_ref(bf->prog);
      bf->pc = f->pc;
    }

    if ((bf->fun.u.object = f->current_object) &&
	(bf->fun.u.object->prog)) {
      add_ref(bf->fun.u.object);
      bf->fun.subtype = f->fun;
      bf->fun.type = PIKE_T_FUNCTION;
    } else {
      bf->fun.u.integer = 0;
      bf->fun.subtype = NUMBER_DESTRUCTED;
      bf->fun.type = PIKE_T_INT;
    }

    if (f->locals) {
      INT32 numargs = DO_NOT_WARN((INT32) MINIMUM(f->num_args,
						  Pike_sp - f->locals));

      numargs = MAXIMUM(numargs, 0);

      if (numargs) {
	bf->args = allocate_array_no_init(numargs, 0);
	assign_svalues_no_free(bf->args->item, f->locals, numargs, BIT_MIXED);
      }
    }

    push_object(o);
    size++;
  }

  f_aggregate(size);
  f_reverse(1);
}

void init_builtin(void)
{
INIT
}
