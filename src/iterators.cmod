/*\
||| This file a part of Pike, and is copyright by Fredrik Hubinette
||| Pike is distributed as GPL (General Public License)
||| See the files COPYING and DISCLAIMER for more information.
\*/
/**/
#include "global.h"
RCSID("$Id: iterators.cmod,v 1.4 2001/02/28 14:26:30 grubba Exp $");
#include "main.h"
#include "object.h"
#include "mapping.h"
#include "multiset.h"
#include "svalue.h"
#include "array.h"
#include "pike_macros.h"
#include "pike_error.h"
#include "pike_memory.h"
#include "dynamic_buffer.h"
#include "interpret.h"
#include "las.h"
#include "gc.h"
#include "stralloc.h"
#include "security.h"
#include "block_alloc.h"
#include "opcodes.h"
#include "pike_error.h"
#include "program.h"

DECLARATIONS

PIKECLASS mapping_iterator
{
  /* All variables *must* be before all functions! */
  CVAR int bucket;
  CVAR struct mapping *m;
  CVAR struct mapping_data *md;
  CVAR struct keypair *current;

  PIKEFUN mixed value()
    {
      if(THIS->current)
	push_svalue(& THIS->current->val);
      else
      {
	push_int(0);
	Pike_sp[-1].subtype=NUMBER_UNDEFINED;
      }
    }

  PIKEFUN mixed index()
    {
      if(THIS->current)
	push_svalue(& THIS->current->ind);
      else
      {
	push_int(0);
	Pike_sp[-1].subtype=NUMBER_UNDEFINED;
      }
    }

  static int step_bucket(struct mapping_iterator_struct *i)
    {
      while(! i->current)
      {
	i->bucket++;
	if(i->bucket >= i->md->hashsize)
	  return 0;
	i->current=i->md->hash[i->bucket];
      }
      return 1;
    }

  static int mi_step(struct mapping_iterator_struct *i)
    {
      if(! i->current) return 0;
      i->current=i->current->next;
      return step_bucket(i);
    }
  
  PIKEFUN object `+(int steps)
    {
      struct object *o=low_clone(mapping_iterator_program);
      OBJ2_MAPPING_ITERATOR(o)[0] = *THIS;
      add_ref(THIS->m);
      add_ref(THIS->md);
      THIS->md->valrefs++;
      while(--steps>=0 && mi_step(OBJ2_MAPPING_ITERATOR(o)));
      RETURN o;
    }

  PIKEFUN object `+=(int steps)
    {
      while(--steps>=0 && mi_step(THIS));
      REF_RETURN Pike_fp->current_object;
    }

  PIKEFUN int first()
    {
      THIS->current=0;
      THIS->bucket=-1;
      RETURN step_bucket(THIS);
    }

  PIKEFUN int next() { RETURN mi_step(THIS); }
  PIKEFUN int `!() { RETURN !THIS->current; }

  PIKEFUN void create(mapping map)
    {
      if(THIS->m)
	Pike_error("Mapping iterators cannot be reused.\n");

      add_ref(THIS->m=map);
      THIS->md=map->data;
      add_ref(THIS->md);
      THIS->md->valrefs++;
      THIS->bucket=-1;
      step_bucket(THIS);
    }

  INIT
    {
      THIS->m=0;
      THIS->md=0;
      THIS->current=0;
      THIS->bucket=0;
    }

  EXIT
    {
      free_mapping(THIS->m);
      THIS->md->valrefs--;
      free_mapping_data(THIS->md);
    }
};

PIKECLASS array_iterator
{
  CVAR int pos;
  CVAR struct array *a;
  
  PIKEFUN mixed value()
    {
      if(!THIS->a || THIS->pos >= THIS->a->size) 
      {
	push_int(0);
	Pike_sp[-1].subtype=NUMBER_UNDEFINED;
      }else{
	push_svalue(THIS->a->item + THIS->pos);
      }
    }

  PIKEFUN int index()
    {
      if(!THIS->a || THIS->pos >= THIS->a->size) 
      {
	push_int(0);
	Pike_sp[-1].subtype=NUMBER_UNDEFINED;
      }else{
	RETURN THIS->pos;
      }
    }

  PIKEFUN object `+(int steps)
    {
      struct object *o=low_clone(array_iterator_program);
      OBJ2_ARRAY_ITERATOR(o)[0]=*THIS;
      add_ref(THIS->a);
      OBJ2_ARRAY_ITERATOR(o)->pos+=steps;
      RETURN o;
    }

  PIKEFUN object `+=(int steps)
  {
    THIS->pos+=steps;
    REF_RETURN Pike_fp->current_object;
  }

  PIKEFUN int first()
    {
      THIS->pos=0;
      RETURN THIS->a && THIS->a->size < THIS->pos;
    }
  PIKEFUN int next()
    {
      THIS->pos++;
      RETURN THIS->a && THIS->a->size < THIS->pos;
    }

  PIKEFUN int `!()
    {
      RETURN !(THIS->a && THIS->a->size < THIS->pos);
    }

  PIKEFUN void create(array a)
    {
      if(THIS->a)
	Pike_error("Array iterators cannot be reused.\n");
      
      add_ref(THIS->a=a);
    }
  
  INIT 
    {
      THIS->a=0;
      THIS->pos=0;
    }

  EXIT
    {
      free_array(THIS->a);
    }
    
};

PIKECLASS multiset_iterator
{
  CVAR int pos;
  CVAR struct array *a;
  
  PIKEFUN int value()
    {
      if(!THIS->a || THIS->pos >= THIS->a->size) 
      {
	push_int(0);
	Pike_sp[-1].subtype=NUMBER_UNDEFINED;
      }else{
	push_int(1);
      }
    }

  PIKEFUN mixed index()
    {
      if(!THIS->a || THIS->pos >= THIS->a->size) 
      {
	push_int(0);
	Pike_sp[-1].subtype=NUMBER_UNDEFINED;
      }else{
	push_svalue(THIS->a->item + THIS->pos);
      }
    }

  PIKEFUN object `+(int steps)
    {
      struct object *o=low_clone(array_iterator_program);
      OBJ2_MULTISET_ITERATOR(o)[0]=*THIS;
      add_ref(THIS->a);
      OBJ2_MULTISET_ITERATOR(o)->pos+=steps;
      RETURN o;
    }

  PIKEFUN object `+=(int steps)
  {
    THIS->pos+=steps;
    REF_RETURN Pike_fp->current_object;
  }

  PIKEFUN int first()
    {
      THIS->pos=0;
      RETURN THIS->a && THIS->a->size < THIS->pos;
    }
  PIKEFUN int next()
    {
      THIS->pos++;
      RETURN THIS->a && THIS->a->size < THIS->pos;
    }

  PIKEFUN int `!()
    {
      RETURN !(THIS->a && THIS->a->size < THIS->pos);
    }

  PIKEFUN void create(multiset m)
    {
      if(THIS->a)
	Pike_error("Array iterators cannot be reused.\n");
      
      add_ref(THIS->a=m->ind);
    }
  
  INIT 
    {
      THIS->a=0;
      THIS->pos=0;
    }

  EXIT
    {
      free_array(THIS->a);
    }
    
};

PIKECLASS string_iterator
{
  CVAR int pos;
  CVAR struct pike_string *s;
  
  PIKEFUN int value()
    {
      if(!THIS->s || THIS->pos >= THIS->s->len) 
      {
	push_int(0);
	Pike_sp[-1].subtype=NUMBER_UNDEFINED;
      }else{
	RETURN index_shared_string(THIS->s, THIS->pos);
      }
    }

  PIKEFUN int index()
    {
      if(!THIS->s || THIS->pos >= THIS->s->len) 
      {
	push_int(0);
	Pike_sp[-1].subtype=NUMBER_UNDEFINED;
      }else{
	RETURN THIS->pos;
      }
    }

  PIKEFUN object `+(int steps)
    {
      struct object *o=low_clone(string_iterator_program);
      OBJ2_STRING_ITERATOR(o)[0]=*THIS;
      add_ref(THIS->s);
      OBJ2_STRING_ITERATOR(o)->pos+=steps;
      RETURN o;
    }

  PIKEFUN object `+=(int steps)
  {
    THIS->pos+=steps;
    REF_RETURN Pike_fp->current_object;
  }

  PIKEFUN int first()
    {
      THIS->pos=0;
      RETURN THIS->s && THIS->s->len < THIS->pos;
    }
  PIKEFUN int next()
    {
      THIS->pos++;
      RETURN THIS->s && THIS->s->len < THIS->pos;
    }

  PIKEFUN int `!()
    {
      RETURN !(THIS->s && THIS->s->len < THIS->pos);
    }

  PIKEFUN void create(string s)
    {
      if(THIS->s)
	Pike_error("String iterators cannot be reused.\n");
      
      add_ref(THIS->s=s);
    }
  
  INIT 
    {
      THIS->s=0;
      THIS->pos=0;
    }

  EXIT
    {
      free_string(THIS->s);
    }
};

PIKEFUN object Iterator(object|array|mapping|multiset|string data)
{
  switch(data->type)
  {
    case PIKE_T_STRING:
      push_object(clone_object(string_iterator_program, 1));
      return;

    case PIKE_T_MAPPING:
      push_object(clone_object(mapping_iterator_program,1));
      return;

    case PIKE_T_MULTISET:
      push_object(clone_object(multiset_iterator_program, 1));
      return;

    case PIKE_T_ARRAY:
      push_object(clone_object(array_iterator_program, 1));
      return;


    case PIKE_T_OBJECT:
      if(!data->u.object->prog)
	Pike_error("Argument 1 to Iterator() is a destructed object.\n");

#ifdef LFUN__GET_ITERATOR
      if(FIND_LFUN(data->u.object->prog, LFUN__GET_ITERATOR) != -1)
      {
	apply_lfun(data->u.object, LFUN__GET_ITERATOR, 1);
	stack_unlink(1);
	return;
      }
#endif

      /* Assume it already is an iterator... */
      return;

    default:
      SIMPLE_BAD_ARG_ERROR("Iterator", 1, "multiset|array|string|mapping|object");
  }
}

/* sp[-4] = index; sp[-2] = value */
int foreach_iterate(struct object *o)
{
  if(!o->prog)
    Pike_error("foreach on destructed iterator.\n");
  if(o->prog->flags & PROGRAM_HAS_C_METHODS)
  {
    if(o->prog == mapping_iterator_program)
    {
      struct mapping_iterator_struct *i=OBJ2_MAPPING_ITERATOR(o);

      if(i->current)
      {
	if(Pike_sp[-4].type != T_INT)
	  assign_lvalue(Pike_sp-4, & i->current->ind);
	
	if(Pike_sp[-2].type != T_INT)
	  assign_lvalue(Pike_sp-2, & i->current->val);
	mi_step(i);
	return 1;
      }else{
	return 0;
      }
    }
    if(o->prog == array_iterator_program)
    {
      struct array_iterator_struct *i=OBJ2_ARRAY_ITERATOR(o);
      if(i->pos < i->a->size)
      {
	if(Pike_sp[-4].type != T_INT)
	{
	  push_int(i->pos);
	  assign_lvalue(Pike_sp-5, Pike_sp-1);
	  pop_stack();
	}

	if(Pike_sp[-2].type != T_INT)
	  assign_lvalue(Pike_sp-2, i->a->item + i->pos);

	i->pos++;
	return 1;
      }else{
	return 0;
      }
    }
    if(o->prog == multiset_iterator_program)
    {
      struct multiset_iterator_struct *i=OBJ2_MULTISET_ITERATOR(o);
      if(i->pos < i->a->size)
      {
	if(Pike_sp[-4].type != T_INT)
	  assign_lvalue(Pike_sp-4, i->a->item + i->pos);

	if(Pike_sp[-2].type != T_INT)
	{
	  push_int(1);
	  assign_lvalue(Pike_sp-3, Pike_sp-1);
	  pop_stack();
	}

	i->pos++;
	return 1;
      }else{
	return 0;
      }
    }
    if(o->prog == string_iterator_program)
    {
      struct string_iterator_struct *i=OBJ2_STRING_ITERATOR(o);
      if(i->pos < i->s->len)
      {
	if(Pike_sp[-4].type != T_INT)
	{
	  push_int(i->pos);
	  assign_lvalue(Pike_sp-5, Pike_sp-1);
	  pop_stack();
	}

	if(Pike_sp[-2].type != T_INT)
	{
	  push_int(index_shared_string(i->s, i->pos));
	  assign_lvalue(Pike_sp-3, Pike_sp-1);
	  pop_stack();
	}

	i->pos++;
	return 1;
      }else{
	return 0;
      }
    }
  }

  /* Generic iteration */
  apply_lfun(o,LFUN_NOT,0);
  if(IS_ZERO(Pike_sp-1))
  {
    if(Pike_sp[-4].type != T_INT)
    {
      apply(o,"index",0);
      assign_lvalue(Pike_sp-5,Pike_sp-1);
      pop_stack();
    }

    if(Pike_sp[-2].type != T_INT)
    {
      apply(o,"value",0);
      assign_lvalue(Pike_sp-3,Pike_sp-1);
      pop_stack();
    }

    push_int(1);
    apply_lfun(o,LFUN_ADD_EQ,1);
    return 1;
  }else{
    return 0;
  }
}


void init_iterators(void)
{
  INIT
}

void exit_iterators(void)
{
  EXIT
}

