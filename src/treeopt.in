// -*- c -*-
//
// $Id: treeopt.in,v 1.45 2000/10/01 17:58:12 grubba Exp $
//
// The tree optimizer
//
// Henrik Grubbström 1999-11-06


// Note: This can cause problems if optimize is called
// before the other tests... /Hubbe
0 = F_APPLY(1 = F_CONSTANT
	    [$$->u.sval.type == T_FUNCTION]
	    [$$->u.sval.subtype == FUNCTION_BUILTIN]
	    [$$->u.sval.u.efun->optimize]
            [ (tmp1=$$->u.sval.u.efun->optimize($0)) ], *):

{
  goto use_tmp1;
}
;

// Attempt to call a void expression.
// The compiler has already complained about it, so just make a valid node.
F_APPLY(-, 0 = *):
  F_COMMA_EXPR(F_POP_VALUE($0, -), 0);

// Attempt to return a void expression.
// The compiler has already complained about it, so just make a valid node.
F_RETURN(-, *):
  F_RETURN(0, -);

// @({ a, b, c })  =>  a, b, c
// Nonconstant array
F_PUSH_ARRAY(F_APPLY(F_CONSTANT
		     [$$->u.sval.type == T_FUNCTION]
		     [$$->u.sval.subtype == FUNCTION_BUILTIN]
		     [$$->u.sval.u.efun->function == debug_f_aggregate], 0), *):
  $0;

// @({ a, b, c })  =>  a, b, c
// Constant array
F_PUSH_ARRAY(0 = F_CONSTANT[$$->u.sval.type == T_ARRAY], *):
  {
    struct array *a = $0->u.sval.u.array;
    node *n = NULL;
    int i;
    for(i=0; i<a->size; i++) {
      if (n) {
	n = mknode(F_ARG_LIST, n, mksvaluenode(a->item+i));
      } else {
	/* i is always 0 here. */
	n = mksvaluenode(a->item);
      }
    }
    $$ = n;
  }
  ;

// `+(`+(a,b),c)  =>  `+(a, b, c)
// NOTE: We do some ugly stuff here to avoid
//	 resolving the resulting type multiple times.
F_APPLY(0 = F_CONSTANT
	[$$->u.sval.type == T_FUNCTION]
	[$$->u.sval.subtype == FUNCTION_BUILTIN]
	[$$->u.sval.u.efun->function == f_add],
	2 = F_ARG_LIST(F_APPLY($0, 1), 3)):
  {
    node *arglist = $2;
#ifdef SHARED_NODES
    sub_node(n);
#endif /* SHARED_NODES */
    ADD_NODE_REF2($1,
    ADD_NODE_REF2($3,
		  _CDR(n) = mknode(F_ARG_LIST, $1, $3)));
#ifdef SHARED_NODES
    n->hash = hash_node(n);
    n->node_info |= OPT_DEFROSTED;
#endif /* SHARED_NODES */
    free_node(arglist);
#ifdef PIKE_DEBUG
    if (l_flag > 4) {
      fprintf(stderr, "Result:    ");
      print_tree(n);
    }
#endif /* PIKE_DEBUG */
    continue;
  }
  ;

// `*(`*(a,b),c)  =>  `*(a, b, c)
// NOTE: We do some ugly stuff here to avoid
//	 resolving the resulting type multiple times.
// NOTE: In this case we also need to do this since
//	 typeof(`*) isn't permissive enough.
F_APPLY(0 = F_CONSTANT
	[$$->u.sval.type == T_FUNCTION]
	[$$->u.sval.subtype == FUNCTION_BUILTIN]
	[$$->u.sval.u.efun->function == f_multiply],
	2 = F_ARG_LIST(3 = F_APPLY($0, 1), *)):
  {
    node *arglist = $2;
#ifdef SHARED_NODES
    sub_node(n);
#endif /* SHARED_NODES */
    ADD_NODE_REF2($1,
    ADD_NODE_REF2($3,
		  _CDR(n) = mknode(F_ARG_LIST, $1, $3)));
#ifdef SHARED_NODES
    n->hash = hash_node(n);
    n->node_info |= OPT_DEFROSTED;
#endif /* SHARED_NODES */
    free_node(arglist);
#ifdef PIKE_DEBUG
    if (l_flag > 4) {
      fprintf(stderr, "Result:    ");
      print_tree(n);
    }
#endif /* PIKE_DEBUG */
    continue;
  }
  ;


F_POP_VALUE(-, *):
  -;

// F_POP_VALUE doesn't leave anything on the stack to pop...
F_POP_VALUE(0 = F_POP_VALUE, *):
  $0;

// Casts don't have side-effects.
F_POP_VALUE(F_CAST(0, *), *):
  F_POP_VALUE($0, -);

// Don't push constants just to pop them.
F_POP_VALUE(F_CONSTANT, *):
  -;

// Why perform a calculation just to throw away the result?
F_POP_VALUE(+[node_is_tossable($$)], *):
  -;

// Popping of variables.
F_POP_VALUE(F_LOCAL, *):
  -;

// Popping of variables.
F_POP_VALUE(F_GLOBAL, *):
  -;

// Popping of variables.
F_POP_VALUE(F_EXTERNAL, *):
  -;

// Popping of zero elements.
// This set of rules also protects the rule
//   F_COMMA(F_POP(0), F_POP(1)) => F_POP(F_COMMA(0, 1))
F_POP_VALUE(0 = F_RETURN, *):
  $0;

F_POP_VALUE(0 = F_CONTINUE, *):
  $0;

F_POP_VALUE(0 = F_BREAK, *):
  $0;

F_POP_VALUE(0 = F_CASE, *):
  $0;

F_POP_VALUE(0 = F_DEFAULT, *):
  $0;

F_POP_VALUE(0 = F_FOR, *):
  $0;

F_POP_VALUE(0 = F_FOREACH, *):
  $0;

F_POP_VALUE(0 = F_INC_LOOP, *):
  $0;

F_POP_VALUE(0 = F_DEC_LOOP, *):
  $0;

F_POP_VALUE(0 = F_INC_NEQ_LOOP, *):
  $0;

F_POP_VALUE(0 = F_DEC_NEQ_LOOP, *):
  $0;

F_POP_VALUE(0 = F_SWITCH, *):
  $0;

F_POP_VALUE('?'(0, ':'(1, 2)), *):
  '?'($0, ':'(F_POP_VALUE($1, -), F_POP_VALUE($2, -)));



F_CAST(-,*):
  -;

// void can't be casted to anything else.
F_CAST(0 = +[$$->type == void_type_string], *):
{
  yywarning("Casting a void expression\n");
  $$ = $0;
}
;

// This one is probably not needed, since it's handled by mkcastnode()
0 = F_CAST(1 = F_CAST[$$->type == $0->type](*, *), *):
  $1;

// This one is probably not needed, since it's handled by mkcastnode()
0 = F_CAST(1 = F_CONSTANT[$$->type == $0->type](*, *), *):
  $1;

// Propagate casts towards the root instead.
// // Propagate casts towards the leaves
// 0 = F_CAST(F_COMMA_EXPR(1, 2), *):
// {
//   struct pike_string *type = $0->type;
//   $$ = mknode(F_COMMA_EXPR, mkcastnode(void_type_string, $1),
// 		 mkcastnode(type, $2));
// }
// ;
// 
// // Propagate casts toward the leaves
// 0 = F_CAST('?'(1, ':'(2, 3)), *):
// {
//   struct pike_string *type = $0->type;
//   $$ = mknode('?', $1, mknode(':', mkcastnode(type, $2),
// 				 mkcastnode(type, $3)));
// }
// ;

// Remove function calls that don't affect the result or the state.
// FIXME: Disabled since it doesn't check for callbacks.
// F_CAST[$$->type == void_type_string]
// 	 (F_APPLY(F_CONSTANT[($$->node_info &
// 			      (OPT_SIDE_EFFECT|
// 			       OPT_ASSIGNMENT|
// 			       OPT_TRY_OPTIMIZE)) == OPT_TRY_OPTIMIZE],
// 		  F_ARG_LIST(1, 2)), *):
// {
//   $$ = mkcastnode(void_type_string,
// 		     mknode(F_COMMA_EXPR, $1, $2));
// }
// ;
// 
// F_CAST[$$->type == void_type_string]
// 	 (F_APPLY(F_CONSTANT[($$->node_info &
// 			      (OPT_SIDE_EFFECT|
// 			       OPT_ASSIGNMENT|
// 			       OPT_TRY_OPTIMIZE)) == OPT_TRY_OPTIMIZE],
// 		  0), *):
// 	   $0;


F_RANGE(*, F_ARG_LIST(*, F_CONSTANT[$$->u.sval.type == T_INT]
                                   [$$->u.sval.u.integer < 0])):
{
  yywarning("Range end is negative.");
}
;

F_RANGE(*, F_ARG_LIST(*, F_CONSTANT[$$->u.sval.type == T_FLOAT]
				   [$$->u.sval.u.float_number < 0.0])):
{
  yywarning("Range end is negative.");
}
;


F_COMMA_EXPR(-, 0):
  $0;

F_COMMA_EXPR(0, -):
  $0;

F_COMMA_EXPR(F_CONSTANT, 0 = +):
  $0;

F_COMMA_EXPR(+[node_is_tossable($$)], 0 = +):
  $0;

F_COMMA_EXPR(F_COMMA_EXPR(0, F_CONSTANT), 1 = +):
  F_COMMA_EXPR($0, $1);

F_COMMA_EXPR(F_COMMA_EXPR(0, +[node_is_tossable($$)]), 1 = +):
  F_COMMA_EXPR($0, $1);

// Join adjacent F_POP_VALUE's.
// NOTE: These two rules work only since F_RETURN, F_BREAK and F_CONTINUE
// have been stripped of F_POP_VALUE by rules above.
// FIXME: This optimization makes values stay on the stack longer,
// which might not be a good idea.
F_COMMA_EXPR(F_POP_VALUE(0, *), F_POP_VALUE(1, *)):
  F_POP_VALUE(F_COMMA_EXPR($0, $1), -);

F_COMMA_EXPR(F_COMMA_EXPR(0, F_POP_VALUE(1, *)), F_POP_VALUE(2, *)):
  F_COMMA_EXPR($0, F_POP_VALUE(F_COMMA_EXPR($1, $2), -));

// Remove initial casts in comma-expressions.
F_COMMA_EXPR(F_CAST(0, *), 1 = +):
  F_COMMA_EXPR($0, $1);

// Propagate casts towards the root.
F_COMMA_EXPR(0, 1 = F_CAST(2, *)):
{
  struct pike_string *type = $1->type;
  $$ = mkcastnode(type, mknode(F_COMMA_EXPR, $0, $2));
}
;

// The following two are disabled, since they are too general.
// F_COMMA_EXPR(+[!($$->tree_info & (OPT_SIDE_EFFECT|OPT_ASSIGNMENT|OPT_CASE|
// 				     OPT_CONTINUE|OPT_BREAK|OPT_RETURN))], 0 = +):
//   $0;
// 
// F_COMMA_EXPR(F_COMMA_EXPR(0, +[!($$->tree_info & (OPT_SIDE_EFFECT|
// 						     OPT_ASSIGNMENT|OPT_CASE|
// 						     OPT_CONTINUE|OPT_BREAK|
// 						     OPT_RETURN))]), 1 = +):
//   F_COMMA_EXPR($0, $1);

// Convert the argument-list to a comma-list.
F_COMMA_EXPR(F_ARG_LIST(0, 1), 2):
  F_COMMA_EXPR(F_COMMA_EXPR($0, $1), $2);

// Ensure that the result value is at the top-node, to ensure
// proper optimization.
F_COMMA_EXPR(0, F_COMMA_EXPR(1, 2)):
  F_COMMA_EXPR(F_COMMA_EXPR($0, $1), $2);

// Dead-code elimination.
// FIXME: Should it be a warning here?
// Is really the OPT_CASE needed for the following three?
F_COMMA_EXPR(0 = F_RETURN, +[!($$->tree_info & OPT_CASE)]):
  $0;

F_COMMA_EXPR(0 = F_CONTINUE, +[!($$->tree_info & OPT_CASE)]):
  $0;

F_COMMA_EXPR(0 = F_BREAK, +[!($$->tree_info & OPT_CASE)]):
  $0;

F_COMMA_EXPR(0 = F_COMMA_EXPR(*, F_RETURN), +[!($$->tree_info & OPT_CASE)]):
  $0;

F_COMMA_EXPR(0 = F_COMMA_EXPR(*, F_CONTINUE), +[!($$->tree_info & OPT_CASE)]):
  $0;

F_COMMA_EXPR(0 = F_COMMA_EXPR(*, F_BREAK), +[!($$->tree_info & OPT_CASE)]):
  $0;


F_ARG_LIST(-, 0):
  $0;

F_ARG_LIST(0, -):
  $0;

// Dead-code elimination.
// FIXME: Should it be a warning here?
// Do people even write code where this is trigged? return in an srgument-list?
// Is really the OPT_CASE needed for the following three?
F_ARG_LIST(0 = F_RETURN, +[!($$->tree_info & OPT_CASE)]):
  $0;

F_ARG_LIST(0 = F_CONTINUE, +[!($$->tree_info & OPT_CASE)]):
  $0;

F_ARG_LIST(0 = F_BREAK, +[!($$->tree_info & OPT_CASE)]):
  $0;

F_ARG_LIST(0 = F_COMMA_EXPR(*, F_RETURN), +[!($$->tree_info & OPT_CASE)]):
  $0;

F_ARG_LIST(0 = F_COMMA_EXPR(*, F_CONTINUE), +[!($$->tree_info & OPT_CASE)]):
  $0;

F_ARG_LIST(0 = F_COMMA_EXPR(*, F_BREAK), +[!($$->tree_info & OPT_CASE)]):
  $0;


F_LVALUE_LIST(-, 0):
  $0;

F_LVALUE_LIST(0, -):
  $0;

// Dead-code elimination.
// FIXME: Should it be a warning here?
// Even more obscure -- return in an lvalue?
// Is really the OPT_CASE needed for the following three?
F_LVALUE_LIST(0 = F_RETURN, +[!($$->tree_info & OPT_CASE)]):
  $0;

F_LVALUE_LIST(0 = F_CONTINUE, +[!($$->tree_info & OPT_CASE)]):
  $0;

F_LVALUE_LIST(0 = F_BREAK, +[!($$->tree_info & OPT_CASE)]):
  $0;

F_LVALUE_LIST(0 = F_COMMA_EXPR(*, F_RETURN), +[!($$->tree_info & OPT_CASE)]):
  $0;

F_LVALUE_LIST(0 = F_COMMA_EXPR(*, F_CONTINUE), +[!($$->tree_info & OPT_CASE)]):
  $0;

F_LVALUE_LIST(0 = F_COMMA_EXPR(*, F_BREAK), +[!($$->tree_info & OPT_CASE)]):
  $0;


F_LOR(-, 0):
  $0;

F_LOR(0, -):
  $0;

// DeMorgan
F_LOR(F_APPLY(0 = F_CONSTANT
	      [$$->u.sval.type == T_FUNCTION]
	      [$$->u.sval.subtype == FUNCTION_BUILTIN]
	      [$$->u.sval.u.efun->function == f_not], 1),
      F_APPLY($0, 2)):
  F_APPLY($0, F_LAND($1, $2));

F_LOR(0, F_LOR(1, 2)):
  F_LOR(F_LOR($0, $1), $2);

F_LOR(0 = F_ASSIGN(*, +[node_is_false($$)]), 2):
  F_COMMA_EXPR($0, $2);

F_LOR(F_COMMA_EXPR(0, 1), 2):
  F_COMMA_EXPR($0, F_LOR($1, $2));

F_LOR(0 = F_ASSIGN(*, +[node_is_true($$)]), *):
  $0;

F_LOR(0, F_CONSTANT[node_is_false($$)]):
  $0;

F_LOR(+[node_is_false($$)], 0):
  $0;

F_LOR(0 = +[node_is_true($$)], *):
  $0;


F_LAND(-, 0):
  -;

F_LAND(0, -):
  F_COMMA_EXPR($0, 0);

// DeMorgan
F_LAND(F_APPLY(0 = F_CONSTANT
	       [$$->u.sval.type == T_FUNCTION]
	       [$$->u.sval.subtype == FUNCTION_BUILTIN]
	       [$$->u.sval.u.efun->function == f_not], 1),
       F_APPLY($0, 2)):
  F_APPLY($0, F_LOR($1, $2));

F_LAND(0, F_LAND(1, 2)):
  F_LAND(F_LAND($0, $1), $2);

F_LAND(0 = F_ASSIGN(*, +[node_is_true($$)]), 2):
  F_COMMA_EXPR($0, $2);

F_LAND(0 = F_ASSIGN(*, +[node_is_false($$)]), *):
  $0;

F_LAND(F_COMMA_EXPR(0, 1), 2):
  F_COMMA_EXPR($0, F_LAND($1, $2));

F_LAND(+[node_is_true($$)], 0):
  $0;

F_LAND(0 = +[node_is_false($$)], *):
  $0;


// Optimizations of if statements.
'?'(-, -):
  -;

'?'(-, ':'(*, 0)):
  $0;

'?'(0, -):
  $0;

'?'(0, ':'(-, -)):
  $0;

'?'(F_APPLY(F_CONSTANT
	    [$$->u.sval.type == T_FUNCTION]
	    [$$->u.sval.subtype == FUNCTION_BUILTIN]
	    [$$->u.sval.u.efun->function == f_not], 0), ':'(1, 2)):
  '?'($0, ':'($2, $1));

'?'(+[node_is_true($$)], ':'(0, *)):
  $0;

'?'(+[node_is_false($$)], ':'(*, 0)):
  $0;

'?'(0, ':'(1, $1)):
  F_COMMA_EXPR($0, $1);

'?'(0, ':'(F_COMMA_EXPR(1, 2), $2)):
  F_COMMA_EXPR('?'($0, ':'($1, -)), $2);

'?'(0, ':'(1, F_COMMA_EXPR(2, $1))):
  F_COMMA_EXPR('?'($0, ':'(-, $2)), $1);

'?'(0, ':'(F_COMMA_EXPR(1, 2), F_COMMA_EXPR(3, $2))):
  F_COMMA_EXPR('?'($0, ':'($1, $3)), $2);


// Optimizations of negations.
F_NOT(-, *):
  1;

F_NOT(F_LT(0, 1), *):
  F_GE($0, $1);

F_NOT(F_GT(0, 1), *):
  F_LE($0, $1);

F_NOT(F_LE(0, 1), *):
  F_GT($0, $1);

F_NOT(F_GE(0, 1), *):
  F_LT($0, $1);

F_NOT(F_EQ(0, 1), *):
  F_NE($0, $1);

F_NOT(F_NE(0, 1), *):
  F_EQ($0, $1);


// a += 0  ->  a
F_ADD_EQ(0, 1 = F_CONSTANT[$$->u.sval.type == T_INT]
	 [!($$->u.sval.u.integer)]):
  $0;

// a += 1  ->  ++a
F_ADD_EQ(0, 1 = F_CONSTANT[$$->u.sval.type == T_INT]
	 [($$->u.sval.u.integer) == 1]):
  F_INC($0, -);

// a += -1  ->  --a
F_ADD_EQ(0, 1 = F_CONSTANT[$$->u.sval.type == T_INT]
	 [($$->u.sval.u.integer) == -1]):
  F_DEC($0, -);


// a += 0  ->  a
F_SUB_EQ(0, 1 = F_CONSTANT[$$->u.sval.type == T_INT]
	 [!($$->u.sval.u.integer)]):
  $0;

// a -= 1  ->  --a
F_SUB_EQ(0, 1 = F_CONSTANT[$$->u.sval.type == T_INT]
	 [($$->u.sval.u.integer) == 1]):
  F_DEC($0, -);

// a -= -1  ->  ++a
F_SUB_EQ(0, 1 = F_CONSTANT[$$->u.sval.type == T_INT]
	 [($$->u.sval.u.integer) == -1]):
  F_INC($0, -);


F_INDEX(-, 0 = *):
  F_COMMA_EXPR(F_POP_VALUE($0, -), 0);

// foo["str"]  ->  foo->str
F_INDEX(0 [ !match_types($$->type, object_type_string) ],
	1 = F_CONSTANT[$$->u.sval.type == T_STRING]):
  F_ARROW($0, $1);


F_ARROW(-, 0 = *):
  F_COMMA_EXPR(F_POP_VALUE($0, -), 0);

F_ARROW(0 = F_CONSTANT[$$->u.sval.type == T_OBJECT]
	    [$$->u.sval.u.object->prog],
	1 = F_CONSTANT[$$->u.sval.type == T_STRING]):
{
  /*
  if (find_identifier("`->", $0->u.sval.u.object->prog) == -1) {
    int i = find_shared_string_identifier($1->u.sval.u.string,
					  $0->u.sval.u.object->prog);
    if (i) {
      struct identifier *id = ID_FROM_INT($0->u.sval.u.object->prog, i);
      if (IDENTIFIER_IS_VARIABLE(id->identifier_flags))
	goto next_arrow_opt;
    }
    ref_push_object($0->u.sval.u.object);
    ref_push_string($1->u.sval.u.string);
    f_index(2);
    tmp1 = mksvaluenode(sp-1);
    pop_stack();
    goto use_tmp1;
  }
 next_arrow_opt:
  ;
  */
}
;


// do-while optimizations.
F_DO(0[!($$->tree_info & (OPT_BREAK|OPT_CONTINUE))], -):
  $0;

F_DO(0[!($$->tree_info & (OPT_BREAK|OPT_CONTINUE))], +[node_is_false($$)]):
  $0;

F_DO(-, 0 = +[node_is_true($$)]):
{
  /* Infinite loop */
  $$ = mknode(F_DO, mkefuncallnode("sleep", mkintnode(255)), $0);
}
;


// No body -- No reason to loop...
F_FOREACH(F_VAL_LVAL(0, *), -):
  F_POP_VALUE($0, -);


F_FOR(-, *):
  -;

F_FOR(0, ':'(-, -)):
  F_FOR($0, -);

F_FOR(+[node_is_false($$)], *):
  -;

F_FOR(0 = +[node_is_true($$)], -):
{
  /* Infinite loop */
  $$ = mknode(F_FOR, $0, mknode(':',
				mkefuncallnode("sleep", mkintnode(255)),
				0));
}
;


F_FOR(F_INC(0, *), -):
  F_INC_NEQ_LOOP(F_VAL_LVAL(0, $0), -);
F_FOR(F_INC(0, *), ':'(-, 1[!($$->tree_info & OPT_CONTINUE)])):
  F_INC_NEQ_LOOP(F_VAL_LVAL(0, $0), $1);
F_FOR(F_INC(0, *), ':'(1[!($$->tree_info & OPT_CONTINUE)], -)):
  F_INC_NEQ_LOOP(F_VAL_LVAL(0, $0), $1);
F_FOR(F_INC(0, *), ':'(1[!($$->tree_info & OPT_CONTINUE)],
		       2[!($$->tree_info & OPT_CONTINUE)])):
  F_INC_NEQ_LOOP(F_VAL_LVAL(0, $0), F_COMMA_EXPR($1, $2));

F_FOR(F_POST_INC(0, *), -):
  F_INC_NEQ_LOOP(F_VAL_LVAL(1, $0), -);
F_FOR(F_POST_INC(0, *), ':'(-, 1[!($$->tree_info & OPT_CONTINUE)])):
  F_INC_NEQ_LOOP(F_VAL_LVAL(1, $0), $1);
F_FOR(F_POST_INC(0, *), ':'(1[!($$->tree_info & OPT_CONTINUE)], -)):
  F_INC_NEQ_LOOP(F_VAL_LVAL(1, $0), $1);
F_FOR(F_POST_INC(0, *), ':'(1[!($$->tree_info & OPT_CONTINUE)],
		            2[!($$->tree_info & OPT_CONTINUE)])):
  F_INC_NEQ_LOOP(F_VAL_LVAL(1, $0), F_COMMA_EXPR($1, $2));

F_FOR(F_DEC(0, *), -):
  F_DEC_NEQ_LOOP(F_VAL_LVAL(0, $0), -);
F_FOR(F_DEC(0, *), ':'(-, 1[!($$->tree_info & OPT_CONTINUE)])):
  F_DEC_NEQ_LOOP(F_VAL_LVAL(0, $0), $1);
F_FOR(F_DEC(0, *), ':'(1[!($$->tree_info & OPT_CONTINUE)], -)):
  F_DEC_NEQ_LOOP(F_VAL_LVAL(0, $0), $1);
F_FOR(F_DEC(0, *), ':'(1[!($$->tree_info & OPT_CONTINUE)],
		       2[!($$->tree_info & OPT_CONTINUE)])):
  F_DEC_NEQ_LOOP(F_VAL_LVAL(0, $0), F_COMMA_EXPR($1, $2));

F_FOR(F_POST_DEC(0, *), -):
  F_DEC_NEQ_LOOP(F_VAL_LVAL(-1, $0), -);
F_FOR(F_POST_DEC(0, *), ':'(-, 1[!($$->tree_info & OPT_CONTINUE)])):
  F_DEC_NEQ_LOOP(F_VAL_LVAL(-1, $0), $1);
F_FOR(F_POST_DEC(0, *), ':'(1[!($$->tree_info & OPT_CONTINUE)], -)):
  F_DEC_NEQ_LOOP(F_VAL_LVAL(-1, $0), $1);
F_FOR(F_POST_DEC(0, *), ':'(1[!($$->tree_info & OPT_CONTINUE)],
			    2[!($$->tree_info & OPT_CONTINUE)])):
  F_DEC_NEQ_LOOP(F_VAL_LVAL(-1, $0), F_COMMA_EXPR($1, $2));

F_FOR(0, ':'(1, F_CAST[$$->type == void_type_string](2, *))):
  F_FOR($0, ':'($1, $2));

F_FOR(0 = F_APPLY(1 = F_CONSTANT
		  [$$->u.sval.type == T_FUNCTION]
		  [$$->u.sval.subtype == FUNCTION_BUILTIN],
                  2),
      4 = ':'(3, *)):
{
  node **last;

  /* Last is a pointer to the place where the incrementor is in the
   * tree. This is needed so we can nullify this pointer later and
   * free the rest of the tree
   */
  last = &_CDR($4);
  tmp1 = *last;

  /* We're not interested in casts to void */
  while(tmp1 &&
	( (tmp1->token == F_CAST && tmp1->type == void_type_string) ||
	  tmp1->token == F_POP_VALUE))
  {
    last = &_CAR(tmp1);
    tmp1 = *last;
  }

  /* If there is an incrementor, and it is one of x++, ++x, x-- or ++x */
  if(tmp1 && (tmp1->token == F_INC ||
	      tmp1->token == F_POST_INC ||
	      tmp1->token == F_DEC ||
	      tmp1->token == F_POST_DEC))
  {
    node **arg1, **arg2;
    int oper;
    int inc;
    int token;

    /* does it increment or decrement ? */
    inc = (tmp1->token==F_INC || tmp1->token==F_POST_INC);

    /* for(; arg1 oper arg2; z ++) p; */

    if($1->u.sval.u.efun->function == f_gt)
      oper = F_GT;
    else if($1->u.sval.u.efun->function == f_ge)
      oper = F_GE;
    else if($1->u.sval.u.efun->function == f_lt)
      oper = F_LT;
    else if($1->u.sval.u.efun->function == f_le)
      oper = F_LE;
    else if($1->u.sval.u.efun->function == f_ne)
      oper = F_NE;
    else
      goto next_for_opt;

    if(count_args($2) != 2)
      goto next_for_opt;

    arg1 = my_get_arg(&_CDR($0), 0);
    arg2 = my_get_arg(&_CDR($0), 1);

    /* it was not on the form for(; x op y; z++) p; */
    if(!node_is_eq(*arg1, CAR(tmp1)) || /* x == z */
       depend_p(*arg2, *arg2) ||	/* does y depend on y? */
       depend_p(*arg2, *arg1) ||	/* does y depend on x? */
       depend_p(*arg2, $3) ||		/* does y depend on p? */
       depend_p(*arg2, tmp1))		/* does y depend on z? */
    {
      /* it was not on the form for(; x op y; z++) p; */
      if(!node_is_eq(*arg2, CAR(tmp1)) || /* y == z */
	 depend_p(*arg1, *arg2) ||	/* does x depend on y? */
	 depend_p(*arg1, *arg1) ||	/* does x depend on x? */
	 depend_p(*arg1, $3) ||		/* does x depend on p? */
	 depend_p(*arg1, tmp1))		/* does x depend on z? */
      {
	/* it was not on the form for(; x op y; y++) p; */
	goto next_for_opt;
      }else{
	node **tmparg;
	/* for(; x op y; y++) p; -> for(; y op^-1 x; y++) p; */
	
	switch(oper)
	{
	case F_LT: oper = F_GT; break;
	case F_LE: oper = F_GE; break;
	case F_GT: oper = F_LT; break;
	case F_GE: oper = F_LE; break;
	}
	    
	tmparg = arg1;
	arg1 = arg2;
	arg2 = tmparg;
      }
    }

    if(inc)
    {
      if(oper == F_LE) {
	ADD_NODE_REF2(*arg2,
	  tmp3 = mkopernode("`+", *arg2, mkintnode(1));
	);
      } else if(oper == F_LT) {
	ADD_NODE_REF2(*arg2,
	  tmp3 = *arg2;
	);
      } else
	goto next_for_opt;
    }else{
      if(oper == F_GE) {
	ADD_NODE_REF2(*arg2,
	  tmp3 = mkopernode("`-", *arg2, mkintnode(1));
	);
      } else if(oper == F_GT) {
	ADD_NODE_REF2(*arg2,
	  tmp3 = *arg2;
	);
      } else
	goto next_for_opt;
    }
    ADD_NODE_REF(*last);

    if(oper == F_NE)
    {
      if(inc)
	token = F_INC_NEQ_LOOP;
      else
	token = F_DEC_NEQ_LOOP;
    }else{
      if(inc)
	token = F_INC_LOOP;
      else
	token = F_DEC_LOOP;
    }

    ADD_NODE_REF2(*arg1,
    ADD_NODE_REF2($3,
      tmp2 = mknode(token, mknode(F_VAL_LVAL, tmp3, *arg1), $3);
    ));

#ifdef SHARED_NODES
    sub_node(tmp1);
#endif /* SHARED_NODES */
    if(inc)
    {
      tmp1->token = F_DEC;
    }else{
      tmp1->token = F_INC;
    }
#ifdef SHARED_NODES
    tmp1->hash = hash_node(tmp1);
    tmp1->node_info |= OPT_DEFROSTED;
    add_node(tmp1);
#endif /* SHARED_NODES */

    tmp1 = mknode(F_COMMA_EXPR, mkcastnode(void_type_string, tmp1), tmp2);
    goto use_tmp1;
  }
 next_for_opt:
  ;
}
;


// Prepare for the return if true optimization.
'?'(0 = +[ node_is_tossable($$) ], ':'( F_RETURN($0, *), 1)) :
{
  struct pike_string *type = $0->type;
  struct pike_string *tmpname;
  int tmpvar;
  void add_local_name(struct pike_string *,struct pike_string *, node *);

  MAKE_CONSTANT_SHARED_STRING(tmpname, " ");
  tmpvar = islocal(tmpname);
  if(tmpvar == -1)
  {
    add_ref(mixed_type_string);
    add_local_name(tmpname, mixed_type_string, 0);
    tmpvar = islocal(tmpname);
  }
  free_string(tmpname);
  $$ = mknode('?', mknode(F_ASSIGN, $0, mklocalnode(tmpvar,0)),
	      mknode(':',mknode(F_RETURN,
				mksoftcastnode(type, mklocalnode(tmpvar,0)),
				0),
		     $1));
}
;
