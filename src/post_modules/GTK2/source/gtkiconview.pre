require gtk26;

class GTK2.IconView;
inherit GTK2.Container;

//! GTK2.IconView provides an alternative view on a list model.  It
//! displays the model as a grid of icons with labels.  Like GTK2.TreeView,
//! it allows to select one or multiple items (depending on the selection
//! mode).  In addition to seleciton with the arrow keys, GTK2.IconView
//! supports rubberband selections, which is controlled by dragging the
//! pointer.

//! Properties:
//! int column-spacing
//! int columns
//! int item-width
//! int margin
//! int markup-column
//! GTK2.TreeModel model
//! int orientation
//! int pixbuf-column
//! int row-spacing
//! int selection-mode
//! int spacing
//! int text-column
//! <p>
//! Style properties:
//! int selection-box-alpha
//! GDK2.Color selection-box-color

signal activate_cursor_item;
signal item_activated;
signal move_cursor;
signal select_all;
signal select_cursor_item;
signal selection_changed;
signal set_scroll_adjustments;
signal toggle_cursor_item;
signal unselect_all;

void create(?GTK2.TreeModel model)
//! Creates a new GTK2.IconView widget
//! Not implemented yet.
{
  pgtk_verify_not_inited();
  pgtk_verify_setup();
  if (args) {
    struct object *o1;
    get_all_args("create",args,"%o",&o1);
    my_pop_n_elems(args);
    THIS->obj=G_OBJECT(gtk_icon_view_new_with_model(
			GTK_TREE_MODEL(get_gobject(o1))));
  } else {
    THIS->obj=G_OBJECT(gtk_icon_view_new());
  }
  pgtk__init_this_object();
}

void set_model(GTK2.TreeModel model);
//! Sets the model.

GTK2.TreeModel get_model();
//! Gets the model.

void set_text_column(int column);
//! Sets the column with text to be column.

int get_text_column();
//! Returns the column with text.

void set_markup_column(int column);
//! Sets the column with markup information to be column.

int get_markup_column();
//! Returns the column with markup text.

void set_pixbuf_column(int column);
//! Sets the column with pixbufs to be column.

int get_pixbuf_column();
//! Returns the column with pixbufs.

GTK2.TreePath get_path_at_pos(int x, int y)
//! Finds the path at the point(x,y) relative to widget coordinates.
{
  pgtk_verify_inited();
  {
    int x,y;
    GtkTreePath *path;
    get_all_args("get_path_at_pos",args,"%i%i",&x,&y);
    my_pop_n_elems(args);
    path=gtk_icon_view_get_path_at_pos(GTK_ICON_VIEW(THIS->obj),x,y);
    push_gobjectclass(path,pgtk_tree_path_program);
  }
}

void set_selection_mode(int mode);
//! Sets the selection mode.
//! One of CONST(GTK_SELECTION_)

int get_selection_mode();
//! Gets the selection mode.

void set_orientation(int orientation);
//! Sets the orientation property which determines whether the labels
//! are drawn beside the icons instead of below.
//! One of CONST(GTK_ORIENTATION_)

int get_orientation();
//! Returns the value of the orientation property.

void set_columns(int columns);
//! Sets the columns property which determines in how many columns the
//! icons are arranged.  If columns is -1, the number of columns will
//! be chosen automatically to fill the available area.

int get_columns();
//! Returns the value of the columns property.

void set_item_width(int item_width);
//! Sets the item-width property which specifies the width to use for
//! each item.  If it is set to -1, the icon view will automatically
//! determine a suitable item size.

int get_item_width();
//! Returns the value of the item-width property.

void set_spacing(int spacing);
//! Sets the spacing property which specifies the space which is inserted
//! between the cells (i.e. the icon and the text) of an item.

int get_spacing();
//! Returns the value of the spacing property

void set_row_spacing(int row_spacing);
//! Sets the row-spacing property which specifies the space which is
//! inserted between the rows of the icon view.

int get_row_spacing();
//! Returns the value of the row-spacing property.

void set_column_spacing(int column_spacing);
//! Sets the column-spacing property which specifies the space which is
//! inserted between the columns of the icon view.

int get_column_spacing();
//! Returns the value of the column-spacing property.

void set_margin(int margin);
//! Sets the margin property.

int get_margin();
//! Returns the value of the margin property.

void select_path(GTK2.TreePath path)
//! Selects the row at path
{
  pgtk_verify_inited();
  {
    struct object *o1;
    get_all_args("select_path",args,"%o",&o1);
    gtk_icon_view_select_path(GTK_ICON_VIEW(THIS->obj),
			(GtkTreePath *)get_gobject(o1));
  }
  RETURN_THIS();
}

void unselect_path(GTK2.TreePath path)
//! Unselects the row at path
{
  pgtk_verify_inited();
  {
    struct object *o1;
    get_all_args("unselect_path",args,"%o",&o1);
    gtk_icon_view_unselect_path(GTK_ICON_VIEW(THIS->obj),
			(GtkTreePath *)get_gobject(o1));
  }
  RETURN_THIS();
}

int path_is_selected(GTK2.TreePath path)
//! Returns true if the icon pointed to by path is currently selected.
//! If icon does not point to a valid location, false is returned.
{
  pgtk_verify_inited();
  {
    struct object *o1;
    get_all_args("path_is_selected",args,"%o",&o1);
    my_pop_n_elems(args);
    push_int(gtk_icon_view_path_is_selected(GTK_ICON_VIEW(THIS->obj),
			(GtkTreePath *)get_gobject(o1)));
  }
}

array(GTK2.TreePath) get_selected_items()
//! Creates a list of paths of all selected items.
//! Not implemented yet.
{
  pgtk_verify_inited();
  {
    GList *gl,*g2;
    int i=0;
    gl=g2=gtk_icon_view_get_selected_items(GTK_ICON_VIEW(THIS->obj));
    while (g2) {
      push_gobjectclass(g2->data,pgtk_tree_path_program);
      i++;
      g2=g_list_next(g2);
    }
    f_aggregate(i);
/*    g_list_foreach(list,gtk_tree_path_free,NULL); */
    g_list_free(gl);
  }
}

void select_all();
//! Selects all the icons.  This widget must have its selection
//! mode set to GTK2.SELECTION_MULTIPLE.

void unselect_all();
//! Unselects all the icons.

void item_activated(GTK2.TreePath path)
//! Activates teh item determined by path.
{
  pgtk_verify_inited();
  {
    struct object *o1;
    get_all_args("item_activated",args,"%o",&o1);
    gtk_icon_view_item_activated(GTK_ICON_VIEW(THIS->obj),
			(GtkTreePath *)get_gobject(o1));
  }
  RETURN_THIS();
}

endrequire;
