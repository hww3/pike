/* -*- C -*- */
class GTK2.Widget;
inherit GTK2.Object;

%{
#ifndef __NT__
#include <gdk/gdkx.h>
#else
#include <gdk/win32/gdkwin32.h>
#endif
#undef TWIN
#undef _GC
#define TWIN (GTK_WIDGET(THIS->obj)->window)
#define _GC(X) ((GdkGC*)get_gdkobject(X,gc))
%}

//! The basic widget, inherited (directly or indirectly) by all
//! widgets.  Thus, all functions and signals defined in this widget
//! works on all widgets.
//! <p>
//! One of the most important functions in this class is 'show',
//! it lets GTK know that we are done setting the attributes of the
//! widget, and it is ready to be displayed.  You may also use hide to
//! make it disappear again.  The order in which you show the widgets is
//! not important, but I suggest showing the toplevel window last so
//! the whole window pops up at once rather than seeing the individual
//! widgets come up on the screen as they're formed.  The children of a
//! widget (a window is a widget too) will not be displayed until the
//! window itself is show using the show() function.</p>

//! Properties:
//! int app-paintable
//! int can-default
//! int can-focus
//! int composite-child
//! int events (GdkEventMask)
//! int extension-events CONST(GDK_EXTENSION_EVENTS_)
//! int has-default
//! int has-focus
//! int height-request
//! int is-focus
//! string name
//! int no-show-all
//! GTK2.Container parent
//! int receives-default
//! int sensitive
//! GTK2.Style style
//! int visible
//! int width-request
//! <p>
//! Style Properties:
//! float cursor-aspect-ratio
//! GDK2.Color cursor-color
//! string focus-line-pattern
//! int focus-line-width
//! int focus-padding
//! int interior-focus
//! GDK2.Color secondary-cursor-color

signal show;
//! Called when the widget is shown
signal hide;
//! Called when the widget is hidden
signal map;
//! Called when the window associated with the widget is mapped
signal unmap;
//! Called when the window associated with the widget is unmapped
signal realize;
//! Called when the widget is realize.  Some methods cannot be used until the widget
//! has been realized, if you get assertion errors related to 'w->window' or similar,
//! this is probably the cause.
signal unrealize;
//! Called when the widget is unrealized.
signal size_request;
//! Called when the widget should calculate how big it wants to be
signal size_allocate;
//! Called when the widget gets the size it should be
signal state_changed;
signal parent_set;
//! Called when the parent widget is changed
signal style_set;
//! Called when the style is changed
signal event;
//! Called for all events
signal button_press_event;
//! Called when a mouse button is pressed
signal button_release_event;
//! Called when a mouse button is released
signal motion_notify_event;
//! Called when the mouse is moved inside the widget
signal delete_event;
//! Called when the user has request that the widget should be closed
signal destroy_event;
//! Called when the widget is destroyed
signal expose_event;
//! Called when the widget, or a part of the widget, gets an expose event
signal key_press_event;
//! Called when a keyboard key is pressed
signal key_release_event;
//! Called when a keyboard key is released
signal enter_notify_event;
//! Called when the mouse enters the widget
signal leave_notify_event;
//! Called when the mouse leaves the widget
signal configure_event;
//! The size, position or stacking order of the widget has changed
signal focus;
signal focus_in_event;
//! The keyboard focus has entered the widget
signal focus_out_event;
//! The keyboard focus has left the widget
signal map_event;
//! Called just before the 'map' signal
signal unmap_event;
//! Called just before the 'unmap' signal
signal property_notify_event;
//! Called when a property of the GDK window associated with the widget
//! is changed
signal selection_clear_event;
//! NYI
signal selection_request_event;
//! NYI
signal selection_notify_event;
//! NYI
signal selection_received;
//! NYI
signal selection_get;
//! NYI
signal proximity_in_event;
signal proximity_out_event;
signal drag_leave;
//! Called when the mouse leaves the widget while the user is dragging something
signal drag_begin;
//! Called when the drag is initiated, on the sending side
signal drag_end;
//! Called when the drag is finished, on the sending side
signal drag_data_delete;
//! Called when the data can be safely deleted (there is no need to use
//! this function in pigtk, it's all handled automatically)
signal drag_motion;
//! Called on the receiving side when the cursor is moved over the widget
//! while dragging something
signal drag_drop;
//! Called on the receiving side when the drop is initiated
signal drag_data_get;
//! Called on the sending side when the drop is initiated
signal drag_data_received;
//! Called on the receiving side when the drop is finished.
signal visibility_notify_event;
//! The widget has been mapped, unmapped, hidden, or otherwise
//! had it's visibility modified
signal client_event;
//! An event sent by another client application
signal no_expose_event;

signal accel_closures_changed;
signal can_activate_accel;
signal child_notify;
signal direction_changed;
signal event_after;
signal grab_focus;
signal grab_notify;
signal hierarchy_changed;
signal mnemonic_activate;
signal popup_menu;
signal screen_changed;
signal scroll_event;
signal show_help;
signal window_state_event;

/* TODO: Some functions left to implement */
void show();
//! Show the widget.  Most (almost all) widgets must be shown to be
//! visible on the screen.

void hide();
//! Hide the widget.

void show_all();
//! Show this widget, and all child widgets.
void hide_all();
//! Hide this widget, and all child widgets.

/*
int text_width(string text)
//! Returns the width, in pixels, the string would have if it was
//! written with the default font in the style object associated with
//! the widget.
{
  struct pike_string *s;
  get_all_args("text_width",args,"%S",&s);
  push_int(gdk_text_width(GTK_WIDGET(THIS->obj)->style->font,s->str,s->len));
}
*/

void add_accelerator(string accel_signal, GTK2.AccelGroup accel_group,
		int accel_key, int accel_mods, int accel_flags);
//! Installs an accelerator in accel_group that causes accel_signal to be
//! emitted if the accelerator is activated.  The signal must be of type
//! G_RUN_ACTION.

int remove_accelerator(GTK2.AccelGroup accel_group, int accel_key,
		int accel_mods);
//! Removes an accelerator.

void set_accel_path(string accel_path, GTK2.AccelGroup accel_group);
//! Sets up an accelerator in accel_group so whenever the key binding that is
//! defined for accel_path is pressed, this widget will be activated.

require gtk24;
int can_activate_accel(int signal_id);
//! Determines whether an accelerator that activates the signal signal_id can
//! currently be activated.
endrequire;

int activate();
//! For widgets that can be "activated" (buttons, menu items, etc.) this
//! functions activates them.  Activation is what happens when you press Enter
//! on a widget during key navigation.

int is_focus();
//! Determines if the widget is the focus widget within its toplevel.
//! (This does not mean that the HAS_FOCUS flag is necessarily set; HAS_FOCUS
//! will only be set if the toplevel widget additionally has the input focus.

void grab_focus();
//! Causes this widget to have the keyboard focus.  This widget must be a
//! focusable widget, such as a GTK2.Entry; something like GTK2.Frame won't
//! work.

void grab_default();
//! Causes this widget to become the default widget.

void set_name(string name);
//! Widgets can be named, which allows you to refer to them from a gtkrc file.
//! You can apply a style to widgets with a particular name in the gtkrc file.

string get_name();
//! Retrieves the name.

void set_sensitive(int sensitive);
//! Sets the sensitivity.  A widget is sensitive is the user can interact with
//! it.  Insensitive widgets are "grayed out" and the user can't interact with
//! them.  Insensitive widgets are known as "inactive", "disabled", or
//! "ghosted" in some other toolkits.

GDK2.Window get_parent_window();
//! Get the parent window.

int hide_on_delete();
//! Utility function

/*
void set_style(GTK2.Style style);
//! Sets the style.
*/

void set_direction(int dir);
//! Sets the reading direction.  This direction controls the primary direction
//! for widgets containing text, and also the direction in which the children
//! of the container are packed.  The ability to set the direction is present
//! in order so that correct localization into languages with right-to-left
//! reading directions can be done.  Generally, applications will let the
//! default reading direction present, except for containers where the
//! containers are arranged in an order that is explicitly visual rather than
//! logical (such as buttons for text justification).

int get_direction();
//! Gets the reading direction.

void shape_combine_mask(GDK2.Bitmap shape_mask, int offset_x, int offset_y)
//! Sets a shape for a widget's GDK2.Window.  This allows for transparent
//! window, etc.
{
  pgtk_verify_inited();
  {
    struct object *o1;
    gint x,y;
    get_all_args("shape_combine_mask",args,"%o%i%i",&o1,&x,&y);
    gtk_widget_shape_combine_mask(GTK_WIDGET(THIS->obj),
		(GdkBitmap *)get_gdkobject(o1,bitmap),x,y);
  }
  RETURN_THIS();
}

string path()
//! Obtains the full path.  The path is simply the name of a widget and all 
//! its parents in the container hierarchy, separated by periods.
{
  pgtk_verify_inited();
  {
    guint len;
    gchar *path;
    gtk_widget_path(GTK_WIDGET(THIS->obj),&len,&path,NULL);
    my_pop_n_elems(args);
    push_text(path);
  }
}

string class_path()
//! Same as path() but uses type rather than name.
{
  pgtk_verify_inited();
  {
    guint len;
    gchar *path;
    gtk_widget_class_path(GTK_WIDGET(THIS->obj),&len,&path,NULL);
    my_pop_n_elems(args);
    push_text(path);
  }
}

string get_composite_name();
//! Get the composite name.

void modify_style(GTK2.RcStyle style)
//! Modifies style values.
{
  pgtk_verify_inited();
  {
    struct object *o1;
    get_all_args("modify_style",args,"%o",&o1);
    gtk_widget_modify_style(GTK_WIDGET(THIS->obj),
		GTK_RC_STYLE(get_gobject(o1)));
  }
  RETURN_THIS();
}

GTK2.RcStyle get_modifier_style()
//! Returns the current modifier style.
{
  pgtk_verify_inited();
  my_pop_n_elems(args);
  push_gobject(gtk_widget_get_modifier_style(GTK_WIDGET(THIS->obj)));
}

void modify_fg(int state, ?GDK2.Color color)
//! Sets the foreground color of the widget in a particular state.
//! state is one of CONST(GTK_STATE_).
//! color can be omitted to undo the effect of a previous call.
{
  pgtk_verify_inited();
  {
    struct object *o1=NULL;
    int state;
    if (args==1)
      get_all_args("modify_fg",args,"%i",&state);
    else
      get_all_args("modify_fg",args,"%i%o",&state,&o1);
    gtk_widget_modify_fg(GTK_WIDGET(THIS->obj),
		state,(GdkColor *)get_gdkobject(o1,color));
  }
  RETURN_THIS();
}

void modify_bg(int state, ?GDK2.Color color)
//! Sets the background color of the widget in a particular state.
//! See modify_fg().
{
  pgtk_verify_inited();
  {
    struct object *o1=NULL;
    int state;
    if (args==1)
      get_all_args("modify_bg",args,"%i",&state);
    else
      get_all_args("modify_bg",args,"%i%o",&state,&o1);
    gtk_widget_modify_bg(GTK_WIDGET(THIS->obj),
		state,(GdkColor *)get_gdkobject(o1,color));
  }
  RETURN_THIS();
}

void modify_text(int state, ?GDK2.Color color)
//! Sets the text color of the widget in a particular state.
//! See modify_fg().
{
  pgtk_verify_inited();
  {
    struct object *o1=NULL;
    int state;
    if (args==1)
      get_all_args("modify_text",args,"%i",&state);
    else
      get_all_args("modify_text",args,"%i%o",&state,&o1);
    gtk_widget_modify_text(GTK_WIDGET(THIS->obj),
		state,(GdkColor *)get_gdkobject(o1,color));
  }
  RETURN_THIS();
}

void modify_base(int state, ?GDK2.Color color)
//! Sets the base color of the widget in a particular state.
//! See modify_fg().
{
  pgtk_verify_inited();
  {
    struct object *o1=NULL;
    int state;
    if (args==1)
      get_all_args("modify_base",args,"%i",&state);
    else
      get_all_args("modify_base",args,"%i%o",&state,&o1);
    gtk_widget_modify_base(GTK_WIDGET(THIS->obj),
		state,(GdkColor *)get_gdkobject(o1,color));
  }
  RETURN_THIS();
}

require pango;
void modify_font(Pango.FontDescription font)
//! Sets the font.
{
  pgtk_verify_inited();
  {
    struct object *o1;
    get_all_args("modify_font",args,"%o",&o1);
    gtk_widget_modify_font(GTK_WIDGET(THIS->obj),
		(PangoFontDescription *)get_pgobject(o1,ppango_font_description_program));
  }
  RETURN_THIS();
}

Pango.Context create_pango_context()
//! Creates a new Pango.Context with the appropriate colormap, font
//! description, and base direction for drawing text for this widget.
{
  pgtk_verify_inited();
  {
    PangoContext *pc=gtk_widget_create_pango_context(GTK_WIDGET(THIS->obj));
    my_pop_n_elems(args);
    push_gobject(pc);
  }
}

Pango.Layout create_pango_layout(string text)
//! Creates a new Pango.Layout with the appropriate colormap, font
//! description, and base direction for drawing text.
{
  pgtk_verify_inited();
  {
    PangoLayout *pl;
    const gchar *str;
    get_all_args("create_pango_layout",args,"%s",&str);
    my_pop_n_elems(args);
    pl=gtk_widget_create_pango_layout(GTK_WIDGET(THIS->obj),str);
    push_gobject(pl);
  }
}
endrequire;

GDK2.Pixbuf render_icon(string stock_id, int size, string detail)
//! A convenience function that uses the theme engine and rc file settings
//! to look up stock_id and render it to a pixbuf.  stock_id should be a
//! stock icon ID such as GTK2.STOCK_OPEN or GTK2.STOCK_OK.  size should be a
//! size such as GTK2.ICON_SIZE_MENU.  detail should be a string that identifies
//! the widget or code doing the rendering, so that theme engines can
//! special-case rendering for that widget or code.
//! <p>
//! The pixels in the returned GDK2.Pixbuf are shared with the rest of the
//! application and should not be modified.
{
  pgtk_verify_inited();
  {
    const gchar *stock_id,*detail;
    int size;
    GdkPixbuf *gp;
    get_all_args("render_icon",args,"%s%i%s",&stock_id,&size,&detail);
    my_pop_n_elems(args);
    gp=gtk_widget_render_icon(GTK_WIDGET(THIS->obj),stock_id,size,detail);
    push_gobject(gp);
  }
}

void queue_draw();
//! Equivalent to calling queue_draw_area() for the entire area of the widget.

void queue_draw_area(int x, int y, int width, int height);
//! Invalidates the rectangular area defined by x,y,width,height by calling
//! GDK2.Window->invalidate_rect() on the widget's window and all its child
//! windows.  Once the main loop becomse idle (after the current batch of
//! events has been processed, roughly), the window will receive expose events
//! for the union of all regions that have been invalidated.

void set_scroll_adjustments(GTK2.Adjustment hadj, GTK2.Adjustment vadj);
//! For widgets that support scrolling, sets the scroll adjustments.  For
//! widgets that don't support scrolling, does nothing.  Widgets that don't
//! support scrolling can be scrolled by placing them in a W(Viewport), which
//! does support scrolling.

mixed style_get_property(string name)
//! Gets the value of the style property called name.
{
  pgtk_verify_inited();
  {
    GValue v;
    const gchar *name;
    get_all_args("style_get_property",args,"%s",&name);
    my_pop_n_elems(args);
//    gtk_widget_style_get_property(GTK_WIDGET(THIS->obj),name,&v);
    push_int(0);
//    push_gvalue_r(&v,G_VALUE_TYPE(&v));
/*
    switch (G_VALUE_TYPE(&v)) {
      case G_TYPE_UCHAR:
	push_int(g_value_get_uchar(&v));
	break;
      case G_TYPE_CHAR:
	push_int(g_value_get_char(&v));
	break;
      case G_TYPE_INT:
	push_int(g_value_get_int(&v));
	break;
      case G_TYPE_UINT:
	push_int(g_value_get_uint(&v));
	break;
      case G_TYPE_LONG:
	push_int(g_value_get_long(&v));
	break;
      case G_TYPE_ULONG:
	push_int(g_value_get_ulong(&v));
	break;
      case G_TYPE_INT64:
	push_int(g_value_get_int64(&v));
	break;
      case G_TYPE_UINT64:
	push_int(g_value_get_uint64(&v));
	break;
      case G_TYPE_FLOAT:
	push_float(g_value_get_float(&v));
	break;
      case G_TYPE_DOUBLE:
	push_float(g_value_get_double(&v));
	break;
      case G_TYPE_STRING:
	PGTK_PUSH_GCHAR(g_value_get_string(&v));
	break;
      case G_TYPE_OBJECT:
	push_gobject(g_value_get_object(&v));
	break;
      default:
	fprintf(stderr,"Unsupported type %d\n",G_VALUE_TYPE(&v));
	break;
    }
*/
  }
}

void child_notify(string prop);
//! Emits a "child-notify" signal for the child property prop.

void freeze_child_notify();
//! Stops emission of "child-notify" signals.  The signals are queued until
//! thaw_child_notify() is called on the widget.

GTK2.Widget get_parent();
//! Returns the parent container.

require gtk22;
GTK2.Clipboard get_clipboard(GDK2.Atom selection)
//! Returns the clipboard object for the given selection.
{
  pgtk_verify_inited();
  {
    struct object *o1;
    GtkClipboard *gcl;
    get_all_args("get",args,"%o",&o1);
    my_pop_n_elems(args);
    gcl=gtk_widget_get_clipboard(GTK_WIDGET(THIS->obj),get_gdkatom(o1));
    push_gobject(gcl);
  }
}

GDK2.Window get_root_window();
//! Get the root window.
endrequire;

void set_size_request(int width, int height);
//! Sets the minimum size of a widget; that is, the widget's size request will
//! be width by height.  You can use this function to force a widget to be
//! either larger or smaller than it normally would be.
//! <p>
//! In most cases, set_default_size() is a better choice for toplevel windows
//! than this function; setting the default size will still allow users to
//! shrink the window.  Setting the size request will force them to leave the
//! window at least as large as the size request.  When dealing with window
//! sizes, set_geometry_hints() can be a useful function as well.
//! <p>
//! Note the inherent danger of setting any fixed size - themes, translations
//! into other languages, different fonts, and user action can all change the
//! appropriate size for a given widget.  So, it's basically impossible to
//! hardcode a size that will always be correct.
//! <p>
//! The size request of a widget is the smallest size a widget can accept while
//! still functioning well and drawing itself correctly.  However in some
//! strange cases a widget may be allocated less than its requested size, and
//! in many cases a widget may be allocated more space than it request.
//! <p>
//! If the size request in a given direction is -1 (unset), then the "natural"
//! size request of the widget will be used instead.
//! <p>
//! Widgets can't actually be allocated a size less than 1x1, but you can pass
//! 0,0 to this function to mean "as small as possible".

void thaw_child_notify();
//! Reverts the effect of a previous call to freeze_child_notify().

require gtk24;
void set_no_show_all(int no_show_all);
//! Sets the "no-show-all" property, which determines whether calls to
//! show_all() and hide_all() will affect this widget.

int get_no_show_all();
//! Returns the current value of the "no-show-all" property.

array(GTK2.Widget) list_mnemonic_lables()
//! Returns a list of the widgets, normally labels, for which this widget is
//! the target of a mnemonic.
{
  pgtk_verify_inited();
  {
    GList *gl,*g2;
    int i=0;
    gl=g2=gtk_widget_list_mnemonic_labels(GTK_WIDGET(THIS->obj));
    while (g2) {
      g_object_ref(g2->data);
      push_gobject(g2->data);
      i++;
      g2=g_list_next(g2);
    }
    f_aggregate(i);
    g_list_free(gl);
  }
}

void add_mnemonic_label(GTK2.Widget label);
//! Adds a widget to the list of mnemonic lables for this widget.  Note the
//! list of mnemonic labels for the widget is cleared when the widget is
//! destroyed, so the caller must make sure to update it's internal state at
//! this point as well, by using a connection to the destroy signal.

void remove_mnemonic_label(GTK2.Widget label);
//! Removes a widget from the list of mnemonic labels for this widget.
endrequire;

