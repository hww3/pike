/* cipher.cmod -*- c -*- */

#include "global.h"
RCSID("$Id: cipher.cmod,v 1.10 2003/08/05 18:15:23 nilsson Exp $");
#include "interpret.h"
#include "svalue.h"

/* For this_object() */
#include "object.h"
#include "module_support.h"

#include "nettle_config.h"

#ifdef HAVE_LIBNETTLE

#include "nettle.h"

#include <nettle/aes.h>
#include <nettle/cast128.h>
#include <nettle/serpent.h>
#include <nettle/twofish.h>
#include <nettle/nettle-meta.h>

#include <assert.h>
#include <stdio.h>
#include <stdarg.h>

#if 0
static void
werror(const char *format, ...)
{
  va_list args;

  va_start(args, format);
  vfprintf(stderr, format, args);
  va_end(args);
}
#else
#define werror(x)
#endif

/*! @module Nettle
 */

/* Checks if a key is acceptable. STR can be NULL, in which case only
 * the length is checked. */
typedef int check_key_func(ptrdiff_t len, const char *str);

/*! @class CipherInfo
 *!
 *! Represents information about a cipher algorithm, such as
 *! name, key size, and block size.
 */
PIKECLASS CipherInfo
{
  CVAR const struct nettle_cipher *meta;
  CVAR check_key_func *check_key;
  
  /*! @decl string name(void)
   *!
   *! @returns
   *!   A human readable name for the algorithm.
   */
  PIKEFUN string name()
    {
      if (!THIS->meta)
	Pike_error("CipherInfo not properly initialized.\n");

      push_string(make_shared_string(THIS->meta->name));
    }

  /*! @decl string key_size(void)
   *!
   *! @returns
   *!   The recommended key size for the cipher.
   */
  PIKEFUN int key_size()
    {
      if (!THIS->meta)
	Pike_error("CipherInfo not properly initialized.\n");

      push_int(THIS->meta->key_size);
    }

  /*! @decl int check_key_size(void)
   *!
   *! @returns
   *!   1 if the given key size is acceptable for the cipher,
   *!   otherwise 0.
   */
  PIKEFUN int check_key_size(int size)
    {
      if (!THIS->meta)
	Pike_error("CipherInfo not properly initialized.\n");

      push_int(THIS->check_key(size, NULL));
    }
  
  /*! @decl string block_size(void)
   *!
   *! @returns
   *!   The block size of the cipher (or 0 for stream ciphers).
   */
  PIKEFUN int block_size()
    {
      if (!THIS->meta)
	Pike_error("CipherInfo not properly initialized.\n");

      push_int(THIS->meta->block_size);
    }
  INIT
    {
      THIS->meta = NULL;
      THIS->check_key = NULL;
    }
}
/*! @endclass
 */

#define GET_INFO(o) \
((struct CipherInfo_struct *) get_storage((o), CipherInfo_program))

/*! @class CipherState
 *!
 *! Base class for hashing contexts.
 */
PIKECLASS CipherState
{
  INHERIT CipherInfo;
  CVAR nettle_crypt_func crypt;
  CVAR void *ctx;
  
  /* FIXME: Create should copy state from the other object, if
   * provided. */

  /*! @decl CipherState set_encrypt_key(string key)
   *!
   *! Initializes the object for encryption.
   */
  PIKEFUN object set_encrypt_key(string key)
    {
      struct CipherInfo_struct *info = GET_INFO(this_object());
      assert(info);
      
      if (!THIS->ctx || !info->meta)
	Pike_error("CipherState not properly initialized.\n");

      NO_WIDE_STRING(key);
      if (!info->check_key(key->len, key->str))
	Pike_error("Invalid key.\n");
      
      info->meta->set_encrypt_key(THIS->ctx, key->len, key->str);
      THIS->crypt = info->meta->encrypt;

      push_object(this_object());
    }

  /*! @decl CipherState set_decrypt_key(string key)
   *!
   *! Initializes the object for decryption.
   */
  PIKEFUN object set_decrypt_key(string key)
    {
      struct CipherInfo_struct *info = GET_INFO(this_object());
      assert(info);
      
      if (!THIS->ctx || !info->meta)
	Pike_error("CipherState not properly initialized.\n");

      NO_WIDE_STRING(key);
      if (!info->check_key(key->len, key->str))
	Pike_error("Invalid key.\n");
      
      info->meta->set_decrypt_key(THIS->ctx, key->len, key->str);
      THIS->crypt = info->meta->decrypt;

      push_object(this_object());
    }

  /*! @decl string crypt(string data)
   *!
   *! Encrypts or decrypts data, using the current key.
   *!
   *! @param data
   *!   For block ciphers, data must be an integral number of blocks.
   *!
   *! @returns
   *!   The encrypted or decrypted data.
   */

  PIKEFUN string crypt (string data)
    {
      struct CipherInfo_struct *info = GET_INFO(this_object());
      struct pike_string *s;
      assert(info);
      
      if (!THIS->ctx || !THIS->crypt|| !info->meta)
	Pike_error("CipherState not properly initialized.\n");

      NO_WIDE_STRING(data);

      if (info->meta->block_size
	  && (data->len % info->meta->block_size))
	Pike_error("Data must be an integral number of blocks.\n");

      s = begin_shared_string(data->len);

      THIS->crypt(THIS->ctx, data->len, s->str, data->str);
      push_string(end_shared_string(s));      
    }

  INIT
    {
      THIS->ctx = NULL;
      THIS->crypt = NULL;
    }

  EXIT
    {
      if (THIS->ctx && Pike_fp->current_object->prog)
      {
	struct CipherInfo_struct *info = GET_INFO(this_object());
	assert(info);
	assert(info->meta);
	memset(THIS->ctx, 0, info->meta->context_size);
      }
    }
}
/*! @endclass CipherState */

static int
AES_check_key(ptrdiff_t len, const char *key)
{
  return (len == 16 || len == 24 || len == 32);
}

/*! @class AES_Info
 *!
 *! Internal mixin class, intended to be multiply inherited
 *! together with CipherInfo. */

PIKECLASS AES_Info
{
  INIT
    {
      struct CipherInfo_struct *CipherInfo = GET_INFO(this_object());

      if (CipherInfo && !CipherInfo->meta)
      {
	CipherInfo->meta = &nettle_aes256;
	CipherInfo->check_key = &AES_check_key;
      }
    }
}

/*! @endclass AES_Info */

/*! @class AES_State
 *!
 *! State for AES encyption
 */
PIKECLASS AES_State
{
  INHERIT AES_Info;
  INHERIT CipherState;
  CVAR struct aes_ctx aes;

  INIT
    {
      struct CipherState_struct *state
	= (struct CipherState_struct *) get_storage(this_object(),
						    CipherState_program);

      assert(state);
      state->ctx = &THIS->aes;
    }
}
/*! @endclass AES_State */

static int
CAST128_check_key(ptrdiff_t len, const char *key)
{
  return (len>=CAST128_MIN_KEY_SIZE && len<=CAST128_MAX_KEY_SIZE);
}

/*! @class CAST128_Info
 *!
 *! Internal mixin class, intended to be multiply inherited
 *! together with CipherInfo. */

PIKECLASS CAST128_Info
{
  INIT
    {
      struct CipherInfo_struct *CipherInfo = GET_INFO(this_object());

      if (CipherInfo && !CipherInfo->meta)
      {
	CipherInfo->meta = &nettle_cast128;
	CipherInfo->check_key = &CAST128_check_key;
      }
    }
}

/*! @endclass CAST128_Info */

/*! @class CAST128_State
 *!
 *! State for CAST128 encyption
 */
PIKECLASS CAST128_State
{
  INHERIT CAST128_Info;
  INHERIT CipherState;
  CVAR struct cast128_ctx cast128;

  INIT
    {
      struct CipherState_struct *state
	= (struct CipherState_struct *) get_storage(this_object(),
						    CipherState_program);

      assert(state);
      state->ctx = &THIS->cast128;
    }
}
/*! @endclass CAST128_State */

static int
serpent_check_key(ptrdiff_t len, const char *key)
{
  return (len>=SERPENT_MIN_KEY_SIZE && len<=SERPENT_MAX_KEY_SIZE);
}

/*! @class Serpent_Info
 *!
 *! Internal mixin class, intended to be multiply inherited
 *! together with CipherInfo. */

PIKECLASS Serpent_Info
{
  INIT
    {
      struct CipherInfo_struct *CipherInfo = GET_INFO(this_object());

      if (CipherInfo && !CipherInfo->meta)
      {
	CipherInfo->meta = &nettle_serpent256;
	CipherInfo->check_key = &serpent_check_key;
      }
    }
}

/*! @endclass Serpent_Info */

/*! @class Serpent_State
 *!
 *! State for Serpent encyption
 */
PIKECLASS Serpent_State
{
  INHERIT Serpent_Info;
  INHERIT CipherState;
  CVAR struct serpent_ctx serpent;

  INIT
    {
      struct CipherState_struct *state
	= (struct CipherState_struct *) get_storage(this_object(),
						    CipherState_program);

      assert(state);
      state->ctx = &THIS->serpent;
    }
}
/*! @endclass Serpent_State */

static int
twofish_check_key(ptrdiff_t len, const char *key)
{
  return (len>=TWOFISH_MIN_KEY_SIZE && len<=TWOFISH_MAX_KEY_SIZE);
}

/*! @class Twofish_Info
 *!
 *! Internal mixin class, intended to be multiply inherited
 *! together with CipherInfo. */

PIKECLASS Twofish_Info
{
  INIT
    {
      struct CipherInfo_struct *CipherInfo = GET_INFO(this_object());

      if (CipherInfo && !CipherInfo->meta)
      {
	CipherInfo->meta = &nettle_twofish256;
	CipherInfo->check_key = &twofish_check_key;
      }
    }
}

/*! @endclass Twofish_Info */

/*! @class Twofish_State
 *!
 *! State for Twofish encyption
 */
PIKECLASS Twofish_State
{
  INHERIT Twofish_Info;
  INHERIT CipherState;
  CVAR struct twofish_ctx twofish;

  INIT
    {
      struct CipherState_struct *state
	= (struct CipherState_struct *) get_storage(this_object(),
						    CipherState_program);

      assert(state);
      state->ctx = &THIS->twofish;
    }
}
/*! @endclass Twofish_State */

/*! @endmodule Nettle */

void
cipher_init(void)
{
  INIT;
}

void
cipher_exit(void)
{
  EXIT;
}

#endif /* HAVE_LIBNETTLE */
