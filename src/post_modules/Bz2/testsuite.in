cond([[ master()->resolv("Bz2")->Deflate ]], [[

test_true([[Bz2.Inflate();]])
test_true([[Bz2.File();]])
define(test_codec,[[
  test_eq([[Bz2.Deflate()->finish($1)]],[[$2]])
  test_eq([[Bz2.Inflate()->inflate($2)]],[[$1]])
]])

dnl Some strings can be compressed to different strings,
dnl depending on Bz2 version. Test for both, then.

define(test_codec2,[[
  test_any([[
     string uncompressed=$1;
     array(string) vcompressed=$2;
     string result;
     
     foreach (vcompressed;;string compressed)
       if ((result=Bz2.Inflate()->inflate(compressed))!=uncompressed)
         error("Bz2 inflate failed:\n%O -> %O, expected %O\n",
	       compressed,result,uncompressed);

     result=Bz2.Deflate()->finish(uncompressed);
     if (search(vcompressed,result)==-1)
        error("Bz2 deflate failed:\n%O -> %O, expected any of %O\n",
	      uncompressed,result,vcompressed);

     return 1;
   ]],1)
]])
test_codec([[""]],[["BZh9\27rE8P\220\0\0\0\0"]])
test_codec([["x"]],[["BZh91AY&SYwK\260\24\0\0\0\0\200\0@ \0!\30F\202\356H\247\n\22\16\351v\2\200"]])
test_codec2([["x"*10000]],[[
 ({"BZh91AY&SY\270\b?\324\200\0\25\210\200\210\0\0@\0\b \0""0\314\5)\247\32\243b\243\305\334\221N\24$.\2\17\365\0",
   "BZh91AY&SY\270\b?\324\0\0\25\210\200\210\0\0@\0\b \0""0\314\5)\247\32\243b\243\305\334\221N\24$.\2\17\365\0"
 })]])
test_codec("x\0x",[["BZh91AY&SY\320Vo\310\0\0\0\300\200@\0\0@ \0!\0\202,]\311\24\341BCAY\277 "]])
test_codec2([[(string)enumerate(256)*3]],[[({"BZh91AY&SY\355\340k\314\200\0\1\177\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\260\1`\1/\377\365UH\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\23\t\200\0\0\0\0\0\0\0\0\0\0\0\0\0\23\0\211""0\0L\0\4\300\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\230\0&\0\2`\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\7\365\0\201\240\210*\14\203\241\bJ\24\205\241\210j\34\207\242\b\212$\211\242\210\252,\213\243\b\312""4\215\243\210\352<\217\244\t\nD\221\244\211*L\223\245\tJT\225\245\211j\\\227\246\t\212d\231\246\211\252l\233\247\t\312t\235\247\211\352|\237\250\n\n\204\241\250\212*\214\243\251\nJ\224\245\251\212j\234\247\252\n\212\244\251\252\212\252\254\253\253\n\312\264\255\253\212\352\274\257\254\13\n\304\261\254\213*\314\263\255\13J\324\265\300\240-\213j\334\267\256\13\212\344\271\256\213\252\354\273\257\13\312\364\275\257\213\352\374\277\277\306\1\201`\230""7\372\302""0\254""3\16\304""1,S\26\306""1\254s\36\310""2,\223&\312""2\254\263.\314""3,\323""6\316""3\254\363>\320""4-\23F\322""4\255""3N\324""5-SV\326""5\255s^\330""6-\223f\332""6\255\263n\334""7-\323v\336""7\255\363~\340""8.\23\206\342""8\256""3\216\344""9.S\226\346""9\256s\236\350:.\223\246\352:\256\263\256\354;.\323\266\356;\256\363\276\360</\23\306\362<\257""3\316\364=/S\326\366=\257s\336\370>/\223\346\372>\257\371\366}\337\207\345\372~\337\307\365\377\213\271\"\234(Hv\360""5\346\0",
"BZh91AY&SY\355\340k\314\0\0\1\177\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\260\1`\1/\377\365UP&\2`\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2L\0\23\0\1""0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1&\0\t\200\0\230\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\375@P$\r\4A_\362\14\203\241\bJ\24\205\241\217\375\rC\220\364A\21D\221""4Q\25E\221ta\31F\221\264q\35G\221\364\201!H\222""4\221%I\222t\241)J\222\264\261-K\222\364\301""1L\223""4\321""5M\223t\341""9N\223\264\361=O\223\365\1AP\224""5\21EQ\224u!IR\224\265""1MS\224\365AQT\225""5QUU\225uaYV\225\265q]W\225\365\201aX\226""5\221eY\226u\241iZ\226\265\261m[\226\365\301q\\\227""5\321u]\227u\341y^\227\265\361}_\227\366\1\201`\230""6\21\205a\230v!\211b\230\266""1\215c\230\366A\221d\231""6Q\225e\231va\231f\231\266q\235g\231\366\201\241h\232""6\221\245i\232v\241\251j\232\266\261\255k\232\366\301\261l\233""6\321\265m\233v\341\271n\233\266\361\275o\233\367\1\301p\234""7\21\305q\234w!\311r\234\267""1\315s\234\367A\321t\235""7Q\325u\235wa\331v\235\267q\335w\235\367\201\341x\236""7\221\345y\236w\241\351z\236\267\261\355{\236\367\301\361|\237""7\321\365}\237w\341\371~\237\267\361\375\177\205\334\221N\24$;x\32\363\0"
})]])
test_eq([[Bz2.BZ_RUN]],0)
test_eq([[Bz2.BZ_FLUSH]],1)
test_eq([[Bz2.BZ_FINISH]],2)

test_any([[

  string packed = "";
  string in_data = "";
  string out_data = "";
  Bz2.Deflate defl = Bz2.Deflate();
  Bz2.Inflate infl = Bz2.Inflate();
  int defl_chunk_size = 75000;
  int infl_chunk_size = 39324;
  int flush_intervall = 7;
  int i = 0;
  int j = 0;
  int flush_count = 0;

  in_data = random_string(2000000);
  
  while(i + defl_chunk_size < sizeof(in_data)){
    if(flush_count != 7){
      defl->feed(in_data[i..i + defl_chunk_size - 1]);
      flush_count++;
    }
    else{
      packed += defl->read(in_data[i..i + defl_chunk_size - 1]);
      flush_count = 0;
    }
    i += defl_chunk_size;
  }
  
  packed += defl->finish(in_data[i..sizeof(in_data) - 1]);
  
  while(j + infl_chunk_size < sizeof(packed))
  {
    out_data += infl->inflate(packed[j..j + infl_chunk_size - 1]);
    j += infl_chunk_size;
  }
  out_data += infl->inflate(packed[j..sizeof(packed)-1]);
  
  return(out_data == in_data);
 
]],1)

test_any([[

  string in_data = "";
  string out_data = "";
  Bz2.File write_file = Bz2.File();
  Bz2.File read_file = Bz2.File();
  
  in_data = "jglaksdjalsdkfjwoeiruwoiurbenrbwenrwikerhwkeurwhfksnASDFASJFKSDJFASIGHSFGAFD34535234523426FSFGSFDGSDRHTWGDASDFASDF";
  in_data = in_data * 100000;
  
  write_file->write_open("test_data_tmp.bz2");
  write_file->write(in_data);
  write_file->close();

  read_file->read_open("test_data_tmp.bz2");
  out_data = read_file->read();
  read_file->close();
  Stdio.recursive_rm("test_data_tmp.bz2");
  return(in_data == out_data);

]],1)

]])
