PROGRAM(menu_shell);

// A GTK.MenuShell is the abstract base class used to derive the
// W(Menu) and W(MenuBar) subclasses.

// <p>

// A GTK.MenuShell is a container of W(MenuItem) objects arranged in a
// list which can be navigated, selected, and activated by the user to
// perform application functions. A W(MenuItem) can have a submenu
// associated with it, allowing for nested hierarchical menus.

SIGNAL("deactivate","This signal is emitted when a menu shell is deactivated.");
SIGNAL("selection_done","This signal is emitted when a selection has been completed within a menu shell.");
SIGNAL("move_current", "An action signal which moves the current menu item in the direction specified by the third argument.");
SIGNAL("activate_current","An action signal that activates the current menu item within the menu shell.");
SIGNAL("cancel","An action signal which cancels the selection within the menu shell. Causes the selection_done signal to be emitted.");
INHERIT(container);

CLASSMEMBER(active, int);
// 1 if the menu shell is currently active.

COMPLEX_FUNCTION(append, widget);
NAME_ARGS(what);
// Adds a new W(MenuItem) to the end of the menu shell's item
// list. Same as 'add'.

COMPLEX_FUNCTION(prepend, widget);
NAME_ARGS(what);
// Add a menu item to the start of the widget (for a menu: top, for a
// bar: left)
COMPLEX_FUNCTION(insert, widget, int);
NAME_ARGS(what,where);
// Add a widget after the specified location
COMPLEX_FUNCTION(deactivate);
// Deactivates the menu shell. Typically this results in the menu
// shell being erased from the screen.
COMPLEX_FUNCTION(select_item, widget);
NAME_ARGS(menuitem);
// Selects the menu item from the menu shell.
COMPLEX_FUNCTION(activate_item, widget, int);
NAME_ARGS(menu_item, force_deactivate);
// Activates the menu item within the menu shell.

FUNCTION(children, "function(void:array(object))");
RETURNS(array(GTK.MenuItem));
// This function returns all children of the container
// as an array.
{
  GList *g;
  int n = 0;
  pop_n_elems(args);
  g = GTK_MENU_SHELL( THIS->obj )->children;
  while(g)
  {
    push_gtkobjectclass( GTK_OBJECT( g->data ), pgtk_menu_item_program );
    n++;
    g = g->next;
  }
  f_aggregate(n);
}
