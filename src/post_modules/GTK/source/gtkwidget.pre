PROGRAM(widget);
// The basic widget, inherited (directly or indirectly) by all
// widgets.  Thus, all functions and signals defined in this widget
// works on all widgets.
// <p>
// One of the most importat functions in this class is 'show',
// it lets GTK know that we are done setting the attributes of the
// widget, and it is ready to be displayed. You may also use hide to
// make it disappear again. The order in which you show the widgets is
// not important, but I suggest showing the toplevel window last so
// the whole window pops up at once rather than seeing the individual
// widgets come up on the screen as they're formed. The children of a
// widget (a window is a widget too) will not be displayed until the
// window itself is shown using the show() function.
SIGNAL("show", "Called when the widget is shown");
SIGNAL("hide", "Called when the widget is hidden");
SIGNAL("map",  "Called when the window associated with the widget is mapped");
SIGNAL("unmap", "Called when the window associated with the widget is unmapped");
SIGNAL("realize", "Called when the widget is realized. Some methods cannot be used until the widget has been realized, if you get assertion errors related to 'w->window' or similar, this is probably the cause.");
SIGNAL("unrealize", "Called when the widget is unrealized.");
SIGNAL("draw", "Called when the widget should draw itself.");
SIGNAL("draw_focus", "Called when the widget should draw itself, and a focus indicator around itself (or otherwise indicate that is has the keyboard focus)");
SIGNAL("draw_default", "Called when the widget should draw itself, and indicate that it's the default widget");
SIGNAL("add_accelerator", "Called when an accelarator (keyboard shortcut) is added to the widget");
SIGNAL("remove_accelerator", "Called when an accelerator (keyboard shortcut) is removed from the widget");
SIGNAL("size_request", "Called when the widget should calculate how big it want's to be");
SIGNAL("size_allocate", "Called when the widget get's the size it should be");
SIGNAL("state_changed", "");
SIGNAL("parent_set", "Called when the parent widget is changed");
SIGNAL("style_set", "Called when the style is changed");
SIGNAL("event", "Called for all events");
SIGNAL("button_press_event", "Called when a mouse button is pressed");
SIGNAL("button_release_event", "Called when a mouse button is released");
SIGNAL("motion_notify_event", "Called when the mouse is moved inside the widget");
SIGNAL("delete_event",  "Called when the user has requested that the widget should be closed");
SIGNAL("destroy_event", "Called when the widget is destroyed");
SIGNAL("expose_event",  "Called when the widget, or a part of the widget gets and expose event");
SIGNAL("key_press_event", "Called when a keyboard key is pressed");
SIGNAL("key_release_event", "Called when a keyboard key is released");
SIGNAL("enter_notify_event", "Called when the mouse enters the widget");
SIGNAL("leave_notify_event", "Called when the mouse leaves the widget");
SIGNAL("configure_event", "The size, position or stacking order of the widget has changed");
SIGNAL("focus_in_event", "The keyboard focus has entered the widget");
SIGNAL("focus_out_event", "The keyboard focus has left the widget");
SIGNAL("map_event", "Called just before the 'map' signal");
SIGNAL("unmap_event", "Called just before the 'unmap' signal");
SIGNAL("property_notify_event", "Called when a property of the GDK window associated with the widget is changed");
SIGNAL("selection_clear_event", "NYI");
SIGNAL("selection_request_event", "NYI");
SIGNAL("selection_notify_event", "NYI");
SIGNAL("selection_received", "NYI");
SIGNAL("proximity_in_event", "");
SIGNAL("proximity_out_event", "");
SIGNAL("drag_leave", "Called when the mouse leaves the widget while the user is dragging something");
SIGNAL("drag_begin", "Called when the drag is initiated, on the sending side");
SIGNAL("drag_end", "Called when the drag is finished, on the sending side");
SIGNAL("drag_data_delete", "Called when the data can be safely deleted (there is no need to use this function in pigtk, it's all handled automatically)");
SIGNAL("drag_motion", "Called on the receiving side when the cursor is moved over the widget while dragging something");
SIGNAL("drag_drop", "Called on the receiving side when the drop is initiated");
SIGNAL("drag_data_get", "Called on the sending side when the drop is initiated");
SIGNAL("drag_data_received", "Called on the receiving side when the drop is finished.");
SIGNAL("visibility_notify_event", "The widget has been mapped, unmapped, hidden, or otherwise had it's visibility modified");
SIGNAL("debug_msg", "");
SIGNAL("other_event", "");
SIGNAL("client_event", "An event sent by another client application");
SIGNAL("no_expose_event", "");

INHERIT(object);
/*  TODO: Some functions left to implement */
SIMPLE_FUNCTION(show);
// Show the widget. Most (almost all) widgets must be shown to be
// visible on the screen.

SUBWIDGET(parent, widget);
// Returns the parent of this widget, if any, if there is no parent
// 0 is returned.

FUNCTION(text_width, "function(string:int)");
NAME_ARGS(text);
// Returns the width, in pixels, the string would have if it was
// written with the default font in the style object assosiated with
// the widget. Currently, this is always a 8bit string, but that
// should hopefully change in the future. 
{
  struct pike_string *s;
  get_all_args("text_width", args, "%S", &s); 
  push_int(gdk_text_width(GTK_WIDGET( THIS->obj )->style->font,s->str,s->len));
}


#define TWIN  (GTK_WIDGET(THIS->obj)->window)
#define GC(X) ((GdkGC*)get_gdkobject(X,GC))

FUNCTION(set_background, "function(object:object)");
NAME_ARGS(background);
// Set the background color or image.
// The argument is either a GDK.Pixmap or a GDK.Color object.
// <br>NOTE: The widget must be realized before this function can be used
{
  struct object *o;
  get_all_args("set_background", args, "%o", &o);

  if(get_gdkobject(o,Pixmap))
    gdk_window_set_back_pixmap(TWIN, get_gdkobject(o,Pixmap), 0);
  else if(get_gdkobject(o,Color))
    gdk_window_set_background(TWIN, get_gdkobject(o,Color));

  RETURN_THIS();
}

FUNCTION(copy_area, "function(object,int,int,object,int,int,int,int:object)");
RETURNS(GTK.Widget);
ARGS(GDK.GC,int,int,GTK.Widget,int,int,int,int);
NAME_ARGS(gc,xdest,ydest,source,xsource,ysource,width,height);
// Copies the rectangle defined by xsource,ysource and width,height
// from the source widget, and places the results at xdest,ydest in
// the widget in which this function is called. 
// <br>NOTE: The widget must be realized before this function can be used
{
  struct object *gc, *source;
  GdkWindow *win;
  int xd, yd, xs, ys, w, h;
  get_all_args("copy_area",args, "%o%d%d%o%d%d%d%d", 
	       &gc, &xd, &yd, &source, &xs, &ys, &w, &h);

  if(get_gdkobject( source, Drawable ))
    win = get_gdkobject( source, Drawable );
  else
    win = GTK_WIDGET( get_gtkobject( source ) )->window;

  gdk_window_copy_area( TWIN, GC(gc), xd, yd, win, xs, ys, w, h);
  RETURN_THIS();
}

FUNCTION(get_gdkwindow, "function(void:object)");
RETURNS(GDK.Window);
// Return the GDK.Window associated with this widget, if any.
{
  my_pop_n_elems(args);
  if(GTK_WIDGET(THIS->obj)->window)
  {
    struct object *o;
    o = low_clone( pgtk_GdkWindow_program );
    call_c_initializers( o );
    /* ugly...*/
    ((struct object_wrapper *)o->storage)->obj=
      (void *)&GTK_WIDGET(THIS->obj)->window;
    ref_push_object( o );
  } else
    push_int(0);
}


FUNCTION(shape_combine_mask, "function(object,int,int:object)");
RETURNS(GTK.Widget);
ARGS(GDK.Bitmap,int,int);
NAME_ARGS(shape, xoffset,yoffset);
// Set the shape of the widget, or, rather, it's window, to that of
// the supplied bitmap. Notice how the window behind the example
// window can be seen because of the rather odd shape the example window has.
// TIMG: GTK.Window( GTK.WINDOW_TOPLEVEL )->add(GTK.Label("A rather Oddly shaped\n" "Window\n" "Indeed\n" "Or what do you\nthink?\n" "This text\n" "should\n" "be long enough"))->shape_combine_mask( GDK.Bitmap(Image.image(100,100,255,255,255)->rotate(10,0,0,0) ), 20,20)
// <br>NOTE: The widget must be realized before this function can be used
{
  struct object *m;
  int x, y;
  get_all_args("shape_combine", args, "%o%d%d", &m, &x, &y);
  gtk_widget_shape_combine_mask( GTK_WIDGET( THIS->obj ),
				 get_gdkobject(m,Bitmap), x, y);
  RETURN_THIS();
}

FUNCTION(xoffset, "function(void:int)")
// Returns the x position of the upper left corner relative to the
// widgets window in pixels. For widgets that have their own window
// this will most likely be 0.
{
  push_int( GTK_WIDGET( THIS->obj )->allocation.x );
}

FUNCTION(yoffset, "function(void:int)")
// Returns the y position of the upper left corner relative to the
// widgets window in pixels. For widgets that have their own window
// this will most likely be 0.
{
  push_int( GTK_WIDGET( THIS->obj )->allocation.y );
}

FUNCTION(xsize, "function(void:int)")
// Returns the width of the widget in pixels.
{
  push_int( GTK_WIDGET( THIS->obj )->allocation.width );
}

FUNCTION(ysize, "function(void:int)")
// Returns the height of the widget in pixels.
{
  push_int( GTK_WIDGET( THIS->obj )->allocation.height );
}

FUNCTION(allocation, "function(void:mapping)");
// Returns ([ "x":xoffset, "y":yoffset, "width":xsize, "height":ysize ])
{
  push_text( "x" );
  push_int( GTK_WIDGET( THIS->obj )->allocation.x );
  push_text( "y" );
  push_int( GTK_WIDGET( THIS->obj )->allocation.y );
  push_text( "width" );
  push_int( GTK_WIDGET( THIS->obj )->allocation.width );
  push_text( "height" );
  push_int( GTK_WIDGET( THIS->obj )->allocation.height );
  f_aggregate_mapping( 8 );
}

COMPLEX_FUNCTION(add_accelerator, string, accel_group, int, int, int);
NAME_ARGS(signal, group, key, modifiers, flags);
// Add an accelerator (keyboard shortcut).
// <p>
// Flag is one of CONST(GTK_ACCE)
// <br>
// The signal is the signal to invoke when the accelerator key is pressed.
// <br>
// The modifiers is a bitwise or of one or more of GDK.ShiftMask,
// GDK.LockMask, GDK.ControlMask, CONST(GDK_MOD).
// <br>
// The group is the accelerator group in which the accelerator should be added.
// <br>
// The key is the unicode code for the key to bind.

COMPLEX_FUNCTION(remove_accelerator, accel_group, int, int);
NAME_ARGS(group,key,modifiers);
// Remove an accelerator (keyboard shortcut).
// <p>
// The modifiers is a bitwise or of one or more of GDK.ShiftMask,
// GDK.LockMask, GDK.ControlMask, CONST(GDK_MOD).
// <br>
// The group is the accelerator group in which the accelerator should be added.
// <br>
// The key is the unicode code for the key to bind.

COMPLEX_FUNCTION(set_usize, int, int);
NAME_ARGS(xsize,ysize);
// Set the absolute size of the widget. It might resize itself anyway,
// but this size is used as is in most widgets. Beware of this
// function, it might produce unexpected results. 0 for any size means
// 'keep old size'. When setting sizes of wtoplevel windows, it is 
// preferable to use set_default_size

COMPLEX_FUNCTION(set_uposition, int, int);
NAME_ARGS(xpos,ypos);
// Set the absolute coordinates of the widget relative to it's parent.

COMPLEX_FUNCTION(set_name, string);
NAME_ARGS(name);
// Set the name of the widget. The name is used when the rc-file is
// parsed, you can also parse your own resources by calling
// GTK.parse_rc() with a resource string. <br>Example: <p>
// TODO
COMPLEX_FUNCTION(set_state, int);
NAME_ARGS(state);
// One of CONST(GTK_STATE).
// This function should normaly not be used directly.

COMPLEX_FUNCTION(set_sensitive, int);
NAME_ARGS(sensitivep);
// True (1) or false (0). If true, the widget can receive events,
// otherwise the user cannot interact with the widget. Most widgets
// are drawn 'greyed' or more dim when they are unsensitive.

string COMPLEX_FUNCTION(get_name);
// Returns the name set by set_name or the class name

FUNCTION(set_cursor, "function(int,void|object,void|object:object)");
ARGS(int|void,void|GDK.Color,void|GDK.Color);
NAME_ARGS(cursor_type, fg, bg);
// Change the widget cursor.<br>
// If no arguments are passed, restore the default cursor.<br>
// Both fg and bg must be specified if either one is.<br>
// <table border=0 cellpadding=3 cellspacing=0>
// CURS(GDK.Arrow)
// CURS(GDK.BasedArrowDown)
// CURS(GDK.BasedArrowUp)
// CURS(GDK.Boat)
// CURS(GDK.Bogosity)
// CURS(GDK.BottomLeftCorner)
// CURS(GDK.BottomRightCorner)
// CURS(GDK.BottomSide)
// CURS(GDK.BottomTee)
// CURS(GDK.BoxSpiral)
// CURS(GDK.CenterPtr)
// CURS(GDK.Circle)
// CURS(GDK.Clock)
// CURS(GDK.CoffeeMug)
// CURS(GDK.Cross)
// CURS(GDK.CrossReverse)
// CURS(GDK.Crosshair)
// CURS(GDK.DiamondCross)
// CURS(GDK.Dot)
// CURS(GDK.Dotbox)
// CURS(GDK.DoubleArrow)
// CURS(GDK.DraftLarge)
// CURS(GDK.DraftSmall)
// CURS(GDK.DrapedBox)
// CURS(GDK.Exchange)
// CURS(GDK.Fleur)
// CURS(GDK.Gobbler)
// CURS(GDK.Gumby)
// CURS(GDK.Hand1)
// CURS(GDK.Hand2)
// CURS(GDK.Heart)
// CURS(GDK.Icon)
// CURS(GDK.IronCross)
// CURS(GDK.LeftPtr)
// CURS(GDK.LeftSide)
// CURS(GDK.LeftTee)
// CURS(GDK.Leftbutton)
// CURS(GDK.LlAngle)
// CURS(GDK.LrAngle)
// CURS(GDK.Man)
// CURS(GDK.Middlebutton)
// CURS(GDK.Mouse)
// CURS(GDK.Pencil)
// CURS(GDK.Pirate)
// CURS(GDK.Plus)
// CURS(GDK.QuestionArrow)
// CURS(GDK.RightPtr)
// CURS(GDK.RightSide)
// CURS(GDK.RightTee)
// CURS(GDK.Rightbutton)
// CURS(GDK.RtlLogo)
// CURS(GDK.Sailboat)
// CURS(GDK.SbDownArrow)
// CURS(GDK.SbHDoubleArrow)
// CURS(GDK.SbLeftArrow)
// CURS(GDK.SbRightArrow)
// CURS(GDK.SbUpArrow)
// CURS(GDK.SbVDoubleArrow)
// CURS(GDK.Shuttle)
// CURS(GDK.Sizing)
// CURS(GDK.Spider)
// CURS(GDK.Spraycan)
// CURS(GDK.Star)
// CURS(GDK.Target)
// CURS(GDK.Tcross)
// CURS(GDK.TopLeftArrow)
// CURS(GDK.TopLeftCorner)
// CURS(GDK.TopRightCorner)
// CURS(GDK.TopSide)
// CURS(GDK.TopTee)
// CURS(GDK.Trek)
// CURS(GDK.UlAngle)
// CURS(GDK.Umbrella)
// CURS(GDK.UrAngle)
// CURS(GDK.Watch)
// CURS(GDK.Xterm)
// </table>
{
  GdkCursor *c;
  struct object *fg = NULL, *bg = NULL;
  int i;

  if(!args)
    i = -1;
  else if( args >= 3 )
    get_all_args("set_cursor", args, "%d%o%o", &i, &fg, &bg);
  else
    get_all_args("set_cursor", args, "%d", &i);

  if(i>255) 
    error("No such cursor\n");
  if( i >= 0 )
    c = gdk_cursor_new( i );
  else
    c = NULL;

#ifndef __NT__
  if( c && fg && bg )
  {
    XColor fgp, bgp;
    MEMSET(&fgp, 0, sizeof(fg) );
    MEMSET(&bgp, 0, sizeof(bg) );

    if( get_gdkobject( fg, Color ) )
      fgp.pixel = ((GdkColor *)get_gdkobject( fg, Color ))->pixel;
    if( get_gdkobject( bg, Color ) )
      bgp.pixel = ((GdkColor *)get_gdkobject( bg, Color ))->pixel;
    
    XRecolorCursor(((GdkCursorPrivate *)c)->xdisplay,
                   ((GdkCursorPrivate *)c)->xcursor,
                   &fgp, &bgp );
  }
#endif  
  gtk_object_set_data_full(THIS->obj,
                           "cursor_to_free",(void*)c,
                           (void*)gdk_cursor_destroy);
  gdk_window_set_cursor( TWIN, c );

  RETURN_THIS();
}
FUNCTION(set_bitmap_cursor, "function(object,object,object,object,int,int:object)");

ARGS(GDK.Bitmap,GDK.Bitmap,GDK.Color,GDK.Color,int,int);
NAME_ARGS(source,mask,fg,bg,xhot,yhot);
// xhot and yhot are the locations of the x and y hotspot relative to the
// upper left corner of the cursor image.
// Both bitmaps and both colors must be non-null.
{
  struct object *s, *m, *fg, *bg;
  int xh, yh;
  get_all_args("set_bitmap_cursor", args, "%o%o%o%o%d%d", 
	       &s,&m,&fg,&bg,&xh,&yh);
  gdk_window_set_cursor( TWIN,
		 gdk_cursor_new_from_pixmap( get_gdkobject( s, Pixmap ),
					     get_gdkobject( m, Bitmap ),
					     get_gdkobject( fg, Color),
					     get_gdkobject( bg, Color ),
					     xh,yh ) );
  RETURN_THIS();
}

SIMPLE_FUNCTION(unparent);
// Remove this widget from it's parent
SIMPLE_FUNCTION(realize);
// Realize this widget, and it's children, if nessesary
SIMPLE_FUNCTION(unrealize);
// Unrealize this widget, and it's children, if nessesary
SIMPLE_FUNCTION(queue_draw);
// Force a redraw of the widget
COMPLEX_FUNCTION(queue_draw_area, int,int,int,int);
NAME_ARGS(x,y,width,height);
// Force a redraw of part of the widget
SIMPLE_FUNCTION(queue_clear);
// Force a clear (and subsequent redraw) of the widget
COMPLEX_FUNCTION(queue_clear_area, int,int,int,int);
NAME_ARGS(x,y,width,height);
// Force a clear (and subsequent redraw) of part of the widget
SIMPLE_FUNCTION(ensure_style);
// Ensure that the widget has a style associated with it.
SIMPLE_FUNCTION(queue_resize);
// Force a allocation recalculation, followed by a redraw
SIMPLE_FUNCTION(show_now);
// Show this widget and do not return until it is visible.
SIMPLE_FUNCTION(hide);
// Hide this widget
SIMPLE_FUNCTION(show_all);
// Show this widget and all it's children
SIMPLE_FUNCTION(hide_all);
// Hide this widget and all it's children
SIMPLE_FUNCTION(map);
// Map the widget. Should normally not be called directly.
SIMPLE_FUNCTION(unmap);
// Unmap the widget. Should normally not be called directly.
SIMPLE_FUNCTION(activate);
// Activate the widget. This either activates the widget, if possible
// (as an example, buttons can be activated), or activates the default
// widget of it's parent (or it's parent, or it's parents parent
// etc.)

SIMPLE_FUNCTION(grab_focus);
// Grab the focus.
SIMPLE_FUNCTION(grab_default);
// Make this widget the default action for the parent widget
int COMPLEX_FUNCTION(intersect, GdkRectangle, GdkRectangle);
NAME_ARGS(area, intersection);
// Do an intersection with the area and place the result in
// 'intersection'.

COMPLEX_FUNCTION(reparent, widget);
NAME_ARGS(to);
// Change the parent of the widget.
COMPLEX_FUNCTION(popup, int,int);
NAME_ARGS(xpos,ypos);
// Map the widget at the specified coordinates.

COMPLEX_FUNCTION(add_events, int);
NAME_ARGS(events);
// Events is one or more of:
// GDK.ExposureMask, GDK.PointerMotionMask,
// GDK.PointerMotion_HINTMask, GDK.ButtonMotionMask,
// GDK.Button1MotionMask, GDK.Button2MotionMask,
// GDK.Button3MotionMask, GDK.ButtonPressMask, GDK.ButtonReleaseMask,
// GDK.KeyPressMask, GDK.KeyReleaseMask, GDK.EnterNotifyMask,
// GDK.LeaveNotifyMask, GDK.FocusChangeMask, GDK.StructureMask,
// GDK.PropertyChangeMask, GDK.VisibilityNotifyMask,
// GDK.ProximityInMask, GDK.ProximityOutMask and GDK.AllEventsMask

COMPLEX_FUNCTION(set_events, int);
NAME_ARGS(events);
// Events is one or more of:
// GDK.ExposureMask, GDK.PointerMotionMask,
// GDK.PointerMotion_HINTMask, GDK.ButtonMotionMask,
// GDK.Button1MotionMask, GDK.Button2MotionMask,
// GDK.Button3MotionMask, GDK.ButtonPressMask, GDK.ButtonReleaseMask,
// GDK.KeyPressMask, GDK.KeyReleaseMask, GDK.EnterNotifyMask,
// GDK.LeaveNotifyMask, GDK.FocusChangeMask, GDK.StructureMask,
// GDK.PropertyChangeMask, GDK.VisibilityNotifyMask,
// GDK.ProximityInMask, GDK.ProximityOutMask and GDK.AllEventsMask

COMPLEX_FUNCTION(set_extension_events, int);
NAME_ARGS(events);
// Events is one of CONST(GDK_EXTENSION_EVENT)

int COMPLEX_FUNCTION(get_extension_events);
// Returns one of CONST(GDK_EXTENSION_EVENT)

/* TODO; GdkWindow COMPLEX_FUNCTION(get_parent_window); */
/* TODO: Widget COMPLEX_FUNCTION(get_ancestor, int);  argument is widgettype*/
Widget COMPLEX_FUNCTION(get_toplevel);
// return the toplevel widget this widget is inside (or this widget if
// it is the toplevel widget)

int COMPLEX_FUNCTION(get_events);
// Return the current event mask (see set_events and add_events)

int COMPLEX_FUNCTION(is_ancestor, widget);
NAME_ARGS(of);
// Returns true if the specified widget is an ancestor of this widget.
 
Style COMPLEX_FUNCTION(get_style);
// Return the style associated with this widget

COMPLEX_FUNCTION(restore_default_style);
// Reset all styles to their default value
COMPLEX_FUNCTION(reset_rc_styles);
// Reset all styles to their default value, recursively
COMPLEX_FUNCTION(set_composite_name, string);
NAME_ARGS(name);
// Like set name, but it is inherited by the children of this widget.
string COMPLEX_FUNCTION(get_composite_name);
// Like set name, but it is inherited by the children of this widget.

FUNCTION(path, "function(void:string)");
// Returns the 'pathname' of this widget. Useful for rc-files and such.
{
  gchar *path, *prev;
  guint path_length;
  
  gtk_widget_path( GTK_WIDGET( THIS->obj ), &path_length, &path, &prev );

  push_text( path );
  g_free(path);
  g_free(prev);
}

FUNCTION(class_path, "function(void:string)");
// Returns the class 'pathname' of this widget. Useful for rc-files and such.
{
  gchar *path, *prev;
  guint path_length;

  gtk_widget_class_path( GTK_WIDGET( THIS->obj ), &path_length, &path, &prev );

  push_text( path );
  g_free(path);
  g_free(prev);
}

COMPLEX_FUNCTION(lock_accelerators);
// Make it impossible to add new accelerators, or remove old ones
COMPLEX_FUNCTION(unlock_accelerators);
// Make it possible to add new accelerators, and remove old ones,
// again. Use this after lock_accelerators()

int COMPLEX_FUNCTION(set_scroll_adjustments, adjustment, adjustment);
NAME_ARGS(hadjustment,vadjustment);
// Set the scrolling (panning) adjustment objects for this widget.
// Returns 1 if it is possible to do so, and 0 otherwise.

COMPLEX_FUNCTION(set_app_paintable, int);
NAME_ARGS(paintablep);
// Make it possible to draw directly in the widget using the low-level
// drawing functions.


FUNCTION(set_flags, "function(int:object)");
NAME_ARGS(flags);
// The flags that it makes sense to set are:
// GTK.CanFocus and GTK.CanDefault
RETURNS(GTK.Widget);
{
  GTK_WIDGET_SET_FLAGS( GTK_WIDGET( THIS->obj ), sp[-1].u.integer );
  RETURN_THIS();
}

FUNCTION(unset_flags, "function(int:object)");
NAME_ARGS(flags);
// The flags that it makes sense to unset are:
// GTK.CanFocus and GTK.CanDefault
RETURNS(GTK.Widget);
{
  GTK_WIDGET_UNSET_FLAGS( GTK_WIDGET( THIS->obj ), sp[-1].u.integer );
  RETURN_THIS();
}

FUNCTION(has_set_flags, "function(int:object)");
NAME_ARGS(mask);
// All possible flags are:
// GTK.AppPaintable,
// GTK.CanDefault,
// GTK.CanFocus,
// GTK.CompositeChild,
// GTK.HasDefault,
// GTK.HasFocus,
// GTK.HasGrab,
// GTK.Mapped,
// GTK.NoReparent,
// GTK.NoWindow,
// GTK.ParentSensitive,
// GTK.RcStyle,
// GTK.Realized,
// GTK.ReceivesDefault
// GTK.Sensitive,
// GTK.Toplevel and
// GTK.Visible.
RETURNS(GTK.Widget);
{
  my_pop_n_elems(args);
  push_int( GTK_WIDGET_FLAGS(GTK_WIDGET(THIS->obj)) | sp[-1].u.integer );
}



/* DND */

FUNCTION(drag_dest_unset, "function(void:object)");
// Removes the drop support from this widget (see drag_dest_set)
RETURNS(GTK.Widget);
{
  gtk_drag_dest_unset( GTK_WIDGET( THIS->obj ) );
  RETURN_THIS();
}

FUNCTION(drag_highlight, "function(void:object)");
// Highlight the widget. Not normaly used directly.
RETURNS(GTK.Widget);
{
  gtk_drag_highlight( GTK_WIDGET( THIS->obj ) );
  RETURN_THIS();
}

FUNCTION(drag_unhighlight, "function(void:object)");
// Unhighlight the widget. Not normaly used directly.
RETURNS(GTK.Widget);
{
  gtk_drag_unhighlight( GTK_WIDGET( THIS->obj ) );
  RETURN_THIS();
}

FUNCTION(drag_dest_set, "function(int,array(array(int|string)),int:object)");
NAME_ARGS(flags,targets,actions);
//     Register a drop site, and possibly add default behaviors.<br>
//   arguments:<br>
//     flags:     Which types of default drag behavior to use (one of CONST(GTK_DEST_DEFAULT))<br>
//     targets:   Table of targets that can be accepted
//            ({ ({ content_type(string), flags(int(try 0)), id(int) }), ...})
//       The id will be received in the signal handlers.<br>
//     actions:   one of CONST(GDK_ACTION_)
//   results:
RETURNS(GTK.Widget);
{
  int i, f, j;
  struct array *a;
  GtkTargetEntry *entries = NULL;
  get_all_args( "drag_dest_set", args, "%d%a%d", &i, &a, &f );
  if(a->size)
//     error("You must accept at least one target type\n");
    entries = malloc(sizeof(GtkTargetEntry)*a->size);
  
  for(j=0; j<a->size; j++)
  {
    if(a->item[j].type != T_ARRAY || 
       a->item[j].u.array->size != 3 ||
       a->item[j].u.array->item[0].type != T_STRING ||
       a->item[j].u.array->item[0].u.string->size_shift > 1 ||
       a->item[j].u.array->item[1].type != T_INT ||
       a->item[j].u.array->item[2].type != T_INT)
    {
      free(entries);
      error("The array is malformed.\n"); 
    }
    entries[j].target = a->item[j].u.array->item[0].u.string->str;
    entries[j].flags = a->item[j].u.array->item[1].u.integer;
    entries[j].info = a->item[j].u.array->item[2].u.integer;
  }
  gtk_drag_dest_set( GTK_WIDGET( THIS->obj ), i, entries, a->size, f);
  if(entries)
    free(entries);
  RETURN_THIS();
}



FUNCTION(drag_source_set, "function(int,array(array(int|string)),int:object)");
NAME_ARGS(flags,targets,actions);
//     Register a drop site, and possibly add default behaviors.<br>
//   arguments:<br>
//     buttons:     Which mouse buttons can be used to start the drag<br>
//     targets:   Table of targets that can be accepted
//            ({ ({ content_type(string), flags(int(try 0)), id(int) }), ...})
//       The id will be received in the signal handlers.<br>
//     actions:   one of CONST(GDK_ACTION_)
//   results:
RETURNS(GTK.Widget);
{
  int i, f, j;
  struct array *a;
  GtkTargetEntry *entries = NULL;
  get_all_args( "drag_source_set", args, "%d%a%d", &i, &a, &f );

  if(a->size)
//     error("You must provide at least one target type\n");
    entries = malloc(sizeof(GtkTargetEntry)*a->size);
  
  for(j=0; j<a->size; j++)
  {
    if(a->item[j].type != T_ARRAY || 
       a->item[j].u.array->size != 3 ||
       a->item[j].u.array->item[0].type != T_STRING ||
       a->item[j].u.array->item[0].u.string->size_shift > 1 ||
       a->item[j].u.array->item[1].type != T_INT ||
       a->item[j].u.array->item[2].type != T_INT)
    {
      free(entries);
      error("The array is malformed.\n"); 
    }
    entries[j].target = a->item[j].u.array->item[0].u.string->str;
    entries[j].flags = a->item[j].u.array->item[1].u.integer;
    entries[j].info = a->item[j].u.array->item[2].u.integer;
  }
  gtk_drag_source_set( GTK_WIDGET( THIS->obj ), i, entries, a->size, f);
  if(entries)
    free(entries);
  RETURN_THIS();
}

FUNCTION(drag_source_unset, "function(void:object)");
// Remove the drag support from this widget. See drag_source_set.
RETURNS(GTK.Widget);
{
  gtk_drag_source_unset( GTK_WIDGET( THIS->obj ) );
  RETURN_THIS();
}

FUNCTION(drag_source_set_icon, "function(object,object:object)");
// Set the icon that will be used (by default) for drags
// from this widget.
RETURNS(GTK.Widget);
ARGS(GDK.Pixmap,GDK.Bitmap);
NAME_ARGS(image,mask);
{
  struct object *p=NULL, *m=NULL;
  if(args == 2)
  {
    if(sp[-args].type == T_OBJECT)
      p = sp[-args].u.object;
    if(sp[-args+1].type == T_OBJECT)
      m = sp[-args+1].u.object;
  }  else {
    if(sp[-args].type == T_OBJECT)
      p = sp[-args].u.object;
  }
  gtk_drag_source_set_icon( GTK_WIDGET( THIS->obj ),
                            gdk_colormap_get_system(),
                            get_gdkobject( p, Pixmap ),
                            get_gdkobject( m, Bitmap ));
  RETURN_THIS();
}


FUNCTION(drag_get_data, "function(object,int:object)");
// Get the data from a context and an integer timestamp, requesting
// it from the dropping client. This will probably never be used
// directly.<p>
//
// Use the selection argument passed to the drag_data_received signal
// instead.
RETURNS(GTK.Widget);
ARGS(GDK.DragContext,int);
NAME_ARGS(context,time);
{
  int t;
  struct object *_ctx;
  GdkDragContext *ctx;
  get_all_args( "drag_get_data", args, "%o%d", &_ctx, &t );
  ctx = (GdkDragContext *)get_gdkobject( _ctx, DragContext );
  if(ctx && ctx->targets)
    gtk_drag_get_data( GTK_WIDGET( THIS->obj ), ctx, 
                       GPOINTER_TO_INT( ctx->targets->data ),
                       t );
}
