class widget;
inherit object;
// The basic widget, inherited (directly or indirectly) by all
// widgets.  Thus, all functions and signals defined in this widget
// works on all widgets.
// <p>
// One of the most importat functions in this class is 'show',
// it lets GTK know that we are done setting the attributes of the
// widget, and it is ready to be displayed. You may also use hide to
// make it disappear again. The order in which you show the widgets is
// not important, but I suggest showing the toplevel window last so
// the whole window pops up at once rather than seeing the individual
// widgets come up on the screen as they're formed. The children of a
// widget (a window is a widget too) will not be displayed until the
// window itself is shown using the show() function.</p>
signal show;
// Called when the widget is shown
signal hide;
// Called when the widget is hidden
signal map;
// Called when the window associated with the widget is mapped
signal unmap;
// Called when the window associated with the widget is unmapped
signal realize;
// Called when the widget is realized. Some methods cannot be used until the widget has been realized, if you get assertion errors related to 'w->window' or similar, this is probably the cause.
signal unrealize;
// Called when the widget is unrealized.
signal draw;
// Called when the widget should draw itself.
signal draw_focus;
// Called when the widget should draw itself, and a focus indicator around itself (or otherwise indicate that is has the keyboard focus)
signal draw_default;
// Called when the widget should draw itself, and indicate that it's the default widget
signal add_accelerator;
// Called when an accelarator (keyboard shortcut) is added to the widget
signal remove_accelerator;
// Called when an accelerator (keyboard shortcut) is removed from the widget
signal size_request;
// Called when the widget should calculate how big it want's to be
signal size_allocate;
// Called when the widget get's the size it should be
signal state_changed;
signal parent_set;
// Called when the parent widget is changed
signal style_set;
// Called when the style is changed
signal event;
// Called for all events
signal button_press_event;
// Called when a mouse button is pressed
signal button_release_event;
// Called when a mouse button is released
signal motion_notify_event;
// Called when the mouse is moved inside the widget
signal delete_event;
// Called when the user has requested that the widget should be closed
signal destroy_event;
// Called when the widget is destroyed
signal expose_event;
// Called when the widget, or a part of the widget gets and expose event
signal key_press_event;
// Called when a keyboard key is pressed
signal key_release_event;
// Called when a keyboard key is released
signal enter_notify_event;
// Called when the mouse enters the widget
signal leave_notify_event;
// Called when the mouse leaves the widget
signal configure_event;
// The size, position or stacking order of the widget has changed
signal focus_in_event;
// The keyboard focus has entered the widget
signal focus_out_event;
// The keyboard focus has left the widget
signal map_event;
// Called just before the 'map' signal
signal unmap_event;
// Called just before the 'unmap' signal
signal property_notify_event;
// Called when a property of the GDK window associated with the widget is changed
signal selection_clear_event;
// NYI
signal selection_request_event;
// NYI
signal selection_notify_event;
// NYI
signal selection_received;
// NYI
signal proximity_in_event;
signal proximity_out_event;
signal drag_leave;
// Called when the mouse leaves the widget while the user is dragging something
signal drag_begin;
// Called when the drag is initiated, on the sending side
signal drag_end;
// Called when the drag is finished, on the sending side
signal drag_data_delete;
// Called when the data can be safely deleted (there is no need to use this function in pigtk, it's all handled automatically)
signal drag_motion;
// Called on the receiving side when the cursor is moved over the widget while dragging something
signal drag_drop;
// Called on the receiving side when the drop is initiated
signal drag_data_get;
// Called on the sending side when the drop is initiated
signal drag_data_received;
// Called on the receiving side when the drop is finished.
signal visibility_notify_event;
// The widget has been mapped, unmapped, hidden, or otherwise had it's visibility modified
signal debug_msg;
signal other_event;
signal client_event;
// An event sent by another client application
signal no_expose_event;

/*  TODO: Some functions left to implement */
void show();
// Show the widget. Most (almost all) widgets must be shown to be
// visible on the screen.

subwidget widget parent;
// Returns the parent of this widget, if any, if there is no parent
// 0 is returned.

FUNCTION(text_width, "function(string:int)");
NAME_ARGS(text);
// Returns the width, in pixels, the string would have if it was
// written with the default font in the style object assosiated with
// the widget. Currently, this is always a 8bit string, but that
// should hopefully change in the future.
{
  struct pike_string *s;
  get_all_args("text_width", args, "%S", &s);
  push_int(gdk_text_width(GTK_WIDGET( THIS->obj )->style->font,s->str,s->len));
}


#define TWIN  (GTK_WIDGET(THIS->obj)->window)
#define GC(X) ((GdkGC*)get_gdkobject(X,GC))

FUNCTION(set_background, "function(object:object)");
NAME_ARGS(background);
// Set the background color or image.
// The argument is either a GDK.Pixmap or a GDK.Color object.
// <br />NOTE: The widget must be realized before this function can be used
{
  struct object *o;
  get_all_args("set_background", args, "%o", &o);

  if(get_gdkobject(o,Pixmap))
    gdk_window_set_back_pixmap(TWIN, get_gdkobject(o,Pixmap), 0);
  else if(get_gdkobject(o,Color))
    gdk_window_set_background(TWIN, get_gdkobject(o,Color));

  RETURN_THIS();
}

FUNCTION(copy_area, "function(object,int,int,object,int,int,int,int:object)");
RETURNS(GTK.Widget);
ARGS(GDK.GC,int,int,GTK.Widget,int,int,int,int);
NAME_ARGS(gc,xdest,ydest,source,xsource,ysource,width,height);
// Copies the rectangle defined by xsource,ysource and width,height
// from the source widget, and places the results at xdest,ydest in
// the widget in which this function is called.
// <br />NOTE: The widget must be realized before this function can be used
{
  struct object *gc, *source;
  GdkWindow *win;
  INT_TYPE xd, yd, xs, ys, w, h;
  get_all_args("copy_area",args, "%o%d%d%o%d%d%d%d",
	       &gc, &xd, &yd, &source, &xs, &ys, &w, &h);

  if(get_gdkobject( source, Drawable ))
    win = get_gdkobject( source, Drawable );
  else
    win = GTK_WIDGET( get_gtkobject( source ) )->window;

  gdk_window_copy_area( TWIN, GC(gc), xd, yd, win, xs, ys, w, h);
  RETURN_THIS();
}

FUNCTION(get_gdkwindow, "function(void:object)");
RETURNS(GDK.Window);
// Return the GDK.Window associated with this widget, if any.
{
  my_pop_n_elems(args);
  if(GTK_WIDGET(THIS->obj)->window)
  {
    struct object *o;
    o = low_clone( pgtk_GdkWindow_program );
    call_c_initializers( o );
    /* ugly...*/
    ((struct object_wrapper *)o->storage)->obj=
      (void *)GTK_WIDGET(THIS->obj)->window;
    ref_push_object( o );
  } else
    push_int(0);
}

FUNCTION(shape_combine_mask, "function(object,int,int:object)");
RETURNS(GTK.Widget);
ARGS(GDK.Bitmap,int,int);
NAME_ARGS(shape, xoffset,yoffset);
// Set the shape of the widget, or, rather, it's window, to that of
// the supplied bitmap. Notice how the window behind the example
// window can be seen because of the rather odd shape the example window has.
// TIMG: GTK.Window( GTK.WINDOW_TOPLEVEL )->add(GTK.Label("A rather Oddly shaped\n" "Window\n" "Indeed\n" "Or what do you\nthink?\n" "This text\n" "should\n" "be long enough"))->shape_combine_mask( GDK.Bitmap(Image.image(100,100,255,255,255)->rotate(10,0,0,0) ), 20,20)
// <br />NOTE: The widget must be realized before this function can be used
{
  struct object *m;
  INT_TYPE x, y;
  get_all_args("shape_combine", args, "%o%d%d", &m, &x, &y);
  gtk_widget_shape_combine_mask( GTK_WIDGET( THIS->obj ),
				 get_gdkobject(m,Bitmap), x, y);
  RETURN_THIS();
}

FUNCTION(xoffset, "function(void:int)")
// Returns the x position of the upper left corner relative to the
// widgets window in pixels. For widgets that have their own window
// this will most likely be 0.
{
  push_int( GTK_WIDGET( THIS->obj )->allocation.x );
}

FUNCTION(yoffset, "function(void:int)")
// Returns the y position of the upper left corner relative to the
// widgets window in pixels. For widgets that have their own window
// this will most likely be 0.
{
  push_int( GTK_WIDGET( THIS->obj )->allocation.y );
}

FUNCTION(xsize, "function(void:int)")
// Returns the width of the widget in pixels.
{
  push_int( GTK_WIDGET( THIS->obj )->allocation.width );
}

FUNCTION(ysize, "function(void:int)")
// Returns the height of the widget in pixels.
{
  push_int( GTK_WIDGET( THIS->obj )->allocation.height );
}

FUNCTION(allocation, "function(void:mapping)");
// Returns ([ "x":xoffset, "y":yoffset, "width":xsize, "height":ysize ])
{
  push_text( "x" );
  push_int( GTK_WIDGET( THIS->obj )->allocation.x );
  push_text( "y" );
  push_int( GTK_WIDGET( THIS->obj )->allocation.y );
  push_text( "width" );
  push_int( GTK_WIDGET( THIS->obj )->allocation.width );
  push_text( "height" );
  push_int( GTK_WIDGET( THIS->obj )->allocation.height );
  f_aggregate_mapping( 8 );
}

void add_accelerator( string signal, accel_group group, int key, int modifiers, int flags );
// Add an accelerator (keyboard shortcut).
// <p>
// Flag is one of CONST(GTK_ACCE)
// <br />
// The signal is the signal to invoke when the accelerator key is pressed.
// <br />
// The modifiers is a bitwise or of one or more of GDK.ShiftMask,
// GDK.LockMask, GDK.ControlMask, CONST(GDK_MOD).
// <br />
// The group is the accelerator group in which the accelerator should be added.
// <br />
// The key is the unicode code for the key to bind.</p>

void remove_accelerator( accel_group group, int key, int modifiers );
// Remove an accelerator (keyboard shortcut).
// <p>
// The modifiers is a bitwise or of one or more of GDK.ShiftMask,
// GDK.LockMask, GDK.ControlMask, CONST(GDK_MOD).
// <br />
// The group is the accelerator group in which the accelerator should be added.
// <br />
// The key is the unicode code for the key to bind.</p>

void set_usize( int xsize, int ysize );
// Set the absolute size of the widget. It might resize itself anyway,
// but this size is used as is in most widgets. Beware of this
// function, it might produce unexpected results. 0 for any size means
// 'keep old size'. When setting sizes of wtoplevel windows, it is
// preferable to use set_default_size

void set_uposition( int xpos, int ypos );
// Set the absolute coordinates of the widget relative to it's parent.

void set_name( string name );
// Set the name of the widget. The name is used when the rc-file is
// parsed, you can also parse your own resources by calling
// GTK.parse_rc() with a resource string. <br />Example: <p>
// TODO</p>
void set_state( int state );
// One of CONST(GTK_STATE).
// This function should normaly not be used directly.

void set_sensitive( int sensitivep );
// True (1) or false (0). If true, the widget can receive events,
// otherwise the user cannot interact with the widget. Most widgets
// are drawn 'greyed' or more dim when they are unsensitive.

string get_name();
// Returns the name set by set_name or the class name

#ifndef __NT__
#include <gdk/gdkx.h>
#else
#include <gdk/win32/gdkwin32.h>
#endif
FUNCTION(set_cursor, "function(int,void|object,void|object:object)");
ARGS(int|void,void|GDK.Color,void|GDK.Color);
NAME_ARGS(cursor_type, fg, bg);
// Change the widget cursor.<br />
// If no arguments are passed, restore the default cursor.<br />
// Both fg and bg must be specified if either one is.<br />
// <table border="0" cellpadding="3" cellspacing="0">
// CURS(GDK.Arrow)
// CURS(GDK.BasedArrowDown)
// CURS(GDK.BasedArrowUp)
// CURS(GDK.Boat)
// CURS(GDK.Bogosity)
// CURS(GDK.BottomLeftCorner)
// CURS(GDK.BottomRightCorner)
// CURS(GDK.BottomSide)
// CURS(GDK.BottomTee)
// CURS(GDK.BoxSpiral)
// CURS(GDK.CenterPtr)
// CURS(GDK.Circle)
// CURS(GDK.Clock)
// CURS(GDK.CoffeeMug)
// CURS(GDK.Cross)
// CURS(GDK.CrossReverse)
// CURS(GDK.Crosshair)
// CURS(GDK.DiamondCross)
// CURS(GDK.Dot)
// CURS(GDK.Dotbox)
// CURS(GDK.DoubleArrow)
// CURS(GDK.DraftLarge)
// CURS(GDK.DraftSmall)
// CURS(GDK.DrapedBox)
// CURS(GDK.Exchange)
// CURS(GDK.Fleur)
// CURS(GDK.Gobbler)
// CURS(GDK.Gumby)
// CURS(GDK.Hand1)
// CURS(GDK.Hand2)
// CURS(GDK.Heart)
// CURS(GDK.Icon)
// CURS(GDK.IronCross)
// CURS(GDK.LeftPtr)
// CURS(GDK.LeftSide)
// CURS(GDK.LeftTee)
// CURS(GDK.Leftbutton)
// CURS(GDK.LlAngle)
// CURS(GDK.LrAngle)
// CURS(GDK.Man)
// CURS(GDK.Middlebutton)
// CURS(GDK.Mouse)
// CURS(GDK.Pencil)
// CURS(GDK.Pirate)
// CURS(GDK.Plus)
// CURS(GDK.QuestionArrow)
// CURS(GDK.RightPtr)
// CURS(GDK.RightSide)
// CURS(GDK.RightTee)
// CURS(GDK.Rightbutton)
// CURS(GDK.RtlLogo)
// CURS(GDK.Sailboat)
// CURS(GDK.SbDownArrow)
// CURS(GDK.SbHDoubleArrow)
// CURS(GDK.SbLeftArrow)
// CURS(GDK.SbRightArrow)
// CURS(GDK.SbUpArrow)
// CURS(GDK.SbVDoubleArrow)
// CURS(GDK.Shuttle)
// CURS(GDK.Sizing)
// CURS(GDK.Spider)
// CURS(GDK.Spraycan)
// CURS(GDK.Star)
// CURS(GDK.Target)
// CURS(GDK.Tcross)
// CURS(GDK.TopLeftArrow)
// CURS(GDK.TopLeftCorner)
// CURS(GDK.TopRightCorner)
// CURS(GDK.TopSide)
// CURS(GDK.TopTee)
// CURS(GDK.Trek)
// CURS(GDK.UlAngle)
// CURS(GDK.Umbrella)
// CURS(GDK.UrAngle)
// CURS(GDK.Watch)
// CURS(GDK.Xterm)
// </table>
{
  GdkCursor *c;
  struct object *fg = NULL, *bg = NULL;
  INT_TYPE i;

  if(!args)
    i = -1;
  else if( args >= 3 )
    get_all_args("set_cursor", args, "%d%o%o", &i, &fg, &bg);
  else
    get_all_args("set_cursor", args, "%d", &i);

  if(i>255)
    error("No such cursor\n");
  if( i >= 0 )
    c = gdk_cursor_new( i );
  else
    c = NULL;

#ifndef __NT__
  if( c && fg && bg )
  {
    XColor fgp, bgp;
    MEMSET(&fgp, 0, sizeof(fg) );
    MEMSET(&bgp, 0, sizeof(bg) );

    if( get_gdkobject( fg, Color ) )
      fgp.pixel = ((GdkColor *)get_gdkobject( fg, Color ))->pixel;
    if( get_gdkobject( bg, Color ) )
      bgp.pixel = ((GdkColor *)get_gdkobject( bg, Color ))->pixel;

    XRecolorCursor(((GdkCursorPrivate *)c)->xdisplay,
                   ((GdkCursorPrivate *)c)->xcursor,
                   &fgp, &bgp );
  }
#endif
  gtk_object_set_data_full(THIS->obj,
                           "cursor_to_free",(void*)c,
                           (void*)gdk_cursor_destroy);
  gdk_window_set_cursor( TWIN, c );

  RETURN_THIS();
}
FUNCTION(set_bitmap_cursor, "function(object,object,object,object,int,int:object)");

ARGS(GDK.Bitmap,GDK.Bitmap,GDK.Color,GDK.Color,int,int);
NAME_ARGS(source,mask,fg,bg,xhot,yhot);
// xhot and yhot are the locations of the x and y hotspot relative to the
// upper left corner of the cursor image.
// Both bitmaps and both colors must be non-null.
{
  struct object *s, *m, *fg, *bg;
  INT_TYPE xh, yh;
  get_all_args("set_bitmap_cursor", args, "%o%o%o%o%d%d",
	       &s,&m,&fg,&bg,&xh,&yh);
  gdk_window_set_cursor( TWIN,
		 gdk_cursor_new_from_pixmap( get_gdkobject( s, Pixmap ),
					     get_gdkobject( m, Bitmap ),
					     get_gdkobject( fg, Color),
					     get_gdkobject( bg, Color ),
					     xh,yh ) );
  RETURN_THIS();
}

void unparent();
// Remove this widget from it's parent
void realize();
// Realize this widget, and it's children, if nessesary
void unrealize();
// Unrealize this widget, and it's children, if nessesary
void queue_draw();
// Force a redraw of the widget
void queue_draw_area( int x, int y, int width, int height );
// Force a redraw of part of the widget
void queue_clear();
// Force a clear (and subsequent redraw) of the widget
void queue_clear_area( int x, int y, int width, int height );
// Force a clear (and subsequent redraw) of part of the widget
void ensure_style();
// Ensure that the widget has a style associated with it.
void queue_resize();
// Force a allocation recalculation, followed by a redraw
void show_now();
// Show this widget and do not return until it is visible.
void hide();
// Hide this widget
void show_all();
// Show this widget and all it's children
void hide_all();
// Hide this widget and all it's children
void map();
// Map the widget. Should normally not be called directly.
void unmap();
// Unmap the widget. Should normally not be called directly.
void activate();
// Activate the widget. This either activates the widget, if possible
// (as an example, buttons can be activated), or activates the default
// widget of it's parent (or it's parent, or it's parents parent
// etc.)

void grab_focus();
// Grab the focus.
void grab_default();
// Make this widget the default action for the parent widget
int intersect( GdkRectangle area, GdkRectangle intersection );
// Do an intersection with the area and place the result in
// 'intersection'.

void reparent( widget to );
// Change the parent of the widget.
void popup( int xpos, int ypos );
// Map the widget at the specified coordinates.

void add_events( int events );
// Events is one or more of:
// GDK.ExposureMask, GDK.PointerMotionMask,
// GDK.PointerMotion_HINTMask, GDK.ButtonMotionMask,
// GDK.Button1MotionMask, GDK.Button2MotionMask,
// GDK.Button3MotionMask, GDK.ButtonPressMask, GDK.ButtonReleaseMask,
// GDK.KeyPressMask, GDK.KeyReleaseMask, GDK.EnterNotifyMask,
// GDK.LeaveNotifyMask, GDK.FocusChangeMask, GDK.StructureMask,
// GDK.PropertyChangeMask, GDK.VisibilityNotifyMask,
// GDK.ProximityInMask, GDK.ProximityOutMask and GDK.AllEventsMask

void set_events( int events );
// Events is one or more of:
// GDK.ExposureMask, GDK.PointerMotionMask,
// GDK.PointerMotion_HINTMask, GDK.ButtonMotionMask,
// GDK.Button1MotionMask, GDK.Button2MotionMask,
// GDK.Button3MotionMask, GDK.ButtonPressMask, GDK.ButtonReleaseMask,
// GDK.KeyPressMask, GDK.KeyReleaseMask, GDK.EnterNotifyMask,
// GDK.LeaveNotifyMask, GDK.FocusChangeMask, GDK.StructureMask,
// GDK.PropertyChangeMask, GDK.VisibilityNotifyMask,
// GDK.ProximityInMask, GDK.ProximityOutMask and GDK.AllEventsMask

void set_extension_events( int events );
// Events is one of CONST(GDK_EXTENSION_EVENT)

int get_extension_events();
// Returns one of CONST(GDK_EXTENSION_EVENT)

/* TODO; GdkWindow complex_function(get_parent_window); */
/* TODO: Widget complex_function(get_ancestor, int);  argument is widgettype*/
Widget get_toplevel();
// return the toplevel widget this widget is inside (or this widget if
// it is the toplevel widget)

int get_events();
// Return the current event mask (see set_events and add_events)

int is_ancestor( widget of );
// Returns true if the specified widget is an ancestor of this widget.

Style get_style();
// Return the style associated with this widget

void restore_default_style();
// Reset all styles to their default value
void set_rc_style();
// Set the style from the .rc files
void reset_rc_styles();
// Reset all styles to their default value, recursively
void set_composite_name( string name );
// Like set name, but it is inherited by the children of this widget.
string get_composite_name();
// Like set name, but it is inherited by the children of this widget.

FUNCTION(path, "function(void:string)");
// Returns the 'pathname' of this widget. Useful for rc-files and such.
{
  gchar *path, *prev;
  guint path_length;

  gtk_widget_path( GTK_WIDGET( THIS->obj ), &path_length, &path, &prev );

  push_text( path );
  g_free(path);
  g_free(prev);
}

FUNCTION(class_path, "function(void:string)");
// Returns the class 'pathname' of this widget. Useful for rc-files and such.
{
  gchar *path, *prev;
  guint path_length;

  gtk_widget_class_path( GTK_WIDGET( THIS->obj ), &path_length, &path, &prev );

  push_text( path );
  g_free(path);
  g_free(prev);
}

void lock_accelerators();
// Make it impossible to add new accelerators, or remove old ones
void unlock_accelerators();
// Make it possible to add new accelerators, and remove old ones,
// again. Use this after lock_accelerators()

int set_scroll_adjustments( adjustment hadjustment, adjustment vadjustment );
// Set the scrolling (panning) adjustment objects for this widget.
// Returns 1 if it is possible to do so, and 0 otherwise.

void set_app_paintable( int paintablep );
// Make it possible to draw directly in the widget using the low-level
// drawing functions.


FUNCTION(set_flags, "function(int:object)");
NAME_ARGS(flags);
// The flags that it makes sense to set are:
// GTK.CanFocus and GTK.CanDefault
RETURNS(GTK.Widget);
{
  GTK_WIDGET_SET_FLAGS( GTK_WIDGET( THIS->obj ), Pike_sp[-1].u.integer );
  RETURN_THIS();
}

FUNCTION(unset_flags, "function(int:object)");
NAME_ARGS(flags);
// The flags that it makes sense to unset are:
// GTK.CanFocus and GTK.CanDefault
RETURNS(GTK.Widget);
{
  GTK_WIDGET_UNSET_FLAGS( GTK_WIDGET( THIS->obj ), Pike_sp[-1].u.integer );
  RETURN_THIS();
}

FUNCTION(has_set_flags, "function(int:object)");
NAME_ARGS(mask);
// All possible flags are:
// GTK.AppPaintable,
// GTK.CanDefault,
// GTK.CanFocus,
// GTK.CompositeChild,
// GTK.HasDefault,
// GTK.HasFocus,
// GTK.HasGrab,
// GTK.Mapped,
// GTK.NoReparent,
// GTK.NoWindow,
// GTK.ParentSensitive,
// GTK.RcStyle,
// GTK.Realized,
// GTK.ReceivesDefault
// GTK.Sensitive,
// GTK.Toplevel and
// GTK.Visible.
RETURNS(GTK.Widget);
{
  my_pop_n_elems(args);
  push_int( GTK_WIDGET_FLAGS(GTK_WIDGET(THIS->obj)) | Pike_sp[-1].u.integer );
}



/* DND */

FUNCTION(drag_dest_unset, "function(void:object)");
// Removes the drop support from this widget (see drag_dest_set)
RETURNS(GTK.Widget);
{
  gtk_drag_dest_unset( GTK_WIDGET( THIS->obj ) );
  RETURN_THIS();
}

FUNCTION(drag_highlight, "function(void:object)");
// Highlight the widget. Not normaly used directly.
RETURNS(GTK.Widget);
{
  gtk_drag_highlight( GTK_WIDGET( THIS->obj ) );
  RETURN_THIS();
}

FUNCTION(drag_unhighlight, "function(void:object)");
// Unhighlight the widget. Not normaly used directly.
RETURNS(GTK.Widget);
{
  gtk_drag_unhighlight( GTK_WIDGET( THIS->obj ) );
  RETURN_THIS();
}

FUNCTION(drag_dest_set, "function(int,array(array(int|string)),int:object)");
NAME_ARGS(flags,targets,actions);
//     Register a drop site, and possibly add default behaviors.<br />
//   arguments:<br />
//     flags:     Which types of default drag behavior to use (one of CONST(GTK_DEST_DEFAULT))<br />
//     targets:   Table of targets that can be accepted
//            ({ ({ content_type(string), flags(int(try 0)), id(int) }), ...})
//       The id will be received in the signal handlers.<br />
//     actions:   one of CONST(GDK_ACTION_)
//   results:
RETURNS(GTK.Widget);
{
  INT_TYPE i, f, j;
  struct array *a;
  GtkTargetEntry *entries = NULL;
  get_all_args( "drag_dest_set", args, "%d%a%d", &i, &a, &f );
  if(a->size)
//     error("You must accept at least one target type\n");
    entries = malloc(sizeof(GtkTargetEntry)*a->size);

  for(j=0; j<a->size; j++)
  {
    if(a->item[j].type != PIKE_T_ARRAY ||
       a->item[j].u.array->size != 3 ||
       a->item[j].u.array->item[0].type != PIKE_T_STRING ||
       a->item[j].u.array->item[0].u.string->size_shift > 1 ||
       a->item[j].u.array->item[1].type != PIKE_T_INT ||
       a->item[j].u.array->item[2].type != PIKE_T_INT)
    {
      free(entries);
      error("The array is malformed.\n");
    }
    entries[j].target = a->item[j].u.array->item[0].u.string->str;
    entries[j].flags = a->item[j].u.array->item[1].u.integer;
    entries[j].info = a->item[j].u.array->item[2].u.integer;
  }
  gtk_drag_dest_set( GTK_WIDGET( THIS->obj ), i, entries, a->size, f);
  if(entries)
    free(entries);
  RETURN_THIS();
}

FUNCTION(drag_source_set, "function(int,array(array(int|string)),int:object)");
NAME_ARGS(flags,targets,actions);
//     Register a drop site, and possibly add default behaviors.<br />
//   arguments:<br />
//     buttons:     Which mouse buttons can be used to start the drag<br />
//     targets:   Table of targets that can be accepted
//            ({ ({ content_type(string), flags(int(try 0)), id(int) }), ...})
//       The id will be received in the signal handlers.<br />
//     actions:   one of CONST(GDK_ACTION_)
//   results:
RETURNS(GTK.Widget);
{
  INT_TYPE i, f, j;
  struct array *a;
  GtkTargetEntry *entries = NULL;
  get_all_args( "drag_source_set", args, "%d%a%d", &i, &a, &f );

  if(a->size)
//     error("You must provide at least one target type\n");
    entries = malloc(sizeof(GtkTargetEntry)*a->size);

  for(j=0; j<a->size; j++)
  {
    if(a->item[j].type != PIKE_T_ARRAY ||
       a->item[j].u.array->size != 3 ||
       a->item[j].u.array->item[0].type != PIKE_T_STRING ||
       a->item[j].u.array->item[0].u.string->size_shift > 1 ||
       a->item[j].u.array->item[1].type != PIKE_T_INT ||
       a->item[j].u.array->item[2].type != PIKE_T_INT)
    {
      free(entries);
      error("The array is malformed.\n");
    }
    entries[j].target = a->item[j].u.array->item[0].u.string->str;
    entries[j].flags = a->item[j].u.array->item[1].u.integer;
    entries[j].info = a->item[j].u.array->item[2].u.integer;
  }
  gtk_drag_source_set( GTK_WIDGET( THIS->obj ), i, entries, a->size, f);
  if(entries)
    free(entries);
  RETURN_THIS();
}

FUNCTION(drag_source_unset, "function(void:object)");
// Remove the drag support from this widget. See drag_source_set.
RETURNS(GTK.Widget);
{
  gtk_drag_source_unset( GTK_WIDGET( THIS->obj ) );
  RETURN_THIS();
}

FUNCTION(drag_source_set_icon, "function(object,object:object)");
// Set the icon that will be used (by default) for drags
// from this widget.
RETURNS(GTK.Widget);
ARGS(GDK.Pixmap,GDK.Bitmap);
NAME_ARGS(image,mask);
{
  struct object *p=NULL, *m=NULL;
  if(args == 2)
  {
    if(Pike_sp[-args].type == PIKE_T_OBJECT)
      p = Pike_sp[-args].u.object;
    if(Pike_sp[-args+1].type == PIKE_T_OBJECT)
      m = Pike_sp[-args+1].u.object;
  }  else {
    if(Pike_sp[-args].type == PIKE_T_OBJECT)
      p = Pike_sp[-args].u.object;
  }
  gtk_drag_source_set_icon( GTK_WIDGET( THIS->obj ),
                            gdk_colormap_get_system(),
                            get_gdkobject( p, Pixmap ),
                            get_gdkobject( m, Bitmap ));
  RETURN_THIS();
}


FUNCTION(drag_get_data, "function(object,int:object)");
// Get the data from a context and an integer timestamp, requesting
// it from the dropping client. This will probably never be used
// directly.
//
//<p>Use the selection argument passed to the drag_data_received signal
// instead.</p>
RETURNS(GTK.Widget);
ARGS(GDK.DragContext,int);
NAME_ARGS(context,time);
{
  INT_TYPE t;
  struct object *_ctx;
  GdkDragContext *ctx;
  get_all_args( "drag_get_data", args, "%o%d", &_ctx, &t );
  ctx = (GdkDragContext *)get_gdkobject( _ctx, DragContext );
  if(ctx && ctx->targets)
    gtk_drag_get_data( GTK_WIDGET( THIS->obj ), ctx,
                       GPOINTER_TO_INT( ctx->targets->data ),
                       t );
}

