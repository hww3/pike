require sheet;
ADD_INCLUDE(#include <gtksheet.h>);
ADD_INCLUDE(#include <gtksheetentry.h>);
CONSTANT(GTK_SHEET_FOREGROUND);
CONSTANT(GTK_SHEET_BACKGROUND);
CONSTANT(GTK_SHEET_FONT);
CONSTANT(GTK_SHEET_JUSTIFICATION);
CONSTANT(GTK_SHEET_BORDER);
CONSTANT(GTK_SHEET_BORDER_COLOR);
CONSTANT(GTK_SHEET_IS_EDITABLE);
CONSTANT(GTK_SHEET_IS_VISIBLE);
CONSTANT(GTK_SHEET_NORMAL);
CONSTANT(GTK_SHEET_ROW_SELECTED);
CONSTANT(GTK_SHEET_COLUMN_SELECTED);
CONSTANT(GTK_SHEET_RANGE_SELECTED);
CONSTANT(GTK_SHEET_IS_LOCKED);
CONSTANT(GTK_SHEET_IS_FROZEN);
CONSTANT(GTK_SHEET_IN_XDRAG);
CONSTANT(GTK_SHEET_IN_YDRAG);
CONSTANT(GTK_SHEET_IN_DRAG);
CONSTANT(GTK_SHEET_IN_SELECTION);
CONSTANT(GTK_SHEET_IN_RESIZE);
CONSTANT(GTK_SHEET_IN_CLIP);
CONSTANT(GTK_SHEET_ROW_FROZEN);
CONSTANT(GTK_SHEET_COLUMN_FROZEN);
CONSTANT(GTK_SHEET_AUTORESIZE);
CONSTANT(GTK_SHEET_ADJUST_TEXT);
CONSTANT(GTK_SHEET_ROW_TITLES_VISIBLE);
CONSTANT(GTK_SHEET_COL_TITLES_VISIBLE);
CONSTANT(GTK_SHEET_AUTO_SCROLL);

class shentry;
#include <gtksheetentry.h>
inherit entry;
FUNCTION(create, "function(void|int:void)");
NAME_ARGS(max_width);
{
  if(args)
    THIS->obj = GTK_OBJECT(gtk_shentry_new_with_max_length( sp[-1].u.integer ));
  else
    THIS->obj = GTK_OBJECT(gtk_shentry_new(  ));
}
void set_text( string text, int justifictation );
void set_justification( int justifictation );

class sheet;
#include <gtksheet.h>
// IMG: GTK.Sheet( 10,10, "example")
inherit container;
signal activate;
// Called when a child is activated
signal deactivate;
// Called when a child is deactivated
signal new_column_width;
signal new_row_height;
signal select_row;
signal select_column;
signal select_range;
signal clip_range;
signal resize_range;
signal move_range;
signal traverse;
signal set_cell;
signal changed;
signal new_column_width;
signal new_row_height;
signal set_scroll_adjustments;

static void push_gtk_sheet_range( GtkSheetRange range )
{
  push_text( "row0" ); push_int( range.row0 );
  push_text( "rowi" ); push_int( range.rowi );
  push_text( "col0" ); push_int( range.col0 );
  push_text( "coli" ); push_int( range.coli );
  f_aggregate_mapping( 8 );
}

static void push_gtk_sheet_border( GtkSheetCellBorder b )
{
  push_text( "mask" );        push_int( b.mask );
  push_text( "width" );       push_int( b.width );
  push_text( "line_style" );  push_int( b.line_style );
  push_text( "cap_style" );   push_int( b.cap_style );
  push_text( "join_style" );  push_int( b.join_style );
  push_text( "color" );
  push_pgdkobject( &b.color, pgtk_GdkColor_program );
  f_aggregate_mapping( 12 );
}

static void push_gtk_sheet_attr( GtkSheetAttr *a )
{
  push_text( "range" ); push_gtk_sheet_range( a->range );
  push_text( "type" );  push_int( a->type );
  push_text( "value" );
  switch( a->type )
  {
  case GTK_SHEET_FOREGROUND:
  case GTK_SHEET_BACKGROUND:
    push_pgdkobject( &a->value.foreground, pgtk_GdkColor_program );
    break;
  case GTK_SHEET_BORDER_COLOR:
    push_pgdkobject( &a->value.border.color, pgtk_GdkColor_program );
    break;
  case GTK_SHEET_FONT:
    push_pgdkobject( a->value.font, pgtk_GdkFont_program );
    break;
  case GTK_SHEET_JUSTIFICATION:
    push_int( a->value.justification );
    break;
  case GTK_SHEET_BORDER:
    push_gtk_sheet_border( a->value.border );
    break;
  case GTK_SHEET_IS_EDITABLE:
    push_int( a->value.is_editable );
    break;
  case GTK_SHEET_IS_VISIBLE:
    push_int( a->value.is_visible );
    break;
  }
  f_aggregate_mapping( 6 );
}

FUNCTION(get_attributes, "function(int,int:mapping)");
{
  int x, y;
  GtkSheetCellAttr attr;
  get_all_args( "get_attributes", args, "%d%d", &x, &y );
  my_pop_n_elems( args );
  if( gtk_sheet_get_attributes( GTK_SHEET(THIS->obj),x,y, &attr ) )
  {
    push_text("justification");
    push_int( attr.justification );
    push_text("font");
    push_pgdkobject( &attr.font, pgtk_GdkFont_program );
    push_text("foreground");
    push_pgdkobject( &attr.foreground, pgtk_GdkColor_program );
    push_text("background"); push_int( attr.justification );
    push_pgdkobject( &attr.background, pgtk_GdkColor_program );
    push_text("border");
    push_gtk_sheet_border( attr.border );
    push_text("is_editable");
    push_int( attr.is_editable );
    push_text("is_visible");
    push_int( attr.is_visible );
    f_aggregate_mapping( 14 );
  }
  else
    push_int( 0 );
}

void create( int rows, int columns, string title );
entry get_entry();
void set_hadjustment( adjustment );
void set_vadjustment( adjustment );

void set_column_titles_height( int height );
void set_row_titles_width( int height );
void put( widget child, int x, int y );
void move_child( widget child, int x, int y );
void set_cell_text( int, int, string );
int get_state();
void set_title( string title );
/* set_border( int );
/* NAME_ARGS(border_style); */
void freeze();
void thaw();
void set_column_title( int, string );
void set_row_title( int, string );
void row_button_add_label( int, string );
void column_button_add_label( int, string );
void moveto( int, int, float, float );
void show_column_titles();
void show_row_titles();
void hide_column_titles();
void hide_row_titles();
void column_set_sensitivity( int, int );
void row_set_sensitivity( int, int );
void columns_set_sensitivity( int );
void rows_set_sensitivity( int );
void column_set_visibility( int, int );
void row_set_visibility( int, int );
void select_row( int );
void select_column( int );
FUNCTION(clip_range, "function(int,int,int,int:object)");
NAME_ARGS(x0,y0,x1,y1);
{
  GtkSheetRange r;
  get_all_args( "clip_range", args, "%d%d%d%d", &r.col0,&r.row0,&r.coli,&r.rowi);
  gtk_sheet_clip_range( GTK_SHEET( THIS->obj ), r );
  RETURN_THIS();
}
void unclip_range();
adjustment get_vadjustment();
adjustment get_hadjustment();
FUNCTION(select_range, "function(void:mapping)");
NAME_ARGS(x0,y0,x1,y1);
{
  GtkSheetRange r;
  my_pop_n_elems(args);
  gtk_sheet_select_range( GTK_SHEET( THIS->obj ), &r );
  push_text( "x0" ); push_int( r.col0 );
  push_text( "y0" ); push_int( r.row0 );
  push_text( "x1" ); push_int( r.coli );
  push_text( "y1" ); push_int( r.rowi );
  f_aggregate_mapping( 4 );
}
FUNCTION(unselect_range, "function(void:mapping)");
NAME_ARGS(x0,y0,x1,y1);
{
  GtkSheetRange r;
  my_pop_n_elems(args);
  gtk_sheet_unselect_range( GTK_SHEET( THIS->obj ), &r );
  push_text( "x0" ); push_int( r.col0 );
  push_text( "y0" ); push_int( r.row0 );
  push_text( "x1" ); push_int( r.coli );
  push_text( "y1" ); push_int( r.rowi );
  f_aggregate_mapping( 4 );
}
int set_active_cell( int, int );
FUNCTION(get_active_cell, "function(void:mapping)");
{
  int x, y;
  my_pop_n_elems(args);
  gtk_sheet_get_active_cell( GTK_SHEET(THIS->obj), &x, &y );
  push_text( "row" ); push_int( x );
  push_text( "col" ); push_int( y );
  f_aggregate_mapping( 4 );
}
void set_cell( int row, int col, int justification, string text );
string cell_get_text( int, int );
void cell_clear( int, int );
FUNCTION(clear, "function(void:object)");
{
  my_pop_n_elems(args);
  gtk_sheet_range_clear(GTK_SHEET(THIS->obj), NULL);
  RETURN_THIS();
}
FUNCTION(range_clear, "function(int,int,int,int:object)");
NAME_ARGS(x0,y0,x1,y1);
{
  GtkSheetRange r;
  get_all_args( "clip_range", args, "%d%d%d%d", &r.col0,&r.row0,&r.coli,&r.rowi);
  gtk_sheet_range_clear( GTK_SHEET( THIS->obj ), &r );
  RETURN_THIS();
}
int cell_get_state( int, int );

FUNCTION(get_pixel_info, "function(int,int:mapping)");
{
  int x, y, r, c;
  get_all_args( "get_pixel_info", args, "%d%d", &x, &y );

  my_pop_n_elems(args);
  gtk_sheet_get_pixel_info( GTK_SHEET(THIS->obj),x,y, &r, &c );
  push_text( "row" ); push_int( r );
  push_text( "col" ); push_int( c );
  f_aggregate_mapping( 4 );
}
FUNCTION(range_set_foreground, "function(int,int,int,int,object:object)");
NAME_ARGS(x0,y0,x1,y1,color);
{
  GtkSheetRange r;
  struct object *c;
  get_all_args( "range_set_foreground", args, "%d%d%d%d%o",
                &r.col0,&r.row0,&r.coli,&r.rowi,&c);
  gtk_sheet_range_set_foreground( GTK_SHEET( THIS->obj ),
                                  r, get_gdkobject( c, Color ) );
  RETURN_THIS();
}
FUNCTION(range_set_background, "function(int,int,int,int,object:object)");
NAME_ARGS(x0,y0,x1,y1,color);
{
  GtkSheetRange r;
  struct object *c;
  get_all_args( "range_set_background", args, "%d%d%d%d%o",
                &r.col0,&r.row0,&r.coli,&r.rowi, &c);
  gtk_sheet_range_set_background( GTK_SHEET( THIS->obj ),
                                  r, get_gdkobject( c, Color ) );
  RETURN_THIS();
}
FUNCTION(range_set_font, "function(int,int,int,int,object:object)");
NAME_ARGS(x0,y0,x1,y1,color);
{
  GtkSheetRange r;
  struct object *c;
  get_all_args( "range_set_background", args, "%d%d%d%d%o",
                &r.col0,&r.row0,&r.coli,&r.rowi, &c);
  gtk_sheet_range_set_font( GTK_SHEET( THIS->obj ),
                            r, get_gdkobject( c, Font ) );
  RETURN_THIS();
}
FUNCTION(range_set_border_color, "function(int,int,int,int,object:object)");
NAME_ARGS(x0,y0,x1,y1,color);
{
  GtkSheetRange r;
  struct object *c;
  get_all_args( "range_set_border_color", args, "%d%d%d%d%o",
                &r.col0,&r.row0,&r.coli,&r.rowi, &c);
  gtk_sheet_range_set_border_color( GTK_SHEET( THIS->obj ),
                                    r, get_gdkobject( c, Color ) );
  RETURN_THIS();
}
FUNCTION(range_set_justification, "function(int,int,int,int,int:object)");
NAME_ARGS(x0,y0,x1,y1,justification);
{
  GtkSheetRange r;
  int f;
  get_all_args( "range_set_justification", args, "%d%d%d%d%d",
                &r.col0,&r.row0,&r.coli,&r.rowi,&f);
  gtk_sheet_range_set_justification( GTK_SHEET( THIS->obj ), r, f );
  RETURN_THIS();
}
FUNCTION(range_set_editable, "function(int,int,int,int,int:object)");
NAME_ARGS(x0,y0,x1,y1,editable);
{
  GtkSheetRange r;
  int f;
  get_all_args( "range_set_justification", args, "%d%d%d%d%d",
                &r.col0,&r.row0,&r.coli,&r.rowi,&f);
  gtk_sheet_range_set_editable( GTK_SHEET( THIS->obj ), r, f );
  RETURN_THIS();
}
FUNCTION(range_set_visible, "function(int,int,int,int,int:object)");
NAME_ARGS(x0,y0,x1,y1,visible);
{
  GtkSheetRange r;
  int f;
  get_all_args( "range_set_justification", args, "%d%d%d%d%d",
                &r.col0,&r.row0,&r.coli,&r.rowi,&f);
  gtk_sheet_range_set_visible( GTK_SHEET( THIS->obj ), r, f );
  RETURN_THIS();
}
FUNCTION(range_set_border, "function(int,int,int,int,int:object)");
NAME_ARGS(x0,y0,x1,y1,mask,width,style);
{
  GtkSheetRange r;
  int f,q,w;
  get_all_args( "range_set_border", args, "%d%d%d%d%d%d%d",
                &r.col0,&r.row0,&r.coli,&r.rowi,&f,&q,&w);
  gtk_sheet_range_set_border( GTK_SHEET( THIS->obj ), r, f,q,w );
  RETURN_THIS();
}
void column_set_justification( int column, int justification );
// justification is one of CONST(GTK_JUSTIFY)


void set_column_width( int, int );
void set_row_height( int, int );
void add_column( int );
void add_row( int );
void insert_columns( int, int );
void insert_rows( int, int );
void delete_columns( int, int );
void delete_rows( int, int );

member int flags;
member int maxrow;
member int maxcol;
member int maxallocrow;
member int maxalloccol;
member int maxrange;
member int hoffset;
member int voffset;
member int shadow_type;
