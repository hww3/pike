PROGRAM(GdkDragContext);
// The drag context contains all information about the drag'n'drop
// connected to the signal.
// <p>
// NOIMG
#define GTK_GDKDRAGCONTEXT(X) ((GdkDragContext *)X)

FUNCTION(get_source_widget, "function(void:object)");
// Return the drag source widget.
RETURNS(GTK.Widget);
{
  pop_n_elems(args);
  push_gtkobjectclass(gtk_drag_get_source_widget(((GdkDragContext *)THIS->obj)),
                      pgtk_widget_program);
}

FUNCTION(drag_finish, "function(int,int,int:object)");
RETURNS(GDK.DragContext);
NAME_ARGS(success,del,time);
// If success is true, the drag succeded.
// If del is true, the source should be deleted.
// time is the current time. 
{
  int a, b, t;
  get_all_args("drag_finish", args, "%d%d%d", &a, &b, &t );
  gtk_drag_finish(((GdkDragContext *)THIS->obj), a, b, t);
  RETURN_THIS();
}

FUNCTION(drag_status, "function(int,int|void:object)");
RETURNS(GDK.DragContext);
NAME_ARGS( action );
{
  time_t curtime = time(0);
  gdk_drag_status( ((GdkDragContext *)THIS->obj), 
                   (args?sp[-1].u.integer:
                    ((GdkDragContext *)THIS->obj)->suggested_action),
                   curtime);
  RETURN_THIS();
}

FUNCTION(drag_drop, "function(int:object)");
NAME_ARGS(time);
{
  int t;
  get_all_args( "drop", args, "%d", &t );
  gdk_drag_drop( ((GdkDragContext *)THIS->obj), t);
  RETURN_THIS();
}


FUNCTION(drag_abort, "function(int:object)");
NAME_ARGS(time);
// Abort the drag
{
  int t;
  get_all_args( "abort", args, "%d", &t );
  gdk_drag_abort( ((GdkDragContext *)THIS->obj), t);
  RETURN_THIS();
}

FUNCTION(drop_reply, "function(int,int:object)");
NAME_ARGS(ok,time);
{
  int t, o;
  get_all_args( "reply", args, "%d%d", &o, &t );
  gdk_drop_reply( ((GdkDragContext *)THIS->obj), o, t);
  RETURN_THIS();
}



FUNCTION(drag_set_icon_widget, "function(object,int,int,int:object)");
NAME_ARGS(widget,hot_x,hot_y);
ARGS(GTK.Widget,int,int);
// Set the drag widget. This is a widget that will be shown, and then
// dragged around by the user during this drag.
{
  struct object *_o;
  int x, y;
  get_all_args( "drag_set_icon_window", args, "%o%d%d", 
                &_o, &x, &y);
  gtk_drag_set_icon_widget( ((GdkDragContext *)THIS->obj),
                            GTK_WIDGET(get_pgtkobject( _o, pgtk_widget_program )),
                            x,y );
  RETURN_THIS();
}

FUNCTION(drag_set_icon_default, "function(void:object)");
// Use the default drag icon associated with the source widget.
{
  gtk_drag_set_icon_default( ((GdkDragContext *)THIS->obj) );
  RETURN_THIS();
}

FUNCTION(drag_set_icon_pixmap, "function(object,object|void,int,int:object)");
RETURNS(GTK.Widget);
ARGS(GTK.Pixmap,GTK.Bitmap,int,int);
NAME_ARGS(image,mask,hot_x,hot_y);
// Set the drag pixmap, and optionally mask.<br>
// The hot_x and hot_y coordinates will be the location of the mouse pointer, 
// relative to the upper left corner of the pixmap.
{
  struct object *p=NULL, *m=NULL;
  int x, y;
  if(args != 4)
    error("Too few arguments to drag_set_icon_pixmap\n");
  if(sp[-args].type == T_OBJECT)
    p = sp[-args].u.object;
  if(sp[-args+1].type == T_OBJECT)
    m = sp[-args+1].u.object;
  x  = sp[-args+2].u.integer;
  y  = sp[-args+3].u.integer;

  gtk_drag_set_icon_pixmap( ((GdkDragContext *)THIS->obj),
                            gdk_colormap_get_system(),
                            get_gdkobject( p, Pixmap ),
                            get_gdkobject( m, Bitmap ),
                             x,y);
  RETURN_THIS();
}


CLASSMEMBER(suggested_action, int);
// One of CONST(GDK_ACTION);
CLASSMEMBER(actions, int);
// A bitwise or of one or more of CONST(GDK_ACTION);
CLASSMEMBER(action, int);
// One of CONST(GDK_ACTION);
CLASSMEMBER(start_time, int);
// The start time of this drag, as a unix time_t (seconds since 0:00 1/1 1970)
CLASSMEMBER(protocol, int);
// One of CONST(GDK_DRAG_PROTO)
CLASSMEMBER(is_source, int);
// Is this application the source?
