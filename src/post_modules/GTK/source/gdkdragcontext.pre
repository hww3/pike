class GdkDragContext;
// The drag context contains all information about the drag'n'drop
// connected to the signal to which it is an argument.
// <p>
// NOIMG
#define GTK_GDKDRAGCONTEXT(X) ((GdkDragContext *)X)

FUNCTION(get_source_widget, "function(void:object)");
// Return the drag source widget.
RETURNS(GTK.Widget);
{
  my_pop_n_elems(args);
  push_gtkobjectclass(gtk_drag_get_source_widget(((GdkDragContext *)THIS->obj)),
                      pgtk_widget_program);
}

FUNCTION(drag_finish, "function(int,int,int:object)");
RETURNS(GDK.DragContext);
NAME_ARGS(success,del,time);
// If success is true, the drag succeded.
// If del is true, the source should be deleted.
// time is the current time.
{
  INT_TYPE a, b, t;
  get_all_args("drag_finish", args, "%d%d%d", &a, &b, &t );
  gtk_drag_finish(((GdkDragContext *)THIS->obj), a, b, t);
  RETURN_THIS();
}

FUNCTION(drag_status, "function(int,int|void:object)");
RETURNS(GDK.DragContext);
NAME_ARGS(action);
{
  time_t curtime = time(0);
  gdk_drag_status( ((GdkDragContext *)THIS->obj),
                   (args?Pike_sp[-1].u.integer:
                    ((GdkDragContext *)THIS->obj)->suggested_action),
                   curtime);
  RETURN_THIS();
}

FUNCTION(drag_drop, "function(int:object)");
NAME_ARGS(time);
{
  INT_TYPE t;
  get_all_args( "drop", args, "%d", &t );
  gdk_drag_drop( ((GdkDragContext *)THIS->obj), t);
  RETURN_THIS();
}


FUNCTION(drag_abort, "function(int:object)");
NAME_ARGS(time);
// Abort the drag
{
  INT_TYPE t;
  get_all_args( "abort", args, "%d", &t );
  gdk_drag_abort( ((GdkDragContext *)THIS->obj), t);
  RETURN_THIS();
}

FUNCTION(drop_reply, "function(int,int:object)");
NAME_ARGS(ok,time);
{
  INT_TYPE t, o;
  get_all_args( "reply", args, "%d%d", &o, &t );
  gdk_drop_reply( ((GdkDragContext *)THIS->obj), o, t);
  RETURN_THIS();
}

FUNCTION(drag_set_icon_widget, "function(object,int,int,int:object)");
NAME_ARGS(widget,hot_x,hot_y);
ARGS(GTK.Widget,int,int);
// Set the drag widget. This is a widget that will be shown, and then
// dragged around by the user during this drag.
{
  struct object *_o;
  INT_TYPE x, y;
  get_all_args( "drag_set_icon_window", args, "%o%d%d",
                &_o, &x, &y);
  gtk_drag_set_icon_widget( ((GdkDragContext *)THIS->obj),
                            GTK_WIDGET(get_pgtkobject( _o, pgtk_widget_program )),
                            x,y );
  RETURN_THIS();
}

FUNCTION(drag_set_icon_default, "function(void:object)");
// Use the default drag icon associated with the source widget.
{
  gtk_drag_set_icon_default( ((GdkDragContext *)THIS->obj) );
  RETURN_THIS();
}

FUNCTION(drag_set_icon_pixmap, "function(object,object|void,int,int:object)");
RETURNS(GTK.Widget);
ARGS(GTK.Pixmap,GTK.Bitmap,int,int);
NAME_ARGS(image,mask,hot_x,hot_y);
// Set the drag pixmap, and optionally mask.<br>
// The hot_x and hot_y coordinates will be the location of the mouse pointer,
// relative to the upper left corner of the pixmap.
{
  struct object *p=NULL, *m=NULL;
  int x, y;
  if(args != 4)
    error("Too few arguments to drag_set_icon_pixmap\n");
  if(Pike_sp[-args].type == PIKE_T_OBJECT)
    p = Pike_sp[-args].u.object;
  if(Pike_sp[-args+1].type == PIKE_T_OBJECT)
    m = Pike_sp[-args+1].u.object;
  x  = Pike_sp[-args+2].u.integer;
  y  = Pike_sp[-args+3].u.integer;

  gtk_drag_set_icon_pixmap( ((GdkDragContext *)THIS->obj),
                            gdk_colormap_get_system(),
                            get_gdkobject( p, Pixmap ),
                            get_gdkobject( m, Bitmap ),
                             x,y);
  RETURN_THIS();
}

member int suggested_action;
// One of CONST(GDK_ACTION);
member int actions;
// A bitwise or of one or more of CONST(GDK_ACTION);
member int action;
// One of CONST(GDK_ACTION);
member int start_time;
// The start time of this drag, as a unix time_t (seconds since 0:00 1/1 1970)
member int protocol;
// One of CONST(GDK_DRAG_PROTO)
member int is_source;
// Is this application the source?



