PROGRAM(list);
// This class is not yet finished enough to be usable.
SIGNAL("selection_changed", "...");
SIGNAL("select_child", "...");
SIGNAL("unselect_child", "...");
INHERIT(container);
COMPLEX_FUNCTION(create);
FUNCTION(selection, "function(void:array(object))");
RETURNS(array(GTK.Widget));
{
  GList *s = GTK_LIST( THIS->obj )->selection;
  int j = 0;
  my_pop_n_elems(args);
  while( s )
  {
    push_gtkobjectclass( (void *)s->data, pgtk_list_item_program );
    j++;
    s = s->next;
  }
  f_aggregate( j );
}

int COMPLEX_FUNCTION(child_position, widget);
NAME_ARGS(child);
COMPLEX_FUNCTION(extend_selection, int,float,int);
NAME_ARGS(scroll_type, position, auto_start_selection);
SIMPLE_FUNCTION(start_selection);
SIMPLE_FUNCTION(end_selection);
SIMPLE_FUNCTION(select_all);
SIMPLE_FUNCTION(unselect_all);
COMPLEX_FUNCTION(scroll_horizontal, int, float);
NAME_ARGS(scroll_type, position);
COMPLEX_FUNCTION(scroll_vertical, int, float);
NAME_ARGS(scroll_type, position);
SIMPLE_FUNCTION(toggle_add_mode);
SIMPLE_FUNCTION(toggle_focus_row);
COMPLEX_FUNCTION(toggle_row, widget);
NAME_ARGS(child);
SIMPLE_FUNCTION(undo_selection);
SIMPLE_FUNCTION(end_drag_selection);

FUNCTION(insert_items, "function(array(object),int:object)");
ARGS(array(GTK.ListItem),int);
NAME_ARGS(items,position);
{
  struct array *a;
  int p;
  GList *items = NULL;
  int i;
  get_all_args("insert_items", args, "%a%d", &a, &p);
  
  for(i=0; i<a->size; i++)
    if(a->item[i].type == T_OBJECT &&
       get_pgtkobject( a->item[i].u.object, pgtk_list_item_program ))
      g_list_prepend(items, get_pgtkobject(a->item[i].u.object,
                                           pgtk_list_item_program));
  if(items)
    gtk_list_insert_items( GTK_LIST( THIS->obj ), items, p );
  g_list_free( items );
  RETURN_THIS();
}

FUNCTION(append_items, "function(array(object):object)");
ARGS(array(GTK.ListItem),int);
NAME_ARGS(items,position);
{
  struct array *a;
  GList *items = NULL;
  int i;
  get_all_args("append_items", args, "%a", &a);
  
  for(i=0; i<a->size; i++)
    if(a->item[i].type == T_OBJECT &&
       get_pgtkobject( a->item[i].u.object, pgtk_list_item_program ))
      g_list_prepend(items, get_pgtkobject(a->item[i].u.object,
                                           pgtk_list_item_program));
  if(items)
    gtk_list_append_items( GTK_LIST( THIS->obj ), items );
  g_list_free( items );
  RETURN_THIS();
}

FUNCTION(prepend_items, "function(array(object):object)");
ARGS(array(GTK.ListItem),int);
NAME_ARGS(items,position);
{
  struct array *a;
  GList *items = NULL;
  int i;
  get_all_args("prepend_items", args, "%a", &a);
  
  for(i=0; i<a->size; i++)
    if(a->item[i].type == T_OBJECT &&
       get_pgtkobject( a->item[i].u.object, pgtk_list_item_program ))
      g_list_prepend(items, get_pgtkobject(a->item[i].u.object,
                                           pgtk_list_item_program));
  if(items)
    gtk_list_prepend_items( GTK_LIST( THIS->obj ), items );
  g_list_free( items );
  RETURN_THIS();
}

FUNCTION(remove_items, "function(array(object):object)");
ARGS(array(GTK.ListItem),int);
NAME_ARGS(items,position);
{
  struct array *a;
  GList *items = NULL;
  int i;
  get_all_args("remove_items", args, "%a", &a);
  
  for(i=0; i<a->size; i++)
    if(a->item[i].type == T_OBJECT &&
       get_pgtkobject( a->item[i].u.object, pgtk_list_item_program ))
      g_list_prepend(items, get_pgtkobject(a->item[i].u.object,
                                           pgtk_list_item_program));
  if(items)
    gtk_list_remove_items( GTK_LIST( THIS->obj ), items );
  g_list_free( items );
  RETURN_THIS();
}


COMPLEX_FUNCTION(clear_items, int, int);
NAME_ARGS(start,end);
COMPLEX_FUNCTION(select_item, int);
NAME_ARGS(item);
COMPLEX_FUNCTION(unselect_item, int);
NAME_ARGS(item);
COMPLEX_FUNCTION(select_child, widget);
NAME_ARGS(child);
COMPLEX_FUNCTION(unselect_child, widget);
NAME_ARGS(child);
COMPLEX_FUNCTION(set_selection_mode, int);
NAME_ARGS(selection_mode);

SUBWIDGET(last_focus_child, list_item);
SUBWIDGET(undo_focus_child, list_item);

CLASSMEMBER(htimer,int);
CLASSMEMBER(vtimer,int);
CLASSMEMBER(anchor,int);
CLASSMEMBER(drag_pos,int);
CLASSMEMBER(anchor_state,int);
CLASSMEMBER(selection_mode,int);
CLASSMEMBER(drag_selection,int);
CLASSMEMBER(add_mode,int);
