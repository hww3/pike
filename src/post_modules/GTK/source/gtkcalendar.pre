PROGRAM(calendar);
// A calendar widget.
// IMG: GTK.Calendar();
// IMG: GTK.Calendar()->select_day( 16 );
INHERIT(widget);

SIGNAL("month_changed", "");
SIGNAL("day_selected", "");
SIGNAL("day_selected_double_click", "");
SIGNAL("prev_month", "");
SIGNAL("next_month", "");
SIGNAL("prev_year", "");
SIGNAL("next_year", "");

COMPLEX_FUNCTION(create);
// Create a new calendar widget

int COMPLEX_FUNCTION(select_month, int, int);
NAME_ARGS(month, year);
// Select the month to be viewed.

COMPLEX_FUNCTION(select_day, int);
NAME_ARGS(day_of_month);
// Select a certain day of the currently selected month

COMPLEX_FUNCTION(mark_day, int);
NAME_ARGS(day_of_month);
// Mark a day

COMPLEX_FUNCTION(unmark_day, int);
NAME_ARGS(day_of_month);
// Unmark a day

SIMPLE_FUNCTION(clear_marks);
// Remove all day markers
COMPLEX_FUNCTION(display_options, int);
NAME_ARGS(options);
// Bitwise or of one or more of CONST(GTK_CALENDAR).

FUNCTION(get_date, "function(void:mapping)");
// returns a mapping:<br>
// ([ "year":year, "month":month, "day":day ])
{
  guint y, m, d;
  gtk_calendar_get_date( GTK_CALENDAR( THIS->obj ), &y, &m, &d );
  push_text("year");
  push_int( y );
  push_text("month");
  push_int( m );
  push_text("day");
  push_int( d );
}

SIMPLE_FUNCTION(freeze);
// Suspend all dynamic updating of the widget
SIMPLE_FUNCTION(thaw);
// Resume dynamic updating of the widget

CLASSMEMBER(focus_row, int);
// The currently focused row
CLASSMEMBER(focus_col, int);
// The currently focused column
CLASSMEMBER(highlight_row, int);
// The currently highlighted row
CLASSMEMBER(highlight_col, int);
// The currently highlighted column

CLASSMEMBER(month, int);
// The current month
CLASSMEMBER(year, int);
// The current year
CLASSMEMBER(selected_day, int);
// The currently selected day
CLASSMEMBER(num_marked_dates, int);
// The number of days that are marked

FUNCTION(get_marked_dates, "function(void:array(int))");
// Returns an array (with 31 elements) with 1es and 0es.
{
  int i;
  for(i=0; i<31; i++)
    push_int( GTK_CALENDAR( THIS->obj )->marked_date[i] );
  f_aggregate( 31 );
}

FUNCTION(get_day_month, "function(void:array(array(int)))");
// Return an array of 6x7 days, representing the cells in the 
// currently viewed calendar month.  The value is the day of month.
{
  int i,j;
  for(i=0; i<6; i++)
  {
    for(j=0; j<7; i++)
      push_int( GTK_CALENDAR( THIS->obj )->day_month[i][j] );
    f_aggregate( 7 );
  }
  f_aggregate( 6 );
}

FUNCTION(get_day, "function(void:array(array(int)))");
// Return an array of 6x7 days, representing the cells in the 
// currently viewed calendar month. 
{
  int i,j;
  for(i=0; i<6; i++)
  {
    for(j=0; j<7; i++)
      push_int( GTK_CALENDAR( THIS->obj )->day[i][j] );
    f_aggregate( 7 );
  }
  f_aggregate( 6 );
}

FUNCTION(set_marked_date_color, "function(int,object:object)");
ARGS(int,GDK.Color);
NAME_ARGS(index,color);
// Set the color to use to mark dates
{
  int n;
  struct object *o;
  get_all_args( "set_marked_date_color", args, "%d%o", &n, &o );
  if(!get_gdkobject(o, Color))
    error("Argument 2 is not a GDK.Color object\n");
  n--;
  if(n > 30 || n<0)
    error("Argument 1 is not between 1 and 31, inclusive\n");
  GTK_CALENDAR( THIS->obj )->marked_date_color[n] = *get_gdkobject(o, Color);
  RETURN_THIS();
}

