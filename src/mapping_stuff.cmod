/*\
||| This file a part of Pike, and is copyright by Fredrik Hubinette
||| Pike is distributed as GPL (General Public License)
||| See the files COPYING and DISCLAIMER for more information.
\*/
/**/
#include "global.h"
RCSID("$Id: mapping_stuff.cmod,v 1.1 2001/02/22 19:18:08 hubbe Exp $");
#include "main.h"
#include "object.h"
#include "mapping.h"
#include "svalue.h"
#include "array.h"
#include "pike_macros.h"
#include "pike_error.h"
#include "pike_memory.h"
#include "dynamic_buffer.h"
#include "interpret.h"
#include "las.h"
#include "gc.h"
#include "stralloc.h"
#include "security.h"
#include "block_alloc.h"
#include "opcodes.h"
#include "pike_error.h"
#include "program.h"

DECLARATIONS

PIKECLASS mapping_iterator
{
  /* All variables *must* be before all functions! */
  CVAR int bucket;
  CVAR struct mapping *m;
  CVAR struct mapping_data *md;
  CVAR struct keypair *current;

  PIKEFUN mixed value()
    {
      if(THIS->current)
	push_svalue(& THIS->current->val);
      else
      {
	push_int(0);
	Pike_sp[-1].subtype=NUMBER_UNDEFINED;
      }
    }

  PIKEFUN mixed index()
    {
      if(THIS->current)
	push_svalue(& THIS->current->ind);
      else
      {
	push_int(0);
	Pike_sp[-1].subtype=NUMBER_UNDEFINED;
      }
    }

  static int step_bucket(struct mapping_iterator_struct *i)
    {
      while(! i->current)
      {
	i->bucket++;
	if(i->bucket >= i->md->hashsize)
	  return 0;
	i->current=i->md->hash[i->bucket];
      }
      return 1;
    }

  static int mi_step(struct mapping_iterator_struct *i)
    {
      if(! i->current) return 0;
      i->current=i->current->next;
      return step_bucket(i);
    }
  
  PIKEFUN object `+(int steps)
    {
      struct object *o=low_clone(mapping_iterator_program);
      OBJ2_MAPPING_ITERATOR(o)[0] = *THIS;
      add_ref(THIS->m);
      add_ref(THIS->md);
      THIS->md->valrefs++;
      while(--steps>=0 && mi_step(OBJ2_MAPPING_ITERATOR(o)));
      RETURN o;
    }

  PIKEFUN object `+=(int steps)
    {
      while(--steps>=0 && mi_step(THIS));
      REF_RETURN Pike_fp->current_object;
    }

  PIKEFUN int first()
    {
      THIS->current=0;
      THIS->bucket=-1;
      RETURN step_bucket(THIS);
    }

  PIKEFUN int next() { RETURN mi_step(THIS); }
  PIKEFUN int `!() { RETURN !THIS->current; }

  PIKEFUN void create(mapping map)
    {
      if(THIS->m)
	Pike_error("Mapping iterators cannot be reused.\n");

      add_ref(THIS->m=map);
      THIS->md=map->data;
      add_ref(THIS->md);
      THIS->md->valrefs++;
      THIS->bucket=-1;
      step_bucket(THIS);
    }

  INIT
    {
      THIS->m=0;
      THIS->md=0;
      THIS->current=0;
      THIS->bucket=0;
    }

  EXIT
    {
      free_mapping(THIS->m);
      THIS->md->valrefs--;
      free_mapping_data(THIS->md);
    }
};


void init_mapping_stuff(void)
{
  INIT
}

void exit_mapping_stuff(void)
{
  EXIT
}

