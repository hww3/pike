test_true([["$Id: testsuite.in,v 1.447 2001/08/02 22:24:11 hubbe Exp $"]]);

cond([[all_constants()->_verify_internals]],
[[
  test_do(_verify_internals())
]]);
test_eq(1e1,10.0);
test_eq(1E1,10.0);
test_eq(1e+1,10.0);
test_eq(1.1e1,11.0);
test_eq(1e-1,0.1);
test_eq('\x20',32);
test_eq("\x20","\040");
test_eq("\d32","\x20");
test_eq('Å',"Å"[0]);
test_eq('\7777',"\7777"[0]);
test_eq('\77777777',"\77777777"[0]);
test_eq("\x10000","\x10000");
test_eq(0x80000000-0x80000000, 0);
test_eq(0xf0000000-0xf0000000, 0);
test_eq(0x80000001-0x80000000, 1);
test_eq(0x80000000-0x80000001,-1);
test_eq(-2147483648*-1, -2147483648/-1);
test_true([[1.0e-40]]);
test_eq([[#"foo
bar"]],[["foo\nbar"]]);
test_eq([[#"foo\
bar"]],[["foobar"]]);
test_true([[stringp(#string "Makefile")]]);
test_any([[class Bar { array(int) foo = ({}); };
	   class Foo { inherit Bar; array(int) foo = ({1}); };
	   return sizeof(Foo()->foo);]],1);

test_eq(8, 0b1000);
test_eq(-8, -0b1000);
test_eq(16, 0b10000);
test_eq(-16, -0b10000);

test_any([[
class X
{
  int Ack(int M, int N) {
    if (M == 0) return( N + 1 );
    if (N == 0) return( Ack(M - 1, 1) );
    return( Ack(M - 1, Ack(M, (N - 1))) );
  }
};

class Y { inherit X; };

return Y()->Ack(2,2);
]],7)

test_eval_error([[mixed x; return mkmapping(x,x)]]);

test_eval_error([[class Foo {
  void bar() {}
  void foo() {destruct(this_object());bar();}
};
  Foo()->foo();
]])

test_do([[
  void foo (int i) {
    multiset res = (<>);
    if (i) res = res;
  };
  foo (1);
]])

test_any([[
  array tmp=({});
  tmp=({([])})+tmp;
  tmp->foo=7;
  tmp=({([])})+tmp;
  return sizeof(tmp[0]);
]], 0)


test_any([[int a=0xffffffff; return a+17]], 0x100000010);
test_any([[int a=0xffffffff; return a-17]], 0xffffffee);
test_any([[int a=0xffffffff; return a*17]], 0x10ffffffef);
test_any([[int a=0xffffffff; return a^17]], 0xffffffee);
test_any([[int a=0xffffffff; return a&17]], 17);
test_any([[int a=0xffffffff; return a|17]], 0xffffffff);
test_any([[int a=0xffffffff; return a<<17]], 0x1fffffffe0000);

test_any([[ int a=0xffffffff; return a/17 ]],
	 [[ (0xffffffff == -1)?-1:0x0f0f0f0f ]]);
test_any([[ int a=0xffffffff; return a%17 ]],
	 [[ (0xffffffff == -1)?16:0 ]]);
test_any([[ int a=0xffffffff; return a>>17 ]],
	 [[ (0xffffffff == -1)?-1:0x7fff ]]);

test_any([[return sprintf("%O", typeof(aggregate("foo")));]], "array(string)");
test_any([[int a; return sprintf("%O", typeof(aggregate(a)));]], "array(int)");
test_any([[int|string a;
	   string s = sprintf("%O", typeof(aggregate(a)));
	   return (< "array(string | int)", "array(int | string)" >)[s];]], 1);
test_any([[return sprintf("%O", typeof(aggregate()));]], "array(zero)");
test_any([[int i; return (< "int", "int | zero", "zero | int" >)
                          [sprintf("%O", typeof(max(i,0)))];]], 1)

test_any([[array(string) a; return sprintf("%O", typeof(a[0])); ]], "string")

test_any([[class foo { string a; };
	   object(foo) bar;
	   return sprintf("%O", typeof(bar->a));]], "string");

test_any([[class foo { string a; };
	   array(object(foo)) bar;
	   return sprintf("%O", typeof(bar[0]->a));]], "string");

test_any([[function(:string)|function(int:int) f;
	   return sprintf("%O", typeof(f())); ]],
	 "string")

test_any([[function(:string)|function(int:int) f;
	   return sprintf("%O", typeof(f(1))); ]],
	 "int")

test_any([[function(:string)|function(mixed, mixed...:int) f;
	  return sprintf("%O", typeof(f())); ]],
	 "string")

test_any([[function(:string)|function(mixed, mixed ...:int) f;
	  return sprintf("%O", typeof(f(1))); ]],
	 "int")

test_any([[mapping(object:string)|mapping(string:int) f;
	  return sprintf("%O", typeof(f[class{}()])); ]],
	 "string")

test_any([[mapping(object:string)|mapping(string:int) f;
	  return sprintf("%O", typeof(f[""])); ]],
	 "int")

test_any([[mapping(object:string)|mapping(string:int) f;
	  return sort((sprintf("%O", typeof(f[0])) - " ")/"|")*"|"; ]],
	 "int|string")

test_any([[class Foo { string `[](mixed y) {return "";} };
	  object(Foo) foo;
	  return sprintf("%O", typeof(foo[0])); ]],
	 "string")

test_any([[class Foo { array(int) _indices() {return ({0});} };
	  object(Foo) foo;
	  return sprintf("%O", typeof(indices(foo))); ]],
	 "array(int)")

test_any([[class Foo { array(string) _values() {return ({""});} };
	  object(Foo) foo;
	  return sprintf("%O", typeof(values(foo))); ]],
	 "array(string)")

test_any([[mapping(string:int) foo;
	  array(string) bar;
	  return sprintf("%O", typeof(rows(foo, bar))); ]],
	 "array(int)")

test_any([[{
  class Foo
  {
    mixed m;
  };
  class Bar
  {
    inherit Foo;
    string m;
    Foo b;
    mixed f() {
      return typeof(b->m);
    }
  };
  Foo c;
  Bar d;
  return sprintf("%O$%O$%O$%O",
                 Bar()->f(), typeof(c->m), typeof(d->m), typeof(d->b->m));
}]], "mixed$mixed$string$mixed")

// type checks

define(test_type_error, [[
   test_compile_error([[ $1 x; x=$3; ]])
   test_compile_error_low([[ class ErrBa { $1 x() { return $3; } } ]])
   test_compile_error_low([[ class ErrBa { $1 x() { $2 a=$3; return a; } } ]])
]])

test_type_error(int,float,17.23)
test_type_error(int,array,({1,2,3}))
test_type_error(int,mapping,([1:2,3:4]))
test_type_error(int,multiset,(<1,2,3>))
test_type_error(int,function,lambda() { return 17; })
test_type_error(int,program,object_program(this_object()))
test_type_error(int,object,this_object())

test_type_error(float,int,17)
test_type_error(float,array,({1,2,3}))
test_type_error(float,mapping,([1:2,3:4]))
test_type_error(float,multiset,(<1,2,3>))
test_type_error(float,function,lambda() { return 17; })
test_type_error(float,program,object_program(this_object()))
test_type_error(float,object,this_object())

test_type_error(array,int,17)
test_type_error(array,float,17.23)
test_type_error(array,mapping,([1:2,3:4]))
test_type_error(array,multiset,(<1,2,3>))
test_type_error(array,function,lambda() { return 17; })
test_type_error(array,program,object_program(this_object()))
test_type_error(array,object,this_object())

test_type_error(mapping,int,17)
test_type_error(mapping,float,17.23)
test_type_error(mapping,array,({1,2,3}))
test_type_error(mapping,multiset,(<1,2,3>))
test_type_error(mapping,function,lambda() { return 17; })
test_type_error(mapping,program,object_program(this_object()))
test_type_error(mapping,object,this_object())

test_type_error(multiset,int,17)
test_type_error(multiset,float,17.23)
test_type_error(multiset,array,({1,2,3}))
test_type_error(multiset,mapping,([1:2,3:4]))
test_type_error(multiset,function,lambda() { return 17; })
test_type_error(multiset,program,object_program(this_object()))
test_type_error(multiset,object,this_object())

test_type_error(function,int,17)
test_type_error(function,float,17.23)
test_type_error(function,array,({1,2,3}))
test_type_error(function,mapping,([1:2,3:4]))
test_type_error(function,multiset,(<1,2,3>))

test_type_error(program,int,17)
test_type_error(program,float,17.23)
test_type_error(program,array,({1,2,3}))
test_type_error(program,mapping,([1:2,3:4]))
test_type_error(program,multiset,(<1,2,3>))

test_type_error(object,int,17)
test_type_error(object,float,17.23)
test_type_error(object,array,({1,2,3}))
test_type_error(object,mapping,([1:2,3:4]))
test_type_error(object,multiset,(<1,2,3>))

test_compile_error([[ string a="abcb"; a=a/"b"; ]])
test_compile_error([[ string a="abcb"; a/="b"; ]])
test_compile_error([[ string a="abcb"; string b="b"; a=a/b; ]])
test_compile_error([[ string a="abcb"; string b="b"; a/=b; ]])
test_compile_error([[ string a="x"; int b; b="x"*17; ]])
test_compile_error([[ string a="x"; array b; b="x"*17; ]])
test_compile_error([[ int b=17; string a; a=b*42; ]])
test_compile_error([[ int b=17; float c=42.0; b=b/c; ]])
test_compile_error([[ int b=17; float c=42.0; b/=c; ]])
test_compile_error([[ int b=17; float c=42.0; b=b*c; ]])
test_compile_error([[ int b=17; float c=42.0; b*=c; ]])
test_compile_error([[ int b=17; float c=42.0; b=b+c; ]])
test_compile_error([[ int b=17; float c=42.0; b+=c; ]])
test_compile_error([[ int b=17; float c=42.0; b=b-c; ]])
test_compile_error([[ int b=17; float c=42.0; b-=c; ]])
test_compile_error([[ float b=17.0; string a; a=b*42; ]])
test_compile_error([[ float b=17.0; string a; a=b*42.0; ]])

//

test_any([[
  class Foo {
    constant zero = 0;
    mapping(string:array(int)) m;
    string foo() { return sprintf("%O", typeof(m[""][zero])); }
  };
  return Foo()->foo();
]], "int")

test_compile_any([[
  class { ; }
]])

test_compile_any([[
  class { ; ; }
]])

test_compile_any([[
  class { ; constant c = 0; }
]])

test_compile_any([[
  class { void a() {  constant c = 17; }
	  void b() {  constant c = 17; }  }
]])

test_compile_any([[
  constant FOO = 0;
  mapping(int:string) foo = ([FOO: "foo"]);
]])

test_compile_error([[
  function(...:int) foo;
]]);

test_compile_error([[
  function(,...:int) foo;
]]);

test_compile_error([[
  function(string,...:int) foo;
]]);

test_any([[return class Z {
string bonk() { return "oiff"; }

class A
{
  string bonk_me() { return bonk(); }
}

class B { inherit A; }

class C
{
  string oiff() { return "bonk"; }
  class D { inherit B; }
}
}()->C()->D()->bonk_me()]],"oiff")

test_compile_error([[
 class A { constant q = "x"; }
 class B { inherit A; string z="z"; constant q="x"+z; }
]])

test_compile_any([[
  class A
  {
     object x(int y)
     {
        return B(y);
     }
  }
  
  class B
  {
     void create(int y)
     {
     }
  }
]])

// Test that prototypes evaluate to false.
test_any([[
  class Foo
  {
    int foo();
    int(0..1) f()
    {
      return !foo;
    }
  };
  return Foo()->f();
]], 1)

test_any([[
  class Foo
  {
    int foo();
  };
  return !Foo()->foo;
]], 1)

test_do([[
class Foo
{
  inherit Stdio.File;

  void create() {  }
};

class Bar
{
  int y;


  class Gazonk
  {
    inherit Foo;
    

    void create(Stdio.File f)
      {
	assign(f);
      }
  }

  void create()
    {
      Gazonk(Stdio.stdin);
    }
};

Bar();

]])

test_any([[
  object f = class {
      array recursive(mixed func, array data, mixed ... args)
      {
	array ret=({});

	foreach(data, mixed foo)
	{
	  if(arrayp(foo))
	  {
	    ret+=({ recursive(func, foo, @args) });
	  }else{
	    ret+=({ foo });
	  }
	}
  
	return func(ret, @args);
      };
    }();

  mixed x = ({ "A", ({}) });
  x = f->recursive(replace, x, "B", ({}));

  for(int i = 0; i < sizeof(x); i++) {
    if (!stringp(x[i]) && !arrayp(x[i])) return 0;
  }
  return 1;
]], 1);

// This test checks for excessive recursion in
// destruct_objects_to_destruct, and also that it keeps the destruct
// order sane.
test_do([[
  class Top
  {
    int count = 0;

    class Foo
    {
      int c;
      object foo;
      static void create(object o)
      {
	foo = o;
	c = count++;
      }

      void destroy()
      {
	count--;
	if (count != c)
	  error ("Destruct out of sequence, "
		 "%d destructed when %d should be.\n", c, count);
	object x = foo && Foo(0);
	x = 0;
	// Cause call to destruct_objects_to_destruct.
	for (int j = 0; j < 10; j++) werror ("");
      }
    }

    mixed eat_stack()
    {
      mixed err = 1;
      if (catch (err = eat_stack()) || err != 10)
	return intp (err) && err > 0 ? err + 1 : err;
      if (err = catch {

	Foo foo;
	for(int i=0; i < 10000; i++)
	  foo = Foo(foo);
	foo = 0;
	// Cause call to destruct_objects_to_destruct.
	for (int j = 0; j < 10; j++) werror ("");

      }) return err;
    }

    static void create()
    {
      if (mixed err = eat_stack()) {
	catch (err[1] = err[1][sizeof (err[1]) - 50..]);
	throw (err);
      }
    }
  };

  Top();
]]);

// Testing stack popping in the tail recursion opcodes
test_program([[
  inherit Thread.Mutex : monitor;
  int f (int x)
  {
    if(monitor::trylock(1))
      return 0;
    return x;
  }
  int a()
  {
    object key = monitor::lock();
    return f (1); // F_CALL_LFUN_AND_RETURN
  };
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  int f (int x)
  {
    if(monitor::trylock(1))
      return 0;
    return x;
  };
  mixed g = f;
  int a()
  {
    object key = monitor::lock();
    return g (1); // F_CALL_FUNCTION_AND_RETURN
  }
]]);
test_program([[
  Thread.Mutex monitor = Thread.Mutex();
  int f (int x)
  {
    if(monitor->trylock(1))
      return 0;
    return x;
  }
  int a()
  {
    add_constant ("f", f);
    add_constant ("monitor", monitor);
    return compile_string(#"
      int g()
      {
	object key = monitor->lock();
	return f (1); // F_APPLY_AND_RETURN
      }")()->g();
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  int iter = 0;
  int a (void|int x)
  {
    if (iter == 1) {
      if (monitor::trylock(1))
	return 0;
      return x;
    }
    else {
      object key = monitor::lock();
      iter = 1;
      return a (1); // F_COND_RECUR
    }
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  int iter = 0;
  int a (void|int x)
  {
    if (!iter) {
      iter = 1;
      return a (x);
    }
    else if (iter == 2) {
      if (monitor::trylock(1))
	return 0;
      return x;
    }
    else {
      object key = monitor::lock();
      iter = 2;
      return a (1); // F_TAIL_RECUR
    }
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  int iter = 0;
  int a (void|int x)
  {
    if (!iter) {
      iter = 1;
      return a (x);
    }
    else if (iter == 2) {
      if (monitor::trylock(1))
	return 0;
      return x;
    }
    else {
      object key = monitor::lock();
      iter = 2;
      int res = a (1); // F_RECUR
      iter = -1;
      return res;
    }
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  int iter = 0;
  int a (void|int x)
  {
    if (!iter) {
      iter = 1;
      return a (x);
    }
    else if (iter == 2) {
      if (monitor::trylock(1))
	iter = 0;
      iter = x;
    }
    else {
      object key = monitor::lock();
      iter = 2;
      a (1); // F_RECUR_AND_POP
      return iter;
    }
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  int f (int x)
  {
    if(monitor::trylock(1))
      return 0;
    return x;
  }
  int a()
  {
    foreach (({0, monitor::lock()}), mixed m)
      return f (1); // F_CALL_LFUN_AND_RETURN
  };
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  int f (int x)
  {
    if(monitor::trylock(1))
      return 0;
    return x;
  };
  mixed g = f;
  int a()
  {
    foreach (({0, monitor::lock()}), mixed m)
      return g (1); // F_CALL_FUNCTION_AND_RETURN
  }
]]);
test_program([[
  Thread.Mutex monitor = Thread.Mutex();
  int f (int x)
  {
    if(monitor->trylock(1))
      return 0;
    return x;
  }
  int a()
  {
    add_constant ("f", f);
    add_constant ("monitor", monitor);
    return compile_string(#"
      int g()
      {
	foreach (({0, monitor->lock()}), mixed m)
	  return f (1); // F_APPLY_AND_RETURN
      }")()->g();
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  int iter = 0;
  int a (void|int x)
  {
    if (iter == 1) {
      if (monitor::trylock(1))
	return 0;
      return x;
    }
    else {
      iter = 1;
      foreach (({0, monitor::lock()}), mixed m)
	return a (1); // F_COND_RECUR
    }
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  int iter = 0;
  int a (void|int x)
  {
    if (!iter) {
      iter = 1;
      return a (x);
    }
    else if (iter == 2) {
      if (monitor::trylock(1))
	return 0;
      return x;
    }
    else {
      iter = 2;
      foreach (({0, monitor::lock()}), mixed m)
	return a (1); // F_TAIL_RECUR
    }
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  int iter = 0;
  int a (void|int x)
  {
    if (!iter) {
      iter = 1;
      return a (x);
    }
    else if (iter == 2) {
      if (monitor::trylock(1))
	return 0;
      return x;
    }
    else {
      iter = 2;
      int res;
      foreach (({0, monitor::lock()}), mixed m) {
	res = a (1); // F_RECUR
	iter = random (res);
	return res;
      }
    }
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  int iter = 0;
  int a (void|int x)
  {
    if (!iter) {
      iter = 1;
      return a (x);
    }
    else if (iter == 2) {
      if (monitor::trylock(1))
	iter = 0;
      iter = x;
    }
    else {
      iter = 2;
      foreach (({0, monitor::lock()}), mixed m) {
	a (1); // F_RECUR_AND_POP
	return iter;
      }
    }
  }
]]);

test_false([[object_variablep(class X { int y; int z() { return 1; }}(),"foo")]])
test_false([[object_variablep(class X { int y; int z() { return 1; }}(),"z")]])
test_true([[object_variablep(class X { int y; int z() { return 1; }}(),"y")]])

test_any([[ int a,b; [a,b]=({1,2}); return a]],1)
test_any([[ int a,b; [a,b]=({1,2}); return b]],2)
test_any([[ int a,b; [ [a],b]=({ ({ 1 }) ,2}); return a]],1)
test_any([[ int a,b; [ [a],b]=({ ({ 1 }) ,2}); return b]],2)
test_any([[ int a; catch { [a]=({1,2}); }; return 1]],1)
test_any([[ int a,b; catch { [a,b]=({1}); }; return 1]],1)
test_any([[ mapping m=([]); m[m]=m; return stringp(sprintf("%O",m)); ]],1)

test_any([[
  int q() { throw(1); };
  catch {
     return q();
  };
  return 17;
]],17)

test_any([[
 return class
 {
   int q() { throw(1); };
   int p() {
     catch {
        return q();
     };
     return 17;
   }
 }()->p();
]],17)

test_compile_error([[
  static function foo(string ...:object);
  int bar()
  {
    return 17;
  }
]])
test_compile_error([[ 
  array a;
  a = path_info[..(sizeof(path_info)-2]*"/";
]])
test_compile_error([[ default ; ]])
test_compile_error([[ 0999; ]])
test_compile_error([[ int a,b; [a,b]++; ]])
test_compile_error([[
array(int) x;

string foo()
{
 return "foo "+(array(string) x) * ",";
}

int main()
{
  return 0;
}
]])

dnl
dnl this_program
dnl
test_true(this_program)
test_any([[int this_program; return this_program;]], 0)
test_any([[class A { int a() { return this_program == A; }}; return A()->a();]], 1)

dnl test_compile_error(0())
test_compile_error(1())
test_compile_error(""())
test_compile_error(([])())
test_compile_error(([])())
test_any([[ class X { int y; class Z { void destroy() { y++; } } }; X x=X(); destruct(x->Z()); return x->y;]],1)

test_eval_error([[ class Z { int destroy() { return 1/y; } }(); ]])

test_any([[ class X { int y; class Z { static void destroy() { y++; } } }; X x=X(); destruct(x->Z()); return x->y;]],1)
test_any([[ class X { int y; class Z { static void create() { y++; } } }; X x=X(); destruct(x->Z()); return x->y;]],1)

cond([[all_constants()->_debug]],
[[
  test_do(_debug(_debug(0)))
]])
test_do(_static_modules())
test_compile_any([[import Stdio; class x { string y() { read_file("foo"); } }]])

dnl ----------------------------------------------------------------
dnl scopes and stuff
dnl ----------------------------------------------------------------

dnl
dnl Undocumented but important behaviour...
dnl
test_eq([[Stdio._stdin]],[[Stdio.stdin->_fd]])

test_compile_any([[
class Bar
{
  int f() {return 17;}

  class Foo {
    int g() {return f();}
  }

  inherit Foo;
}
]])
test_compile_any([[
class Bar
{
  int f() {return 17;}

  class Foo {
    int g() {return f();}
  }
}

class Gnu
{
  inherit Bar;
  inherit Foo;
}

]])

test_any([[
 Stdio.write_file("testsuite_test.pmod",
	#"
// this crashes Pike /Mirar 2001-05-19
// I haven't been able to minimize it futher,
// and it needs to be in a separate module.

mapping es=0;

string efoo(string e)
{
   if (!es)
   {
      mapping res=([]);

      string l;

      if (sscanf(l,\"%s%s\",string ext,string type)==4 &&
	  ext!=\"\" && ext[0]!=\"#\") // note the type error
	 res[ext]=type;

      es=res;
   }
}	
	");

 // Compilation handler that hides compilation errors.
 class handler
 {
   void compile_error(string file, int line, string err)
   {
     // werror("file: %O, line: %O, err: %O\n", file, line, err);
   }
 };

 // turn this on when the bug is found
 // master()->set_inhibit_compile_errors(lambda(){});

 //_optimizer_debug(2);
 //_assembler_debug(20);

 catch {
   compile_string("import \".\";\n"
                  "int foo() { testsuite_test.efoo; }\n",
		  "testsuite_test", handler());
 };
 return 0;
]],0);

test_compile_any([[int log() { return 17; } class Greta { int hanna() { return log(); } }]])
test_compile_any([[int kajsa(int a,int b) { return 17; } class Jenny { int kajsa() { return 17; } class Greta { int hanna() { return kajsa(); } } }]])
test_any([[add_constant("kajsa",lambda(int a,int b) { return 17; }); return compile_string("int kajsa() { return 17; } class Greta { int hanna() { return kajsa(); } }")()->kajsa()]],17)

test_compile([[Stdio.File foo=Stdio.File();]])
test_compile([[  string|multiset(string) foo;
  array(string) gazonk;
  array(string) bar = indices(foo)-gazonk;
]])
test_compile([[class { Stdio.File foo=Stdio.File(); }]])
test_compile_any([[void foo(Stdio.FILE f) {}]])
test_compile_any([[void foo(array(Stdio.FILE) f) {}]])
test_compile_any([[void foo(array(Stdio.FILE) f) {}]])
test_compile_any([[Stdio.File foo(array(Stdio.FILE) f) { return f[0]; }]])
test_compile_any([[
class a {
  int `== (mixed x) {
    return 0;
  }
}

class b {
  inherit a;
  class c {
    int d (string x, string y) {
      return x==y;
     }
  }
}
]])
test_compile([[Stdio.File foo=Stdio.FILE();]])

test_any([[string gurk="bozo"; string b(int x) { return (x?b(x-1)+gurk:""); }; return b(5)]],[["bozo"*5]])

dnl this should really work...
dnl test_compile_any([[void foo(int,string,...);]])

dnl This test doesn't run out of stack anymore, freaky
dnl test_eval_error([[class X { int create() { create(); } }();]])
test_compile_error([[ int float; ]])
test_compile_error([[ int array; ]])
test_compile_error([[ int function; ]])
test_compile_error([[ int int; ]])
test_compile_error([[ int mapping; ]])
test_compile_error([[ int multiset; ]])
test_compile_error([[ int object; ]])
test_compile_error([[ int string; ]])
test_compile_error([[ int void; ]])
test_compile_error([[ int inline; ]])
test_compile_error([[ int local; ]])
test_compile_error([[ int nomask; ]])
test_compile_error([[ int predef; ]])
test_compile_error([[ int private; ]])
test_compile_error([[ int protected; ]])
test_compile_error([[ int public; ]])
test_compile_error([[ int static; ]])
test_compile_error([[ int final; ]])
test_compile_error([[ int do; ]])
test_compile_error([[ int else; ]])
test_compile_error([[ int return; ]])
test_compile_error([[ int constant; ]])
test_compile_error([[ int import; ]])
test_compile_error([[ int inherit; ]])
test_compile_error([[ int catch; ]])
test_compile_error([[ float gauge; ]])
test_compile_error([[ int lambda; ]])
test_compile_error([[ int sscanf; ]])
test_compile_error([[ int switch; ]])
test_compile_error([[ int typeof; ]])
test_compile_error([[ int break; ]])
test_compile_error([[ int case; ]])
test_compile_error([[ int continue; ]])
test_compile_error([[ int default; ]])
test_compile_error([[ int for; ]])
test_compile_error([[ int foreach; ]])
test_compile_error([[ int if; ]])
test_compile_error([[ int float = 0; ]])
test_eval_error([[ return 0.0[0]; ]])
test_eval_error([[ return 0[0]; ]])
test_compile_error([[constant x=class {}(); ]])

test_compile_error_low([[
 mixed foo;
 mapping query_variables() { return ([]); };
 mixed foo(mixed bar) { return 1/foo; }
]])

test_compile_error_low([[
  class A {int wrong = "bogus"; void create() {}}
  class B {inherit A;}
]])


test_compile([[float x=(gauge { return; },1.0);]])
cond( [[ master()->resolv("Gmp")->mpz ]],
[[
  test_compile_error([[object x = Gmp.mpz(17); constant y = x;]])
]])
test_any([[object(Stdio.File) f; f=Stdio.File(); return 1]],1)
test_compile([[float t=gauge { string foo; };]])
test_compile_any([[class { object(Stdio.FILE) f; void create() { f=Stdio.FILE(); }}]])
test_eq([[compile_string("#define A(X) (X)\nint x() { return A \n\t(1); }")()->x()]],1)

test_any([[class G { mapping t=([]);
 class tO { void init(string name) { t[name]=this_object(); }}
 class W { inherit tO; void create() { init("foo"); }}
}; object x=G(); x->W(); return objectp(x->t->foo)]],1)

test_program([[class foo { program x() { return class {}; }}; class bar { inherit foo; program x() { return class {}; }} int a() { return foo()->x != bar()->x(); }]])

test_any([[
  class A {
    constant gurka = 2;
    int foo = gurka;
  };
  class B {
    static inherit A;
    constant gurka = 1;
    int bar;

    void create() { bar = foo; }
  };
  return B()->bar;
]], 1)

test_any([[
  class A {
    constant gurka = 2;
    int foo = gurka;
  };
  class B {
    static inherit A;
    constant gurka = 1;
    int bar;
    int baz = 3;

    void create() { bar = baz + foo; }
  };
  return B()->bar;
]], 4)

test_any([[
  class A {
    constant gurka = 1;
    int foo = gurka;
  };
  class B {
    constant banan = 2;
    int foo = banan;
  };
  class C {
    static inherit A;
    static inherit B;
    constant gurka = 3;
    constant banan = 4;
    int bar;
    int baz = 5;

    void create() { bar = baz + A::foo + B::foo; }
  };
  return C()->bar;
]], 12)

test_any([[
  class A { int a = 1; };
  class B { int b = 2; };
  class C {
    inherit A;
    inherit B;
    int c = 4;
  };
  class D {
    inherit C;
  };
  object d = D();
  return d->a + d->b + d->c;
]], 7)

test_compile_error_low([[
  class AScope
  {
     int gurka;
     class A
     {
  	int func() { return gurka; }
     }
  }
  
  class CScope
  {
     string hohum;
     class C
     {
  	inherit AScope.A;
     }
  }

]])

dnl Come back when we decide that this should be possible
dnl test_do([[
dnl  class A {
dnl    constant i = 5;
dnl  };
dnl  class B {
dnl    inherit A;
dnl    int i = 17;
dnl  };
dnl  B();
dnl ]])


test_any([[
 class A {};
 class B { inherit A; };
 class C { inherit B; };
 class D { inherit C; };
 return Program.inherits(D,A);
]],1)

test_any([[
 class A {};
 class B { inherit A; };
 class C { inherit B; };
 class D { inherit C; };
 return Program.inherits(A,D);
]],0)

test_any([[
 class A {};
 class B { inherit A; };
 class C { inherit B; };
 class D { inherit C; };
 return Program.inherits(A,C);
]],0)

test_any([[
 class A {};
 class B { inherit A; };
 class C { inherit B; };
 class D { inherit C; };
 return Program.inherits(C,A);
]],1)

test_any_equal([[
 class A {};
 class B { inherit A; };
 class C { inherit B; };
 class D { inherit C; };
 return Program.inherit_list(D);
]],[[ ({ C }) ]] )

test_any_equal([[
 class A {};
 class B { inherit A; };
 class C { inherit B; };
 class D { inherit A; inherit B; inherit C; };
 return Program.inherit_list(D);
]],[[ ({ A,B,C }) ]])

test_any_equal([[
 class A {};
 class B { inherit A; };
 class C { inherit B; };
 class D { inherit C; };
 return Program.inherit_tree(D);
]],[[  ({D, ({C, ({B, ({A})})})}) ]])

test_any([[
 class A {};
 class B { inherit A; };
 class C { inherit B; };
 class D { inherit C; };
 return sizeof( Program.all_inherits(D) - ({A,B,C}) );
]],0)

test_program([[

int errors;
int tests;

#define indent(X) (X)

int maxdepth;
int quiet;

void low_generate(int depth,
		  array(string) code,
		  string acc,
		  string ans,
		  int cnt)
{
  mixed tmp;
  if(--depth<0)
  {
    string res="None";
    tests++;

    if(!(tests & 63))
    {	
      __signal_watchdog();
      if(!quiet)
        werror("\r%d: %d  ",maxdepth,tests);
    }

    string test=code*"\n"+"\n"
      "mixed Q() { return "+acc+"();}\n"
      "int main() { trace(9); werror(\"%O\\n\","+acc+"()); }\n"
      ;

    mixed tmp;
    mixed err=catch {
      tmp=compile_string(test)();
      res=tmp->Q();
      if(res != ans)
      throw("Test failed");
    };
    mixed x=Program.inherit_list(object_program(tmp));
    if(err)
    {
      errors++;
      werror("\nTest failed:\n----------------------------------\n%s\n---------------------------------\nexpected answer: %O\nAnswer received: %O\n",test,ans,res);
      if(err!="Test failed")
      {
	string tmp=master()->describe_backtrace(err);
	array s=tmp/"\n";
	s=s[..20];
	werror("%s\n",s*"\n");
      }
      return;
    }
  }else{
    low_generate(depth, 
		 code+
		 ({sprintf("string F%d(){ return %s()+\"F%d\"; }",cnt,acc,cnt)}),
		 sprintf("F%d",cnt),
		 sprintf("%sF%d",ans,cnt),
		 cnt+1);

    for(int e=0;e<sizeof(code);e++)
    {
      low_generate(depth, 
		   code[..e-1]+({
		     sprintf("class C%d {\n%s\n};",cnt,indent(code[e..]*"\n"))
		       }),
		   sprintf("C%d()->%s",cnt,acc),
		   ans,cnt+1);
    }
      

    if(sscanf(acc,"%s()->%s",string classname,string rest))
    {
      low_generate(depth, 
		   code+({sprintf("inherit %s;",classname) }),
		   rest,
		   ans,
		   cnt);
    }
  }
}

int a()
{
  werror("Testing vtables and scope access.\n");

  string testargs=getenv()->TESTARGS;
  if(testargs &&
     (has_value(testargs/" ", "-q") ||
      has_value(testargs/" ", "-quiet") ) )
    quiet=1;

  switch(getenv("TERM"))
  {
    case "dumb":
    case "emacs":
      quiet=1;
  }

  int total_tests;
  for(maxdepth=1;maxdepth<9 && !errors;maxdepth++)
  {
    low_generate(maxdepth,
		 ({ "string X(){return \"X\";}" }),
		 "X",
		 "X",0);
    if(quiet)
      werror("Maxdepth %d\n",maxdepth);
    else
      werror("\r%d: %d\n",maxdepth,tests);
    total_tests+=tests;
    tests=0;
  }
  
  if(errors) werror("%d/%d tests failed.\n",errors,total_tests);
  return !errors;
}

]])




test_true([[Program.implements( class { int x; string y; void foo(int x) {} },
	class { void foo(mixed z) {} int x; })]])
test_false([[Program.implements( class { int x; string y; void foo(int x) {} },
	class { void foo(mixed z) {} string x; })]])

test_eq([[object_program(master())]],[[(program)"/master"]])
test_compile([[object("master") m = master();]])
test_any([[if(int x=1,y=2) return x;]],1)
test_any([[int x; x++; if(x) return x; return -1;]],1)
test_any([[int x; if(x) return x; return -1;]],-1)
test_any([[int x,y; if(x==y || x==1) return 2; return 0;]],2);
test_any([[int x,y; if(x==y && x==0) return 2; return 0;]],2);
test_any([[int x,y=1; if(x==y || x==1) return 2; return 0;]],0);
test_any([[int x,y=1; if(x==y && x==0) return 2; return 0;]],0);

test_eq([[ "\007" & "\023"]],"\003")
test_eq([[ "\007" | "\023"]],"\027")
test_eq([[ "\007" ^ "\023"]],"\024")


test_any([[
return class { int i=17; }()["i"]
]],17)

test_any([[
return class { int i=17; mixed `[](string foo) { return i; }}()[""]
]],17)

test_any([[
return class { int i=17; mixed `[](string foo) { return ::`[]("i"); }}()[""]
]],17)

test_any([[
return class { int i=17; mixed `[](string foo) { return ::`[]; }}()[""]("i")
]],17)

test_any([[
return class { int i=17; mixed `[](string foo) { return ::`[]; }}()[""]("y")
]],0)

test_any([[
object o=class {
  int i=17;
  mixed `[](string foo) { return ::`[]=; }
  mixed `[]=(string ind, mixed foo) {}
}();

o[""]("i",99);
return o->i;
]],99)

test_any([[
object o=class {
  int foo=7;
  int bar=11;
  int i=17;
  int gazonk=12;
  mixed `[](string foo) { return ::`[]=; }
  mixed `[]=(string ind, mixed foo) {}
}();

o[""]("i",99);
return o->i;
]],99)

test_any([[
class Fonk {
  int foo=1;
  int bar=2;
  int i=17;
  int gazonk=3;
};

object o=class
{
  inherit Fonk;
  mixed `[](string foo) { return ::`[]=; }
  mixed `[]=(string ind, mixed foo) {}
}();

o[""]("i",99);
return o->i;
]],99)

test_any([[
class Fonk {
  int foo=1;
  int bar=2;
  int i=17;
  int gazonk=3;
};

object o=class
{
  inherit Fonk : zonk;
  mixed `[](string foo) { return zonk::`[]=; }
  mixed `[]=(string ind, mixed foo) {}
}();

o[""]("i",99);
return o->i;
]],99)

test_any([[
  class A {int foo() {return bar();} int bar();};
  class B {int bar() {return 1;}};
  class C {inherit A; inherit B; int bar() {return B::bar();}};
  return C()->foo();
]], 1)

test_compile_any([[
  class X { void hej() {} }
  class Y { inherit X:banan; void hopp() { banan::hej(); } }
]])


test_compile_any([[
  class X { static void hej() {} }
  class Y { inherit X:banan; void hopp() { ::hej(); } }
]])

test_compile_any([[
  class X { static void hej() {} }
  class Y { inherit X; void hopp() { X::hej(); } }
]])

test_compile_any([[
  class X { static void hej() {} }
  class Y { public inherit X:banan; void hopp() { banan::hej(); } }
]])

test_compile_any([[
  class X { static void hej() {} }
  class Y { inherit X:banan; void hopp() { banan::hej(); } }
]])

// testing virtual overloading
test_any([[
class fnord
{
  int ber() { return 1; }
  int goo() { return ber(); }
};

class blorg
{
  inherit fnord;
  int ber() { return 2; }
};
return blorg()->goo();
]],2)

// testing 'local'
test_any([[
class fnord
{
  local int ber() { return 1; }
  int goo() { return ber(); }
};

class blorg
{
  inherit fnord;
  int ber() { return 2; }
};
return blorg()->goo();
]],1)

// testing 'local::'
test_any([[
class fnord
{
  int ber() { return 1; }
  int goo() { return local::ber(); }
};

class blorg
{
  inherit fnord;
  int ber() { return 2; }
};
return blorg()->goo();
]],1)
test_any([[
class fnord
{
  int ber() { return 1; }
  int goo() { return local::ber()+ber(); }
};

class blorg
{
  inherit fnord;
  int ber() { return 2; }
};
return blorg()->goo();
]],3)
test_any([[
class fnord
{
  int ber() { return 1; }
  int goo() { return ber()+local::ber(); }
};

class blorg
{
  inherit fnord;
  int ber() { return 2; }
};
return blorg()->goo();
]],3)

// Testing the 'inline' keyword
test_program([[class foo { inline int c() { return time(); } int d() { return c(); } }; class bar { inherit foo; int c() { return 0; } } int a() { return bar()->d(); }]],0)

test_compile_any([[
  class top
  {
     class the_class
     {
     }
  }
  
  class inherit_top
  {
     inherit top:top;
  
     constant top_the_class=top::the_class;
  
     class the_other_class
     {
        inherit top_the_class;
     }
  }
]])

// Testing __INIT
test_any([[
  class X { int x = 1; };
  class Y { int y = 2; };
  class Z { inherit X; inherit Y; int z = 4; };
  object zz = Z();
  return zz->x + zz->y + zz->z;
]], 7)

test_do([[
  class X {
    constant foo = Foo;
    class Foo {}
    void bar()
    {
      foo f = Foo();
    }
  };
]])

test_any([[
class X {
 static string f() { return "p"; }
 static class gazonk { void create() { f(); }};
  static class g { object e() { return gazonk(); }};
 void create() { g()->e(); }}; return objectp(X()); ]],1)
test_any([[class A { protected int x=1; }; class B { inherit A; int foo() { return A::x; }}; return A()->x==B()->x && B()->foo()==A()->x;]],1)
test_any([[class C { int q() { return p(); } int p() { return 17; }}; return C()->q();]],17)
test_any([[class C1 {
 class D { string id() { return "foo"; } };
 class Y { program YinD() { return D; }} };
 class C2 { inherit C1; class D { string id() { return "bar"; } } };
 return C2()->Y()->YinD()()->id()]],"bar")
test_any([[object o=class foo{int c;class bar{void create(){c++;};}}(); o->bar(); return o->c;]],1)
test_do([[add_constant("GURKA2",class foo { int c; class bar{void create() {c+=17;}}}()); ]])
test_any([[class x { inherit GURKA2.bar; }(); return GURKA2->c;]],17)
test_any([[class x { inherit GURKA2.bar; }(); return GURKA2->c;]],34)

test_do([[add_constant("GURKA2",class foo { int c; class bar{void create() { class sune { void create() {c+=17;}}(); }}}()); ]])
test_any([[class x { inherit GURKA2.bar; }(); return GURKA2->c;]],17)
test_any([[class x { inherit GURKA2.bar; }(); return GURKA2->c;]],34)
test_do([[add_constant("GURKA2");]]);

test_eq(class { static int foo=17; }()->foo,0)
test_eval_error(class c { static int foo=17; }()->foo=18;)
test_equal( [[ ({ (["foo":"bar"]), (<"foo">), ([]) })->foo ]], [[ ({"bar",1,0}) ]])
test_any([[mixed a=({([]),0}); a[1]=a; return a->foo[0];]],0)
test_eval_error([[return column(({0}),"foo");]])

test_any([[
class A { constant a=0; int foo() { return a; } };
class B { inherit A; constant a=1; };
return B()->foo(); ]], 1)

test_any([[
class p1 { int foo() { return 1; }};
class p2 { int foo() { return 3; }};
class c1 { inherit p1; inherit p2; int foo() { return p1::foo()+p2::foo(); }};
class c2 { inherit c1; }; return c2()->foo();]],4)

test_any([[
class p1 { int foo() { return 1; } };
class p2 { int foo() { return 2; } };
class c1 { inherit p1; inherit p2; };
return c1()->foo();]],2)

test_any([[class foo { int x=random(100); int `<(object o) { return x < o->x; } }; object *o=allocate(100,foo)(); sort(o); for(int e=1;e<100;e++) if(o[e-1]->x > o[e]->x) return e; return -1;]],-1)

test_any([[
  mixed ret=({});
  int a, b = 3;
  for (a = 0; a < b; a++) {
     ret+=({a,b});
    if (a % 2) b += 1;
  }
  return equal(ret,({0,3,1,3,2,4,3,4,4,5}));
]],1)

test_any([[
  mixed ret=({});
  int a, b = 3;
  for (a = 0; a < b; a++) {
     ret+=({a,b});
    if (a % 2) b ++;
  }
  return equal(ret,({0,3,1,3,2,4,3,4,4,5}));
]],1)

test_any([[
  mixed ret=({});
  int a, b = 3;
  for (a = 0; a < b; a++) {
     ret+=({a,b});
    if (a % 2) b=b+1;
  }
  return equal(ret,({0,3,1,3,2,4,3,4,4,5}));
]],1)

test_any([[
  mixed ret=({});
  int a, b = 3;
  for (a = 0; a < b; a++) {
     ret+=({a,b});
    if (a % 2) b-=-1;
  }
  return equal(ret,({0,3,1,3,2,4,3,4,4,5}));
]],1)


test_compile_error([[void foo() { 1++; }]])
dnl test_compile_error([[void foo() { return destruct(this_object()); }]])
test_any([[class foo { constant x=17; }; class bar { inherit foo; constant x=18; }; return bar()->x;]],18)
test_program([[inline string foo(string s){ while(s[0] == ' ' || s[0] == '\t') s = s[1..]; return(s); } string a() { return foo("   bar"); }]])

test_true([[lambda(int x) { return lambda() { return x; };}]])
test_eq([[lambda(int x) { return lambda() { return x; };}(4)()]],4)
test_eq([[lambda(int x) { return lambda() { return x; };}(17)()]],17)
test_eq([[lambda(int x) { return lambda() { return lambda() { return x; };};}(17)()()]],17)

test_eq(120,
        [[ lambda()
           {
             int f(int i) { return i == 0 ? 1 : i*f(i-1); };
             return f(5);
           }(); ]])
  
test_eq([[function f;
	for(int i = 0; i < 2; i++)
	  { {int _i = i; f = lambda(int j) { return _i+j; }; } }
	return f(17);]],
	[[function f;
	for(int i = 0; i < 2; i++)
	  { {int _i = i; f = lambda(int j) { return _i+j; }; } int FEL; }
	return f(17);]]);


test_any([[
   int x=1;
   void for10(function f) { for(int e=0;e<10;e++) f(); };
   for10(lambda() { x++; });
   return x;
]], 11)

test_any([[
   int x=1;
   void for10(function f) { for(int e=0;e<10;e++) f(); };
   for10() { x++; }
   return x;
]], 11)

test_any([[
  int x;
  for(int i=5; i < 10; i++) x++;
  return x;
]], 5)

test_true([[lambda(function f) {return 1;}(object_program(this_object()));]])
test_any([[
  function my_lambda;

  {
    string foo = "foo", bar = "bar";
    my_lambda = lambda() { return foo; };
  }

  int really_magic_var;
  return my_lambda();
]],"foo")

test_eq([[class c { int `()(){ return 4711; } }()(); ]],4711)
teste_eval_error(mixed foo=({}); sort(@foo); )
test_compile_error([[int foo() { return 1} ; constant foo=(["foo":foo]); return foo->foo();]])
test_compile_error([[class T{void p(object e,object f){lambda::create(f);}}]])
test_eval_error(mixed *foo=({}); return mkmapping(foo,({1})); )
test_compile_error([[mapping (string:array(string:string)) foo=([]); ]])
test_compile_error([[int a() { switch(random(2)) { case 3: if(random(2)) { case 0: return 1; } else { case 1: return 2; } } }]])

test_true(encode_value(0))
test_true(encode_value(0)[0]=='\266')
define(test_encode, [[ test_equal($1, decode_value(encode_value($1)))
		       test_equal($1, decode_value(encode_value_canonic($1))) ]])
test_eq(replace("foobar","","X"),"fXoXoXbXaXr")
test_encode(0)
test_encode("")
test_encode(0.0)
test_encode(1.0)
test_encode(-1.0)
test_encode(12.0)
test_encode(100000.0)
test_encode(3.1875)
test_encode(0.0000019073486328125)
test_encode(({}))
test_encode(([]))
test_encode("foobar")
test_encode((<>))
test_encode("\7")
test_encode("\77")
test_encode("\777")
test_encode("\7777")
test_encode("\77777")
test_encode("\777777")
test_encode("\7777777")
test_encode("\77777777")
test_encode(({"en","sv","de"}))
test_encode((<"en","sv","de">))
test_encode((["en":1,"sv":2,"de":3]))
test_encode(({"s",1,0,-3.40625}))
test_encode((<"s",1,0,-3.40625>))
test_encode((["s":1,1:2,0:3,-3.40625:4]))
test_encode((<1, 2, 2, 3, 3, 3>))
test_eq(decode_value("\210\201"),1)
test_eq(decode_value("\210\011\001"),-1)
test_eq(decode_value("\206\200"),""))
test_equal(decode_value("\200\200"),({}))
test_equal(decode_value("\206\206\146\157\157\142\141\162"),"foobar")
test_any([[mixed a=({0}); a[0]=a; return equal(a, decode_value(encode_value(a)));]], 1)
test_any([[ int e; for(e=0;e<100000;e+=1+(e>>4)) if(decode_value(encode_value(e))!=e) return e; return -1;]], -1)
test_any([[ int e; for(e=0;e<100000;e+=1+(e>>4)) if(decode_value(encode_value(-e))!=-e) return e; return -1;]], -1)

test_eval_error([[return decode_value("\266ke0\241\346abc\b&\346de~\200\335\1\362PO\35\242")]])
test_eval_error([[return decode_value("\266ke0\241\346abcpf\221\337v\37\224")]])
test_eval_error([[return decode_value("\266ke0\241\346abc\b&\346def`\266\212\340\337\b\252\b")]])
test_eval_error([[return decode_value("\266ke0\241\346abc\b&\346def`\266\264\22\330\207")]])
test_eval_error([[return decode_value("\266ke0\241\262\266\216\213{@\333|")]])
test_eval_error([[return decode_value("\266ke0\241\346a\211[\266SN\313\331")]])
test_eval_error([[return decode_value("\266ke0\241\346ab-\266""6\227}u\320\274\251\211")]])
test_eval_error([[return decode_value("\266ke0\241\346abc\b&\346de\276\266\364\30\251s\233UF\362")]])
test_eval_error([[return decode_value("\266ke0\241\346abcv\22C\246\264\264L"          )]])
test_eval_error([[return decode_value("\266ke0\241\260\303\rl")]])

test_equal(encode_value_canonic ((["en":1,"sv":2,"de":3])),
           encode_value_canonic ((["en":1,"de":3,"sv":2])))
test_equal(encode_value_canonic ((["en":1,"sv":2,"de":3])),
           encode_value_canonic ((["de":3,"sv":2,"en":1])))
test_equal(encode_value_canonic ((["en":1,"sv":2,"de":3])),
           encode_value_canonic ((["sv":2,"en":1,"de":3])))
test_equal(encode_value_canonic ((<"en","sv","de">)),
           encode_value_canonic ((<"en","de","sv">)))
test_equal(encode_value_canonic ((<"en","sv","de">)),
           encode_value_canonic ((<"de","sv","en">)))
test_equal(encode_value_canonic ((<"en","sv","de">)),
           encode_value_canonic ((<"sv","en","de">)))


test_any([[
class Test
{
    class Resolver (array c)
    {
      mixed resolv (string id)
      {
	if (id == "c") return c;
      }
    }

    class Codec
    {
      mixed fooof (string name) {return all_constants()[name];}
      function objectof = fooof;
      function functionof = fooof;
      function programof = fooof;

      string nameof (mixed what)
      {
	if (string name = search (all_constants(), what)) return name;
	return ([])[0];
      }
    }

    mixed main()
    {
      array c = ({"subres"});
      object o = compile (
	#"string res() {return `+(@c());}
	string subres() {return \"foo\";}",
	Resolver (c))();
      for (int i = 0; i < sizeof (c); i++)
	if (stringp (c[i])) c[i] = o[c[i] ];
#ifdef DEBUG
#define D ,1
#else
#define D
#endif
      function e=encode_value;
      function d=decode_value;
      return d (e (o, Codec() D), Codec() D)->res();
    }
};
  return Test()->main();
]],"foo")

test_any([[
class Test
{
    class Codec
    {
      mixed nameof (mixed what)
      {
	return ([])[0];
      }
    }

    int main()
    {
      object o = compile_string (#"
	constant x = ({0});
	int f() {return 17;}
	int g() {return x[0]();}
      ")();
      o->x[0] = o->f;
      function e=encode_value;
      function d=decode_value;
      o = d (e (o, Codec()), Codec());
      return function_object (o->x[0]) == o;
    }
};
  return Test()->main();
]],1);



test_any([[mixed s="foo"; return s++;]],"foo")
test_any([[mixed s="foo"; s++; return s;]],"foo1")
test_any([[mixed s="foo"; return ++s;]],"foo1")
test_any([[float p=2.0; return p--;]],2.0);
test_any([[float p=2.0; p--; return p;]],1.0)
test_any([[float p=2.0; return --p;]],1.0)

test_compile_error(int foo() { LJjjjjJJJ ; })
test_true(clone(class c { constant i=1; })->i)
test_true(clone(class c { constant i=0; mixed `->(string s) { if(s=="i") return 1; }})->i)
test_true(clone(class c { constant i=1; mixed `->(string s) { return 0; }})["i"])
test_true(clone(class c { constant i=0; mixed `[](string s) { if(s=="i") return 1; }})["i"])
test_true(clone(class c { optional constant i=0; mixed `[](string s) { if(s=="i") return 1; }})["i"])
test_true(clone(class c { mixed `[]=(mixed a, mixed b) { if(a!=b) throw(1); }})[1]=1)
test_true(clone(class c { mixed `->=(mixed a, mixed b) { if(a!=b) throw(1); }})->i="i")

test_eq((["static":42])->static,42)

test_compile_any(class A {}; class B { inherit A; })

test_any_equal(array a = ({({1,0,0}),({1,1,0}),({0,1,1})}); return map(a,`[],1);,
               ({0,1,1}))
test_any_equal(array a = ({({1,0,0}),({1,1,0}),({0,1,1})}); map(a,`[]=,1,0); return a;,
               ({({1,0,0}),({1,0,0}),({0,0,1})}))
test_any_equal(array a = ({(<1>),(<1,2>),(<2,3>),(<1,3>)}); return map(a,`[],1);,
               ({1,1,0,1}))
test_any_equal(array a = ({(<1>),(<1,2>),(<2,3>),(<1,3>)}); map(a,`[]=,1,0); return a;,
               ({(<>),(<2>),(<2,3>),(<3>)}))
test_any_equal(array a = ({(<"a">),(<"b">),(<>)}); map(a,`->=,"a",1); return a;,
               ({(<"a">),(<"a","b">),(<"a">)}))
test_any_equal(array a = ({([1:10]),([1:11,2:12]),([2:13])}); return map(a,`[],1);,
               ({10,11,0}))
test_any_equal(array a = ({([1:10]),([1:11,2:12]),([2:13])}); map(a,`[]=,1,1); return a;,
               ({([1:1]),([1:1,2:12]),([1:1,2:13])}))
test_any_equal(array a = ({(["a":10]),(["b":11]),([])}); map(a,`->=,"a",1); return a;,
               ({(["a":1]),(["a":1,"b":11]),(["a":1])}))
test_any_equal(array a = ({(["i":1]),([])}); return a["i"];,
	       ({1,0}))
test_any_equal(array a = ({(["i":1]),([])}); a["i"] = 7; return a;,
	       ({(["i":7]),(["i":7])}))
test_any([[
  class A {local int i = 10; int ii(){return i;}};
  class B {inherit A;};
  class C {inherit A; int i = 11;};
  array a = ({A(),B(),C()});
  map(a,`[]=,"i",7);
  return equal(a->i,({7,7,7})) && equal(a->ii(),({7,7,10}));
]],1)
test_any([[
  class A {local int i = 10; int ii(){return i;}};
  class B {inherit A;};
  class C {inherit A; int i = 11;};
  array a = ({A(),B(),C()});
  a->i = 7;
  return equal(a->i,({7,7,7})) && equal(a->ii(),({7,7,10}));
]],1)
test_any([[
  class A {local int i = 10; int ii(){return i;}};
  class B {inherit A;};
  class C {inherit A; int i = 11;};
  array a = ({A(),B(),C()});
  map(a,`->=,"i",7);
  return equal(a->i,({7,7,7})) && equal(a->ii(),({7,7,10}));
]],1)
test_any_equal([[
  array a = ({({(["a":"b"]),([]),(["c":17])}),({(["a":"b"]),(["a":7])}),(["b":"d"])});
  a->a = 1;
  return a;
]], ({({(["a":1]),(["a":1]),(["a":1,"c":17])}),
      ({(["a":1]),(["a":1])}),
      (["a":1,"b":"d"])}))
test_any_equal([[
  array a = ({({(["a":"b"]),([]),(["c":17])}),({(["a":"b"]),(["a":7])}),(["b":"d"])});
  map(a,`->=,"a",1);
  return a;
]], ({({(["a":1]),(["a":1]),(["a":1,"c":17])}),
      ({(["a":1]),(["a":1])}),
      (["a":1,"b":"d"])}))

test_any_equal([[
  /* This test tests a wild program pointer in the object o. The bug can trig
     a coredump in a later test. */
  class A {
    array a = ({1});
    void `->= (string var, mixed val) {::`->= (var, val);}
  };
  class B {
    inherit A;
    void `->= (string var, mixed val) {if (var) ::`->= (var, val);}
  };
  object o = B();
  o->a += ({2});
  return o->a;
]], ({1,2}))

test_any_equal([[
  class A {
    array a = ({1});
    void `->= (string var, mixed val) {::`->= (var, val);}
  };
  class B {
    inherit A;
  };
  object o = B();
  o->a += ({2});
  return o->a;
]], ({1,2}))

test_any_equal([[
  class A {
    array a = ({1});
//    void `->= (string var, mixed val) {::`->= (var, val);}
  };
  class B {
    int z;
    inherit A;
    void `->= (string var, mixed val) { A::`->= (var, val);}
  };
  object o = B();
  o->a += ({2});
  return o->a;
]], ({1,2}))

test_any_equal([[
  class FOO
  {
    int q,w,z;
  };
  class A {
    array a = ({1});
  };
  class B {
    inherit FOO;
    int b,c,d,e,f,g;
    inherit A;
    void `->= (string var, mixed val) { A::`->= (var, val);}
  };
  object o = B();
  o->a += ({2});
  return o->a;
]], ({1,2}))


test_any_equal([[
  class A {
    array a = ({1});
  };
  class B {
    int z;
    inherit A : FNORD;

    class Q
    {
	mixed `-> (string var)
	{
	  return FNORD::`-> (var);
	}
      void `->= (string var, mixed val)
	{
	  FNORD::`->= (var, val);
	}
    }
  };
  object o = B();
  object o2=o->Q();
  o2->a += ({2});
  return o->a;
]], ({1,2}))

dnl // Undefined behaviour, don't do this - Hubbe
dnl test_any_equal([[
dnl   class A {
dnl    array a = ({1});
dnl    void `->= (string var, mixed val) {::`->= (var, val); a += ({17});}
dnl  };
dnl  class B {
dnl    inherit A;
dnl  };
dnl  object o = B();
dnl  o->a += ({2});
dnl  return o->a;
dnl ]], ({1,2,17}))

cond(0,[[
dnl This test is not really right, since ::`->= is defined to look up
dnl statically. Still, a variant of ::`->= that does a low-level dynamic
dnl lookup instead would be really useful in cases like this.
test_any_equal([[
  class A {
    int f;
    void `->= (string var, mixed val) {::`->= (var, val); f = 17;}
  };
  class B {
    inherit A;
    array a = ({1});
  };
  object o = B();
  o->a += ({2});
  return o->a + ({o->f});
]], ({1,2,17}))
]])

test_true(mappingp(_memory_usage()))
test_true(_refs(""));
test_true(_refs(({})));
test_true(_refs(([])));
test_true(_refs(this_object()))
test_true(arrayp( _next(({})) || _prev(({}))))
test_do(object o=this_object(); while(o=_next(o)))
test_do(object o=this_object(); while(o=_prev(o)))

test_any([[
  object q=class {}();
  object o=_next(this_object());
  while(zero_type(o)) o=_next(o);  /* skip destructed */
  catch { if(objectp(o) || object_program(o)) return 1;  };
  o=_prev(this_object());
  while(zero_type(o)) o=_prev(o); /* skip destructed */
  catch { if(objectp(o) || object_program(o)) return 1;  };
  return 0;  
]],1)

test_any([[object(Stdio.File) o=Stdio.File(); return objectp(o);]],1)
test_any([[object o=Regexp("foo"); return objectp(o);]],1)
test_any([[object o=Regexp("foo"); return object_program(o);]],Regexp)
test_any([[class Test {}; object(Test) o=Test(); return object_program(o);]],Test)
test_define_program(test,[[constant foo = 1; int a() { return foo; }]])
test_true(new(test)->a())
test_program(inherit test;)
test_program(inherit test; int a() { return foo; } )
test_define_program(test,[[class TEST { int a() { return 1; } }]])
test_program(inherit test; inherit TEST; )


test_any([[
  /* don't save parent */
  class Foo {  };
  return  function_object(object_program(Foo())) ==
	  object_program(this_object());
]], 1)

test_any([[
  class Foo {  };
  return  function_name(object_program(Foo()));
]], "Foo")

test_any([[
  int q;
  return stringp(function_name( lambda() { return q; }));
]],1)

test_any([[
  int q;
  return function_object( lambda() { return q; });
]],[[this_object()]])
  

test_compile_error(class c { object(Stdio.File) foo=class {} ();})
test_compile_error(class c { object(Stdio.File) foo=class {} ();})
test_compile_error(class c { object(Stdio.File) foo=class {} ();})
test_compile_error(class c { object(Stdio.File) foo=class foobar {} ();})
test_do(class c { object foo; object(Regexp) bar=foo; })
test_do(class c { object(Stdio.File) foo; object bar=foo; })
test_any(if(int i=1) return i; return 0;,1)
test_compile(for(int i=0;i<100;i++) return 0;)
test_compile(foreach(({}),mixed i){})
test_compile(sscanf("","",mixed foo))
test_compile_error(sscanf("","",float))
test_compile_error(sscanf("",float))

// ++
test_any([[int e; e++; return e;]],1)
test_any([[int e; ++e; return e;]],1)
test_any([[int e; return e++;]],0)
test_any([[int e; return ++e;]],1)
test_any([[int e; if(e++) return 0; return e;]],1)
test_any([[string e=""; e++; return e;]],"1")

// --
test_any([[int e; e--; return e;]],-1)
test_any([[int e; --e; return e;]],-1)
test_any([[int e; return e--;]],0)
test_any([[int e; return --e;]],-1)
test_any([[int e; if(e--) return 0; return e;]],-1)

test_compile_error_low(master()->add_precompiled_program(\"/test\",compile_string(\"int foo() { return 17; }\",\"62\")))

test_any([[function f=random_seed; int t; foreach(allocate(1),t) f(t); return 1;]],1)
test_compile([[while(0)if(0)continue;else;]])
test_compile([[do { break; } while (0);]])
test_program([[int b=1,c; int a() { c=b+2; return c==3; }]])
test_true([[ ("foobar"/"o") & ({ "foo" }) ]])
test_any([[ array a="foo bar"/" "; return sizeof(a & ({"foo"}))]],1)

// glob
test_false(glob("foo","bar"))
test_true(glob("foo","foo"))
test_true(glob("f?o","foo"))
test_true(glob("f??","foo"))
test_true(glob("?o?","foo"))
test_true(glob("f*","foo"))
test_true(glob("*o","foo"))
test_true(glob("*<<<*","<<<"))
test_true(glob("*<<<*","<<<foo"))
test_false(glob("*f","foo"))
test_false(glob("o*","foo"))
test_false(glob("?f?","foo"))
test_equal([[glob("?f?",({"ff","ffff","off","fff",""}))]],[[({"off","fff"})]])
test_equal([[glob("foo*bar",({"foobar","foobargazonk","","foofoobar","fobar","fooar"}))]],[[({"foobar","foofoobar"})]])

// localtime
cond([[all_constants()->localtime]],
[[
test_true(mappingp(localtime(0)))
]])

cond([[all_constants()->mktime]],
[[
  test_true([[mktime( ([
  "sec":58,
  "isdst":1,
  "year":98,
  "mon":3,
  "mday":26,
  "hour":1,
  "min":51
]))]])

  test_eq([[mktime(58,51,1,26,3,98,1,0)]],[[mktime( ([
  "sec":58,
  "isdst":1,
  "year":98,
  "mon":3,
  "mday":26,
  "hour":1,
  "min":51,
  "timezone":0,
]) ) ]])

]])

cond([[all_constants()->localtime && all_constants()->mktime]],
[[
  test_any([[int x=time(); return mktime(localtime(x)) == x;]], 1)
  test_any([[int x=time(); for(int y=0;y<100;y++) if(mktime(localtime(x+y)) != x+y) return x+y; return 0;]], 0)
]])

cond([[all_constants()->_verify_internals]],
[[
  test_do(_verify_internals())
]])

// sort
test_equal(sort(({1,3,2,4})),({1,2,3,4}))
test_equal(sort(({4,3,2,1})),({1,2,3,4}))
test_equal([[lambda() {array(int) a=({1,2,3,4}); sort(({4,3,2,1}),a); return a; }()]],[[({4,3,2,1})]] )
test_equal([[lambda() {array(int) a=({1,2,3,4}), b=a+({}); sort(({4,3,2,1}),a,b); return b; }()]],[[({4,3,2,1})]] )

cond([[all_constants()->thread_create]],
[[
// thread_create
  test_do(thread_create(lambda() { }))

// /precompiled/mutex
  test_true(Thread.Mutex())
  test_do(add_constant("_tmp_mutex",Thread.Mutex()))
  test_true(_tmp_mutex->lock())
  test_true(_tmp_mutex->lock())
  test_true(_tmp_mutex->trylock())
  test_true(_tmp_mutex->trylock())
  test_do(add_constant("_tmp_mutex_lock",_tmp_mutex->lock()))
  test_true(catch(_tmp_mutex->trylock()))
  test_do(add_constant("_tmp_mutex_lock"))
  test_true(_tmp_mutex->trylock())
  test_do(add_constant("_tmp_mutex"))
  test_any([[ object m = Thread.Mutex(); object k = m->lock(); thread_create(lambda(object k){ sleep(10); catch { destruct(k); }; }, k);if (catch{m->lock(); return 0;}) { return 1; } return 0; ]],1)
  test_any([[ array data=({0,Thread.Mutex(),Thread.Mutex(),0}); data[3]=data[2]->lock(); thread_create(lambda(array data) {object o=data[1]->lock(); destruct(data[3]); sleep(10); data[0]=1; destruct(o);  },data); object l=data[2]->lock(1); object ll=data[1]->lock(); return data[0]; ]],1)
  test_any([[
array data=({1, Thread.Mutex(), Thread.Condition(), 0});
for(int e=0;e<3;e++) { data[3]++; thread_create(lambda(mixed *data) {
  for(int e=0;e<1000;e++) { object o=data[1]->lock(); data[0]*=2;
    for(int d=0;d<5;d++) { data[0]--; data[0]*=2; } data[0]--; destruct(o); }
   data[3]--; data[2]->signal();}, data);}
 while(data[3]) data[2]->wait(); return data[0];]],1)

// /precompiled/condition
  test_true(Thread.Condition())
  test_do(Thread.Condition()->signal())
  test_do(Thread.Condition()->broadcast())

  test_true(objectp(clone(Thread.Fifo)))
  test_true(objectp(clone(Thread.Queue)))

  test_any([[object o=Thread.Queue(); thread_create(lambda(object f) { for(int e=0;e<10000;e++) f->write(random(4711)); f->write(-1); },o); int tmp=0; while(o->read() != -1) tmp++; return tmp;]],10000)
  test_any([[object o=Thread.Fifo(); thread_create(lambda(object f) { for(int e=0;e<10000;e++) f->write(random(4711)); f->write(-1); },o); int tmp=0; while(o->read() != -1) tmp++; return tmp;]],10000)

dnl this will crash pike on out-of-address-space-related errors
dnl  test_any([[ catch { allocate(10000,thread_create)(lambda() { sleep(1); })->wait(); } ]])
]])

cond([[0]],
[[
  test_any([[
  // test if read() hangs when fd is closed by other thread
       object f=Stdio.File();
       object g=f->pipe();
       object t=thread_create(
    	  lambda()
    	  {
    	     g->read(4);
    	  });
       sleep(0.1); // yield
       g->close(); // close same side of pipe as we have in read above
       sleep(0.1); // yield
       if (!t->status()) return 0; // should be done now
	  // if not, there's no way to kill that thread
       return 1;]],1);

]])


  test_true(Getopt.find_option(({"","--foo"}),"p","foo"))
  test_eq(Getopt.find_option(({"","--foo=bar"}),"p","foo",0,0),"bar")
  test_eq(Getopt.find_option(({"","--foo","bar"}),"p","foo",0,0),"bar")
  test_eq(Getopt.find_option(({"","--","--foo=bar"}),"p","foo",0,0),0)

  test_true(Getopt.find_option(({"","-p"}),"p","foo"))
  test_eq(Getopt.find_option(({"","-pbar"}),"p","foo",0,0),"bar")
  test_eq(Getopt.find_option(({"","-p","bar"}),"p","foo",0,0),"bar")
  test_eq(Getopt.find_option(({"","--","--p","bar"}),"p","foo",0,0),0)

  test_equal(Getopt.get_args(({"",0,0,"sune","--","-foo"})),({"","sune","-foo"}))

  test_true(objectp(clone(String.String_buffer)))
  test_do(clone(String.String_buffer)->append("foo"))
  test_do(add_constant("Flurp",clone(String.String_buffer)))
  test_do(Flurp->append("test"))
  test_do(Flurp->append("test"))
  test_eq((string)Flurp,"testtest")
  test_do(add_constant("Flurp"))

  test_eq(String.strmult("foo",4),"foofoofoofoo")

// m_delete
test_any_equal([[ mapping m=([1:1]); m_delete(m,0); return m; ]],[[ ([1:1]) ]])
test_any_equal([[ mapping m=([1:1,0:3]); m_delete(m,0); return m; ]],[[ ([1:1]) ]])
test_any([[mapping a=([1:1]); return m_delete(a,1)]],1)
test_any([[mapping m=([]); m[1]++; return m[1];]],1)
test_any([[mapping m=([1:1]); m[1]++; return m[1];]],2)
test_any([[mapping m=([]); m[1]++; m[1]++; return m[1];]],2)

// multiset tests

test_any([[multiset m=(<>);int e;
  for(e=0;e<1000;e++) m[e]=1;
  for(e=0;e<1000;e++) if(!m[e]) return e;
  return -1;
]],-1)

test_any([[multiset m=(<>);int e;
  for(e=0;e<1000;e++) m[e]++;
  for(e=0;e<1000;e++) if(!m[e]) return e;
  return -1;
]],-1)

test_any([[multiset m=(<>);int e;
  for(e=0;e<1000;e++) m[e]=1;
  for(e=999;e>=0;e--) if(!m[e]) return e;
  return -1;
]],-1)

test_any([[multiset m=(<>);int e;
  for(e=999;e>=0;e--) m[e]=1;
  for(e=0;e<1000;e++) if(!m[e]) return e;
  return -1;
]],-1)

test_any([[multiset m=(<>);int e;
  for(e=999;e>=0;e--) m[e]=1;
  for(e=999;e>=0;e--) if(!m[e]) return e;
  return -1;
]],-1)

test_any([[multiset m=(<>);int e;
  for(e=0;e<1000;e++) m[reverse(e)]=1;
  for(e=0;e<1000;e++) if(!m[reverse(e)]) return e;
  return -1;
]],-1)

test_any([[multiset m=(<>);int e;
  for(e=999;e>=0;e--) m[reverse(e)]=1;
  for(e=0;e<1000;e++) if(!m[reverse(e)]) return e;
  return -1;
]],-1)

test_any([[multiset m=(<>);int e;
  for(e=0;e<1000;e++) m[reverse(e)]=1;
  for(e=0;e<1000;e++) m[reverse(e)]=0;
  return sizeof(m);
]],0)

test_any([[multiset m=(<>);int e;
  for(e=0;e<1000;e++) m[reverse(e)]=1;
  for(e=0;e<1000;e+=2) m[reverse(e)]=0;
  for(e=0;e<1000;e+=2) if(m[reverse(e)]) return e;
  for(e=1;e<1000;e+=2) if(!m[reverse(e)]) return e;
  return -1;
]],-1)


test_any([[multiset m=(<>);int e;
  for(e=0;e<1000;e++) m[reverse(e)]=1;
  for(e=0;e<1000;e++) m[reverse(e)]++;
  for(e=0;e<1000;e++) if(m[reverse(e)]!=1) return e;
  return -1;
]],-1)


test_any([[multiset m=(<>);int e;
  mixed a;
  a=allocate(1000);
  for(e=0;e<1000;e++)
  {
    m[reverse(e)]=1;
    a[e]=reverse(e);
  }
  add_constant("mtest_m",m);
  add_constant("mtest_i",a);
  return 1;
]],1)

test_any([[
  multiset m = set_weak_flag((<>), 1);
  m[1] = 1;
  return sizeof(m);
]], 1)

test_true([[
  multiset m = set_weak_flag((<>), 1);
  m[1] = 1;
  return get_weak_flag(m);
]])

test_eq([[sizeof(mtest_m)]],sizeof(mtest_i))
test_equal(Array.sort_array(indices(mtest_m)),Array.sort_array(mtest_i))
test_equal(mtest_m,copy_value(mtest_m))

test_any([[multiset m=(<>);int e;
  mixed a;
  a=allocate(100);
  for(e=0;e<100;e++)
  {
    m[reverse(e-50)]=1;
    a[e]=reverse(e-50);
    if(sizeof(m)!=e+1) return e;
  }
  add_constant("mtest_m2",m);
  add_constant("mtest_i2",a);
  return -1;
]],-1)

test_eq([[sizeof(mtest_m2)]],sizeof(mtest_i2))
test_any([[int e;multiset q=(<>),p=(<>); for(e=0;e<1000;e++) { p[reverse(e)]=1; q+=(<reverse(e)>); if(!equal(sort(indices(p)),sort(indices(q)))) return 0; } return 1;]],1)

test_equal(sort(indices(mtest_m|mtest_m2)),sort(mtest_i|mtest_i2))
test_equal(sort(indices(mtest_m&mtest_m2)),sort(mtest_i&mtest_i2))
test_equal(sort(indices(mtest_m-mtest_m2)),sort(mtest_i-mtest_i2))
test_equal(sort(indices(mtest_m^mtest_m2)),sort(mtest_i^mtest_i2))
test_equal(sort(indices(mtest_m2|mtest_m)),sort(mtest_i2|mtest_i))
test_equal(sort(indices(mtest_m2&mtest_m)),sort(mtest_i2&mtest_i))
test_equal(sort(indices(mtest_m2-mtest_m)),sort(mtest_i2-mtest_i))
test_equal(sort(indices(mtest_m2^mtest_m)),sort(mtest_i2^mtest_i))

test_do(add_constant("mtest_m"); add_constant("mtest_i"); )
test_do(add_constant("mtest_m2"); add_constant("mtest_i2"); )

define([[MTEST]],[[test_equal([[mkmultiset(indices(allocate($1)))]],[[mkmultiset(reverse(indices(allocate($1))))]])]])

MTEST(0)
MTEST(1)
MTEST(2)
MTEST(3)
MTEST(5)
MTEST(8)
MTEST(13)
MTEST(21)
MTEST(34)
MTEST(55)

define([[MTEST]])

test_equal([[lambda(multiset x){return ({x[17]++,x[17]++,x[17]++});}((<>))]],
		[[({0,1,1})]])

// mapping tests

test_any([[mapping m=([]);int e;
  for(e=0;e<1000;e++) m[e]=e;
  for(e=0;e<1000;e++) if(m[e]!=e) return 0;
  return 1;
]],1)

test_any([[mapping m=([]);int e;
  for(e=0;e<1000;e++) m[e]=e;
  for(e=999;e>=0;e--) if(m[e]!=e) return 0;
  return 1;
]],1)


test_any([[mapping m=([]);int e;
  for(e=999;e>=0;e--) m[e]=e;
  for(e=0;e<1000;e++) if(m[e]!=e) return 0;
  return 1;
]],1)

test_any([[mapping m=([]);int e;
  for(e=999;e>=0;e--) m[e]=e;
  for(e=999;e>=0;e--) if(m[e]!=e) return 0;
  return 1;
]],1)


test_any([[mapping m=([]);int e;
  for(e=0;e<1000;e++) m[reverse(e)]=e;
  for(e=0;e<1000;e++) if(m[reverse(e)]!=e) return 0;
  return 1;
]],1)


test_any([[mapping m=([]);int e;
  for(e=999;e>=0;e--) m[reverse(e)]=e;
  for(e=0;e<1000;e++) if(m[reverse(e)]!=e) return 0;
  return 1;
]],1)


test_any([[mapping m=([]);int e;
  for(e=0;e<1000;e++) m[reverse(e)]=e;
  for(e=0;e<1000;e++) m_delete(m,reverse(e));
  return sizeof(m);
]],0)

test_any([[mapping m=([]);int e;
  for(e=0;e<1000;e++) m[reverse(e)]=e;
  for(e=0;e<1000;e+=2) m_delete(m,reverse(e));
  for(e=0;e<1000;e+=2) if(m[reverse(e)]) return 0;
  for(e=1;e<1000;e+=2) if(m[reverse(e)]!=e) return 0;
  return 1;
]],1)

test_any([[mapping m=([]);int e;
  for(e=0;e<1000;e++) m[reverse(e)]=e;
  for(e=0;e<1000;e++) m[reverse(e)]++;
  for(e=0;e<1000;e++) if(m[reverse(e)]!=e+1) return 0;
  return 1;
]],1)

test_any([[mapping m=([]);int e;
  mixed a,b;
  a=allocate(1000);
  b=allocate(1000);
  for(e=0;e<1000;e++)
  {
    m[reverse(e)]=e;
    a[e]=reverse(e);
    b[e]=e;
  }
  add_constant("mtest_m",m);
  add_constant("mtest_i",a);
  add_constant("mtest_v",b);
  return 1;
]],1)


test_eq([[sizeof(mtest_m)]],sizeof(mtest_i))
test_equal(Array.sort_array(indices(mtest_m)),Array.sort_array(mtest_i))
test_equal(Array.sort_array(values(mtest_m)),Array.sort_array(mtest_v))
test_equal(mtest_m,copy_value(mtest_m))
test_any([[int e; for(e=0;e<1000;e++) if(!equal(mtest_m[mtest_i[e] ],mtest_v[e])) return 0; return 1;]],1)


test_any([[mapping m=([]);int e;
  mixed a,b;
  a=allocate(100);
  b=allocate(100);
  for(e=0;e<100;e++)
  {
    m[reverse(e-50)]=e-50;
    a[e]=reverse(e-50);
    b[e]=reverse(e-50);
  }
  add_constant("mtest_m2",m);
  add_constant("mtest_i2",a);
  add_constant("mtest_v2",b);
  return 1;
]],1)

test_any([[int e;mapping q=([]),p=([]); for(e=0;e<1000;e++) { p[reverse(e)]=e; q+=([reverse(e):e]); if(!equal(sort(indices(p)),sort(indices(q)))) return 0; } return 1;]],1)
test_any([[mapping m=([]); m+=(["foo":"bar"]); m+=(["bar":"foo"]); m+=(["foo":"foo"]); if(sizeof(m)==3) return 1; return m["foo"]=="foo" && m["bar"]=="foo"]],1)

test_equal(sort(indices(mtest_m|mtest_m2)),sort(mtest_i|mtest_i2))
test_equal(sort(indices(mtest_m&mtest_m2)),sort(mtest_i&mtest_i2))
test_equal(sort(indices(mtest_m-mtest_m2)),sort(mtest_i-mtest_i2))
test_equal(sort(indices(mtest_m^mtest_m2)),sort(mtest_i^mtest_i2))
test_equal(sort(indices(mtest_m2|mtest_m)),sort(mtest_i2|mtest_i))
test_equal(sort(indices(mtest_m2&mtest_m)),sort(mtest_i2&mtest_i))
test_equal(sort(indices(mtest_m2-mtest_m)),sort(mtest_i2-mtest_i))
test_equal(sort(indices(mtest_m2^mtest_m)),sort(mtest_i2^mtest_i))

test_do(add_constant("mtest_m"); add_constant("mtest_i"); add_constant("mtest_v");)
test_do(add_constant("mtest_m2"); add_constant("mtest_i2"); add_constant("mtest_v2");)

define([[MTEST]],[[test_equal([[mkmapping(indices(allocate($1)),reverse(indices(allocate($1))))]],[[mkmapping(reverse(indices(allocate($1))),indices(allocate($1)))]])]])

MTEST(0)
MTEST(1)
MTEST(2)
MTEST(3)
MTEST(5)
MTEST(8)
MTEST(13)
MTEST(21)
MTEST(34)
MTEST(55)

define([[MTEST]])

test_equal([[ `+( ([1:2]) )]],[[ ([1:2]) ]])
test_false( `+( ([1:2]) ) == ([1:2]) )
test_equal([[ `+( ([1:2]), ([1:2])  )]],[[ ([1:2]) ]])
test_equal([[ `+( ([1:2]), ([1:2]), ([2:3,4:5])  )]],[[ ([1:2,2:3,4:5]) ]])
test_equal([[ `+( ([1:2]), ([1:2]), ([2:3,4:5]), ([6:7,1:2])  )]],[[ ([1:2,2:3,4:5,6:7]) ]])
test_equal([[ `+( ([1:2]), ([1:2]), ([2:3,4:5]), ([6:7,1:2]),([8:9])  )]],[[ ([1:2,2:3,4:5,6:7,8:9]) ]] )

test_any([[mapping m=([1:2,3:2]); return search(m,2,search(m,2))!=-1;]],1)

test_any([[mapping m=([]); for(int e=0;e<1000;e++) m[e&3]+=({e}); return sizeof(m)==4 && sizeof(m[0])==250;]],1)

test_any([[
  mapping m = set_weak_flag (([1:1]), 1);
  m_delete (m, 1);
  return get_weak_flag (([]));
]], 0);

test_equal([[lambda(mapping x){return ({x[17]++,x[17]++,x[17]++});}(([]))]],
		[[({0,1,2})]])

// destructed indices
test_any([[{
  object o = class{}();
  mapping m = ([o: 1]);
  destruct (o);
  return equal (m, ([])) && equal (m, ([]));
}]], 1)
test_any([[{
  object o = class{}();
  mapping m = ([o: 1]), n = ([class{}(): 1]);
  destruct (o);
  return !equal (m, n) && !equal (m, n);
}]], 1)
test_any([[{
  object o = class{}();
  mapping m = ([o: 1]);
  destruct (o);
  return sizeof (indices (m)) || sizeof (m);
}]], 0)
test_any([[{
  object o = class{}();
  mapping m = ([o: 1]);
  destruct (o);
  return sizeof (values (m)) || sizeof (m);
}]], 0)

// rows
test_equal([[rows(({1,2,3,4,5,6,7,8,9}),({6,7,2}))]],[[({7,8,3})]])
test_equal([[rows(({1,2,3,4,5,6,7,8,9}),({0,4,1}))]],[[({1,5,2})]])
test_equal([[rows(({1,2,3,4,5,6,7,8,9}),({8,3,5}))]],[[({9,4,6})]])

// column
test_equal([[column(({({1,2,3}),({5,6,7}),({8,9,0})}),0)]],[[({1,5,8})]])
test_equal([[column(({({1,2,3}),({5,6,7}),({8,9,0})}),1)]],[[({2,6,9})]])
test_equal([[column(({({1,2,3}),({5,6,7}),({8,9,0})}),2)]],[[({3,7,0})]])


// gc
ifefun(gc,
[[
  test_true(intp(gc()));
  test_any([[ array a=({0}); a[0]=a; gc(); a=0; return gc() > 0; ]],1);
  test_any([[object o=class c {object o;}(); o->o=o; gc(); o=0; return gc() > 0; ]],1);
  test_any([[object o=class c {object o;}(); o->o=o; gc(); o=0; return gc() > 0; ]],1);
  test_any([[mapping m=([]); m[m]=m; gc(); m=0; return gc() > 0; ]],1);
  test_any([[multiset m=(<>); m[m]=1; gc(); m=0; return gc() > 0; ]],1);
  test_any([[{
#if !constant (_debug)
    int _debug (int d) {return 0;};
#endif
    // Must turn off debug in this test or else we'll get extra
    // references to p in the backlog.
    int dlevel = _debug (0);
    program p=compile_string("constant a=({0});");
    object o=p();
    o->a[0]=p;
    gc();
    p=o=0;
    _debug (dlevel);
    return gc() > 0;
  }]], 1);

  test_any([[gc();
      int q=lambda() { mixed foo; foo=lambda() { return foo; }; return 1; }();
      return gc()>0;
  ]],1)

  test_true([[
    object o = class{}();
    mapping m = ([class{}(): o, o: class{}()]);
    set_weak_flag (m, 1);
    gc();
    return !sizeof (m);
  ]])
  test_true([[
    object o = class{}();
    mapping m = ([class{}(): o, o: class{}()]);
    set_weak_flag (m, Pike.WEAK_INDICES);
    gc();
    return sizeof (m);
  ]])
  test_true([[
    object o = class{}();
    mapping m = ([class{}(): o, o: class{}()]);
    set_weak_flag (m, Pike.WEAK_VALUES);
    gc();
    return sizeof (m);
  ]])
  test_true([[
    object o = class{}();
    multiset m = (<o>);
    set_weak_flag (m, 1);
    m[class{}()] = 1;
    m[o] = 0;
    gc();
    return !sizeof (m);
  ]])

  test_do([[
    mixed eat_stack()
    {
      mixed err = 1;
      if (catch (err = eat_stack()) || err != 10)
	return intp (err) && err ? err + 1 : err;
      if (err = catch {
	class Foo
	{
	  object foo;
	  static void create(object o) {foo = o;}
	};
	Foo foo;
	for(int i=0; i < 10000; i++)
	  foo = Foo(foo);
	gc();
      }) return err;
    };
    if (mixed err = eat_stack()) throw (err);
  ]])

  test_any([[
    mapping m=([]);
    m->self=m;

    mapping q=(["foo":"bar","gazonk":1]);
    m->q=q;

    q+=([]);
    m=0;
    gc();
    return sizeof(q);
  ]],2)
]])

ifefun(gc,
[[
  test_eq([[
    int dummy;
    gc();
    function f = lambda() {
      object o = class{}();
      int i;
      return lambda() {return i;};
    }();
    lambda() {dummy++;}(); // Ensure refcount garbing is done.
    int n = gc();
    // n should be 0; o should be refcount garbed above, the frame for f
    // should be intact for use below.
    dummy += f();
    return n;
  ]], 0)

  test_true([[
    class Foo
    {
      object c;
      class A {object b;}
      class B {object a; void destroy() {c = class{}();}}
      mixed test()
      {
	object a = A(), b = B();
	a->b = b;
	b->a = a;
	a = b = 0;
	gc();
	return c;
      }
    }()->test();
  ]])

  test_any([[{
    array a = ({({0})}); a[0][0] = a;
    gc(); a = 0; return gc() > 0;
  }]], 1)

  test_any([[{
    object o = class {}();
    mapping m = ([o: ({17})]);
    gc(); destruct (o); return gc() > 0;
  }]], 1)

  test_any([[{
    class Dead {object o;};
    object o = Dead(); o->o = Dead(); o->o->o = o;
    gc(); o = 0; return gc() > 0;
  }]], 1)
  test_any([[{
    class Live {object o; void destroy() {}};
    object o = Live(); o->o = Live(); o->o->o = o;
    gc(); o = 0; return gc() > 0;
  }]], 1)
  test_any([[{
    class Dead {object o;};
    class Live {object o; void destroy() {}};
    object o = Dead(); o->o = Live(); o->o->o = o;
    gc(); o = 0; return gc() > 0;
  }]], 1)
  test_any([[{
    class Dead {object o;};
    class Live {object o; void destroy() {}};
    object o = Live(); o->o = Dead(); o->o->o = o;
    gc(); o = 0; return gc() > 0;
  }]], 1)


]])

ifefun(gc,
[[

  test_any_equal([[{
    class Live {object o; void destroy() {}};
    array a = set_weak_flag(({Live()}), 1);
    gc(); return a;
  }]], ({0}))
  test_any_equal([[{
    class Live {object o; void destroy() {}};
    multiset l = set_weak_flag((<Live()>), 1);
    gc(); return l;
  }]], (<>))
  test_any_equal([[{
    class Live {object o; void destroy() {}};
    mapping m = set_weak_flag(([0: Live()]), 1);
    gc(); return m;
  }]], ([]))
  test_any_equal([[{
    class Live {object o; void destroy() {}};
    mapping m = set_weak_flag(([Live(): 0]), 1);
    gc(); return m;
  }]], ([]))
  test_any_equal([[{
    array a = set_weak_flag(({4711, 0x54325827a124*0x12348795482485425}), 1);
    gc(); return a;
  }]], ({4711, 0x54325827a124*0x12348795482485425}))

  test_any_equal([[{
    object o = class Live {
      object o;
      array a = ({17});
      void create() {o = this_object();}
      void destroy() {all_constants()->kablutt = a;}
    }();
    o = 0;
    gc();
    return all_constants()->kablutt;
  }]], ({17}));
  test_any([[{
    object o = class Live {
      object o;
      array a = set_weak_flag (({({17})}), 1);
      void create() {o = this_object();}
      void destroy() {
	if (!equal (a, ({({17})})))
	  error ("Contents in weak array zapped: %O.\n", a);
      }
    }();
    o = 0;
    return gc() >= 3;
  }]], 1);
  test_any_equal([[{
    object o = class Live {
      object o;
      array a = set_weak_flag (({({17})}), 1);
      void create() {o = this_object();}
      void destroy() {all_constants()->blatinka = a;}
    }();
    o = 0;
    gc();
    if (!equal (all_constants()->blatinka, ({({17})})))
      error ("Contents in saved weak array zapped: %O.\n",
	     all_constants()->blatinka);
    gc();
    return all_constants()->blatinka;
  }]], ({0}));

]])

ifefun(gc,
[[

  test_any([[{
    class Dead {object o;};
    object o = Dead(); o->o = Dead();
    array a = set_weak_flag(({o}), 1);
    gc(); o = 0; return gc() > 0;
  }]], 1)
  test_any([[{
    class Dead {object o;};
    class Live {object o; void destroy() {}};
    object o = Live(); o->o = Dead();
    array a = set_weak_flag(({o}), 1);
    gc(); o = 0; return gc() > 0;
  }]], 1)
  test_any([[{
    class Dead {object o;};
    class Live {object o; void destroy() {}};
    object o = Dead(); o->o = Live();
    array a = set_weak_flag(({o}), 1);
    gc(); o = 0; return gc() > 0;
  }]], 1)

  test_do([[{
    object o = class {}();
    array a = ({o});
    destruct (o);
    gc();
  }]]);

  test_any([[{
    array a = ({0}), b = ({a, set_weak_flag (({a}), 1)});
    array x = set_weak_flag (({a}), 1);
    a[0] = b;
    a = b = 0;
    gc();
    return !x[0];
  }]], 1);
  test_any([[{
    mapping a = ([]), b = ([a:set_weak_flag (([a:a]), 1)]);
    mapping x = set_weak_flag (([a:2]), 1);
    a[b] = b;
    a = b = 0;
    gc();
    return !sizeof (x);
  }]], 1);
  test_any([[{
    multiset a = (<>), b = (<a, set_weak_flag ((<a>), 1)>);
    multiset x = set_weak_flag ((<a>), 1);
    a[b] = 1;
    a = b = 0;
    gc();
    return !sizeof (x);
  }]], 1);

]])

ifefun(gc,
[[

  test_any([[{
    class Foo {
      Foo f = this_object();
      multiset(Foo) g = set_weak_flag((<this_object()>), 1);
    };
    multiset(Foo) x = set_weak_flag ((<Foo()>), 1);
    gc();
    return !sizeof (x);
  }]], 1);
  test_any([[{
    class Foo {
      Foo f = this_object();
      multiset(Foo) g = set_weak_flag((<this_object()>), 1);
      void destroy() {add_constant("beltbent_oblivion", 1);}
    };
    multiset(Foo) x = set_weak_flag ((<Foo()>), 1);
    gc();
    int res = all_constants()->beltbent_oblivion;
    add_constant("beltbent_oblivion");
    return res;
  }]], 1);

  test_any([[{
    array x = set_weak_flag (({0}), 1);
    x[0] = x;
    multiset b = set_weak_flag ((<x>), 1);
    array a = ({17});
    b[a] = 1;
    x = 0;
    return gc() + gc() >= 1;
  }]], 1);

  test_any([[{
    array a = set_weak_flag (({0, this_object()}), 1);
    a[0] = a;
    a = 0;
    return gc() + gc() >= 1;
  }]], 1);

  test_any([[{
    array y = set_weak_flag (({0}), 1), z = set_weak_flag (({y}), 1);
    y[0] = z;
    y = z = 0;
    return gc() + gc() >= 2;
  }]], 1);

  test_any([[{
    class Live {
      array a;
      object o = this_object();
      void create()
      {
	a = set_weak_flag (({0}), 1);
	array b = set_weak_flag (({a}), 1);
	a[0] = b;
      }
      void destroy()
      {
	if (!arrayp(a) || !arrayp(a[0]) || a[0][0] != a)
	  add_constant ("my_little_error", "GC garbed weak things too early.\n");
      }
    };
    object o = Live();
    o = 0;
    int res = gc() + gc() >= 3;
    if (all_constants()->my_little_error)
      error (all_constants()->my_little_error);
    return res;
  }]], 1);

  test_do([[{
    class Live
    {
      Foo f;
      void destroy()
      {
	if (!f->l || !f->a || !f->a[0] || !f->a[1])
	  add_constant ("my_little_error", "GC garbed live things.\n");
      }
    };
    class Foo
    {
      int i;
      class Bar
      {
	int j = i++;		// Ensure parent pointer.
	array a = ({j});
      }
      Live l;
      void create (Live _l)
      {
	l = _l;
	l->f = this_object();
      }
      array a = allocate (2, Bar)();
    };
    object o = Foo(Live());
    o = 0;
    gc(), gc();
    if (all_constants()->my_little_error)
      error (all_constants()->my_little_error);
  }]]);

  test_do([[{
  object o = compile_string(#"
      class Foo
      {
	int i;
	class Bar
	{
	  int j = i++;		// Ensure parent pointer.
	}
	inherit Bar;
      }")();
    o = 0;
    gc();
  }]]);
]])

ifefun(gc,
[[

  test_do([[{
    mapping a = ([1:({17}),2:3,4:5,6:7,8:9]), b = a + ([]);
    set_weak_flag (b, 1);
    gc();
  }]]);
  test_do([[{
    mapping a = ([1:({17})]), b = a + ([]);
    set_weak_flag (b, 1);
    gc();
  }]]);
  test_any([[{
    mapping a = ([17:({17})]);
    for (int i = 0; i < 10; i++) a[class{}()] = i;
    mapping b = a + ([]);
    set_weak_flag (b, 1);
    foreach (indices (a), mixed o) if (objectp (o)) destruct (o);
    gc();
    return sizeof (a) == 1 && sizeof (b) == 1;
  }]], 1);
  test_any([[{
    mapping a = ([17:({17})]);
    for (int i = 0; i < 10; i++) a[class{}()] = i;
    mapping b = a + ([]);
    set_weak_flag (a, 1);
    foreach (indices (a), mixed o) if (objectp (o)) destruct (o);
    gc();
    return sizeof (a) == 1 && sizeof (b) == 1;
  }]], 1);
  test_any([[{
    mapping a = ([17:({17})]);
    for (int i = 0; i < 10; i++) a[class{}()] = i;
    mapping b = a + ([]);
    set_weak_flag (a, 1);
    set_weak_flag (b, 1);
    foreach (indices (a), mixed o) if (objectp (o)) destruct (o);
    gc();
    return !sizeof (a) && !sizeof (b);
  }]], 1);
  test_any([[{
    mapping a = ([17:({17})]);
    set_weak_flag (a, 1);
    for (int i = 0; i < 10; i++) a[class{}()] = i;
    mapping b = a + ([]);
    foreach (indices (a), mixed o) if (objectp (o)) destruct (o);
    gc();
    return sizeof (a) == 1 && sizeof (b) == 1;
  }]], 1);
  test_any([[{
    mapping a = set_weak_flag (([17: set_weak_flag (({({17})}), 1)]), 1);
    return gc() >= 2 && !sizeof (a);
  }]], 1);

]])

ifefun(gc,
[[

  test_any([[{
    object o = class{}();
    mapping a = set_weak_flag ((["foo": o]), 1);
    gc();
    return sizeof (a);
  }]], 1);
  test_any([[{
    object o = class{}();
    mapping a = set_weak_flag (([o: o]), 1);
    gc();
    return sizeof (a);
  }]], 1);
  test_any([[{
    object o1 = class{}(), o2 = class{}();
    mapping a = set_weak_flag (([o1: o2]), 1);
    gc();
    return sizeof (a);
  }]], 1);
  test_any([[{
    object o = class{}();
    mapping a = set_weak_flag (([o: o]), 1);
    o = 0;
    return gc() >= 1 && !sizeof (a);
  }]], 1);
  test_any([[{
    object o = class{}();
    mapping a = set_weak_flag (([class{}(): o]), 1);
    return gc() >= 1 && !sizeof (a);
  }]], 1);
  test_any([[{
    object o = class{}();
    mapping a = set_weak_flag (([o: class{}()]), 1);
    return gc() >= 1 && !sizeof (a);
  }]], 1);
  test_any([[{
    mapping a = set_weak_flag (([class{}(): class{}()]), 1);
    return gc() >= 2 && !sizeof (a);
  }]], 1);

]])

ifefun(gc,
[[

  test_any([[{
    object o = class{}();
    mapping a = set_weak_flag ((["foo": o]), 1);
    destruct (o);
    gc();
    return !sizeof (a);
  }]], 1);
  test_any([[{
    object o = class{}();
    mapping a = set_weak_flag (([o: o]), 1);
    destruct (o);
    gc();
    return !sizeof (a);
  }]], 1);
  test_any([[{
    object o = class{}();
    mapping a = set_weak_flag (([class{}(): o]), 1);
    destruct (o);
    return gc() >= 1 && !sizeof (a);
  }]], 1);
  test_any([[{
    object o = class{}();
    mapping a = set_weak_flag (([o: class{}()]), 1);
    destruct (o);
    return gc() >= 1 && !sizeof (a);
  }]], 1);
  test_any([[{
    object o = class{}();
    mapping a = set_weak_flag (([o: o]), 0);
    destruct (o);
    gc();
    return !sizeof (a);
  }]], 1);
  test_any([[{
    object o = class{}();
    mapping a = set_weak_flag (([class{}(): o]), 0);
    destruct (o);
    gc();
    return sizeof (a);
  }]], 1);
  test_any([[{
    object o = class{}();
    mapping a = set_weak_flag (([o: class{}()]), 0);
    destruct (o);
    gc();
    return !sizeof (a);
  }]], 1);

  test_any_equal([[{
    array a = set_weak_flag (({1, "foo", 3.14}), 1);
    gc();
    return a;
  }]], ({1, "foo", 3.14}));
  test_any_equal([[{
    multiset a = set_weak_flag ((<1, "foo", 3.14>), 1);
    gc();
    return a;
  }]], (<1, "foo", 3.14>));
  test_any_equal([[{
    mapping a = set_weak_flag (([1: 1, "foo": "foo", 3.14: 3.14]), 1);
    gc();
    return a;
  }]], ([1: 1, "foo": "foo", 3.14: 3.14]));
]])

ifefun(gc,
[[

  test_do([[{
    int got_error = 0;
    array(string) destruct_order;
    add_constant ("destructing", lambda (string id) {destruct_order += ({id});});
    add_constant ("my_error", lambda (string s, mixed... args) {
				if (!got_error) werror ("\n");
				werror (s, @args);
				got_error = 1;
			      });
    program Dead = compile_string (#"
      string id;
      void create (int i) {id = sprintf (\"dead[%d]\", i);}
      mixed a = 1, b = 1; // Mustn't be zero at destruct time.
      mixed x, y, z;
      array v = set_weak_flag (({1}), 1); // Mustn't be zero at destruct time.
      array w = set_weak_flag (({0, 0}), 1);
      function(object:mixed) checkfn;
      void check_live (mapping(object:int) checked) {
	//werror (\"check_live %s\\n\", id);
	checked[this_object()] = 1;
	if (!a) my_error (id + \"->a got destructed too early.\\n\");
	else if (!b) my_error (id + \"->b got destructed too early.\\n\");
	else if (!v[0]) my_error (id + \"->v[0] got destructed too early.\\n\");
	else if (functionp (checkfn) && !checkfn (this_object()))
	  my_error (id + \"->checkfn failed.\\n\");
	else {
	  if (objectp (a) && !checked[a]) a->check_live (checked);
	  if (objectp (b) && !checked[b]) b->check_live (checked);
	  if (objectp (x) && !checked[x]) x->check_live (checked);
	  if (objectp (y) && !checked[y]) y->check_live (checked);
	  if (objectp (z) && !checked[z]) z->check_live (checked);
	  if (objectp (v[0]) && !checked[v[0] ]) v[0]->check_live (checked);
	  if (objectp (w[0]) && !checked[w[0] ]) w[0]->check_live (checked);
	  if (objectp (w[1]) && !checked[w[1] ]) w[1]->check_live (checked);
	}
	//werror (\"check_live %s done\\n\", id);
      }
    ");
    add_constant ("Dead", Dead);
    program Live = compile_string (#"
      inherit Dead;
      void create (int i) {id = sprintf (\"live[%d]\", i);}
      void destroy() {
	destructing (id);
	//werror (\"destroy %s\\n\", id);
	check_live (([]));
      }
    ");
    add_constant ("Live", Live);
    program LiveNested = compile_string (#"
      inherit Live;
      string id = \"live_nested[0]\";
      void create() {}
      void check_live_0 (mapping(object:int) checked) {check_live (checked);}
      class LiveNested1
      {
        inherit Live;
	string id = \"live_nested[1]\";
	void create() {}
	void check_live (mapping(object:int) checked) {
	  checked[this_object()] = 1;
	  if (catch (check_live_0 (checked)))
	    my_error (\"Parent for %s got destructed too early.\\n\", id);
	  else ::check_live (checked);
	}
        void check_live_1 (mapping(object:int) checked) {check_live (checked);}
	class LiveNested2
	{
	  inherit Live;
	  string id = \"live_nested[2]\";
	  void create() {}
	  void check_live (mapping(object:int) checked) {
	    checked[this_object()] = 1;
	    if (catch (check_live_1 (checked)))
	      my_error (\"Parent for %s got destructed too early.\\n\", id);
	    else ::check_live (checked);
	  }
	}
	class LiveNested3
	{
	  inherit Live;
	  string id = \"live_nested[3]\";
	  void create() {}
	  void check_live (mapping(object:int) checked) {
	    checked[this_object()] = 1;
	    if (catch (check_live_1 (checked)))
	      my_error (\"Parent for %s got destructed too early.\\n\", id);
	    else ::check_live (checked);
	  }
	}
      }
    ");
    program DeadNested = compile_string (#"
      inherit Dead;
      string id = \"dead_nested[0]\";
      void create() {}
      void check_live_0 (mapping(object:int) checked) {check_live (checked);}
      class DeadNested1
      {
        inherit Dead;
	string id = \"dead_nested[1]\";
	void create() {}
	void check_live (mapping(object:int) checked) {
	  checked[this_object()] = 1;
	  if (catch (check_live_0 (checked)))
	    my_error (\"Parent for %s got destructed too early.\\n\", id);
	  else ::check_live (checked);
	}
        void check_live_1 (mapping(object:int) checked) {check_live (checked);}
	class DeadNested2
	{
	  inherit Dead;
	  string id = \"dead_nested[2]\";
	  void create() {}
	  void check_live (mapping(object:int) checked) {
	    checked[this_object()] = 1;
	    if (catch (check_live_1 (checked)))
	      my_error (\"Parent for %s got destructed too early.\\n\", id);
	    else ::check_live (checked);
	  }
	}
	class DeadNested3
	{
	  inherit Dead;
	  string id = \"dead_nested[3]\";
	  void create() {}
	  void check_live (mapping(object:int) checked) {
	    checked[this_object()] = 1;
	    if (catch (check_live_1 (checked)))
	      my_error (\"Parent for %s got destructed too early.\\n\", id);
	    else ::check_live (checked);
	  }
	}
      }
    ");
    add_constant ("destructing");
    add_constant ("my_error");
    add_constant ("Dead");
    add_constant ("Live");

    array(object) live, dead, live_nested, dead_nested;
    array(array) destruct_order_tests = ({
      ({3,			// Wanted number of live objects.
	0,			// Wanted number of dead objects.
	0,			// Wanted live nested objects.
	0,			// Wanted dead nested objects.
	lambda() {		// Function to connect them.
	  live[0]->x = live[1], live[0]->a = live[2];
	  live[1]->x = live[0];
	}}),
      ({2, 2, 0, 0, lambda() {	// 1
		      live[0]->x = live[1], live[0]->a = dead[0];
		      live[1]->x = live[0];
		      dead[0]->a = dead[1];
		      dead[1]->a = dead[0];
		    }}),
      ({1, 2, 0, 0, lambda() {	// 2
		      live[0]->a = live[0], live[0]->b = dead[0];
		      dead[0]->a = dead[1];
		      dead[1]->a = dead[0];
		    }}),
      ({0, 3, 0, 0, lambda() {	// 3
		      dead[0]->a = dead[1];
		      dead[1]->a = dead[0];
		      dead[2]->a = dead[0], dead[2]->b = dead[2];
		    }}),
      ({3, 0, 0, 0, lambda() {	// 4
		      live[0]->a = live[0], live[0]->b = live[1];
		      live[1]->a = live[2];
		    }}),
      ({1, 2, 0, 0, lambda() {	// 5
		      live[0]->a = live[0], live[0]->b = dead[0];
		      dead[0]->a = dead[1];
		    }}),
      ({1, 2, 0, 0, lambda() {	// 6
		      live[0]->a = live[0], live[0]->b = dead[1];
		      dead[0]->a = dead[0], dead[0]->b = dead[1];
		      dead[1]->a = dead[1];
		    }}),
      ({2, 2, 0, 0, lambda() {	// 7
		      live[0]->a = live[0], live[0]->b = live[1];
		      dead[0]->a = dead[0];
		      dead[0]->b = live[1];
		      live[1]->a = dead[1];
		      dead[1]->a = dead[1];
		    }}),
      ({1, 3, 0, 0, lambda() {	// 8
		      live[0]->a = live[0], live[0]->b = dead[2];
		      dead[0]->a = dead[0];
		      dead[0]->b = dead[2];
		      dead[2]->a = dead[1];
		      dead[1]->a = dead[1];
		    }}),
      ({3, 1, 0, 0, lambda() {	// 9
		      live[0]->a = live[0], live[0]->b = live[1];
		      dead[0]->a = dead[0], dead[0]->b = live[1];
		      live[1]->a = live[2];
		    }}),
      ({1, 3, 0, 0, lambda() {	// 10
		      live[0]->a = live[0], live[0]->b = dead[1];
		      dead[0]->a = dead[0], dead[0]->b = dead[1];
		      dead[1]->a = dead[2];
		    }}),
      ({1, 3, 0, 0, lambda() {	// 11
		      live[0]->a = live[0], live[0]->b = dead[1];
		      dead[0]->a = dead[0], dead[0]->b = dead[1];
		      dead[1]->a = dead[1], dead[1]->b = dead[2];
		      dead[2]->a = dead[2];
		    }}),
      ({5, 0, 0, 0, lambda() {	// 12
		      live[0]->x = live[1];
		      live[1]->x = live[0], live[1]->a = live[2];
		      live[2]->x = live[3];
		      live[3]->x = live[2], live[3]->a = live[4];
		      live[4]->a = live[4];
		    }}),
      ({3, 0, 0, 0, lambda() {	// 13
		      live[0]->x = live[1], live[0]->y = live[2];
		      live[1]->x = live[2];
		      live[2]->x = live[0];
		    }}),
      ({2, 0, 0, 0, lambda() {	// 14
		      live[0]->a = live[1], live[0]->b = live[0];
		      live[1]->w[0] = live[0];
		    }}),
      ({2, 0, 0, 0, lambda() {	// 15
		      live[0]->a = live[0], live[0]->b = live[1];
		      live[1]->w[0] = live[0];
		    }}),
      ({2, 0, 0, 0, lambda() {	// 16
		      live[0]->a = live[0], live[0]->w[0] = live[1];
		      live[1]->x = live[0];
		    }}),
      ({3, 0, 0, 0, lambda() {	// 17
		      live[0]->a = live[0], live[0]->b = live[1];
		      live[1]->w[0] = live[2];
		      live[2]->a = live[2], live[2]->b = live[1];
		    }}),
      ({3, 0, 0, 0, lambda() {	// 18
		      live[0]->a = live[1], live[0]->x = live[2];
		      live[1]->w[0] = live[2];
		      live[2]->x = live[0];
		    }}),
      ({4, 0, 0, 0, lambda() {	// 19
		      live[0]->x = live[0], live[0]->a = live[1], live[0]->b = live[2];
		      live[1]->a = live[3];
		      live[2]->a = live[3];
		      live[3]->w[0] = live[0];
		    }}),
      ({3, 0, 0, 0, lambda() {	// 20
		      live[0]->x = live[1];
		      live[1]->x = live[0], live[1]->a = live[2];
		      live[2]->w[0] = live[1];
		    }}),
      ({4, 0, 0, 0, lambda() {	// 21
		      live[0]->w[0] = live[1], live[0]->a = live[3];
		      live[1]->w[0] = live[2];
		      live[2]->a = live[0], live[2]->b = live[3], live[2]->x = live[2];
		      live[3]->a = live[1];
		    }}),
      ({2, 1, 0, 0, lambda() {	// 22
		      live[0]->a = dead[0], live[0]->x = live[1];
		      live[1]->x = live[0];
		      dead[0]->w[0] = live[1];
		    }}),
      ({2, 1, 0, 0, lambda() {	// 23
		      live[0]->a = live[1], live[0]->b = dead[0];
		      live[1]->w[0] = dead[0];
		      dead[0]->x = live[0];
		    }}),
      ({3, 0, 0, 0, lambda() {	// 24
		      live[0]->x = live[0], live[0]->a = live[1], live[0]->b = live[2];
		      live[1]->w[0] = live[0], live[1]->w[1] = live[2];
		      live[2]->a = live[1];
		    }}),
      ({3, 0, 0, 0, lambda() {	// 25
		      live[0]->a = live[1];
		      live[1]->w[0] = live[2];
		      live[2]->x = live[2], live[2]->a = live[0], live[2]->b = live[1];
		    }}),
      ({3, 0, 0, 0, lambda() {	// 26
		      live[0]->w[0] = live[1], live[0]->a = live[2];
		      live[1]->x = live[1], live[1]->a = live[0], live[1]->b = live[2];
		      live[2]->w[0] = live[1];
		    }}),
      ({3, 0, 0, 0, lambda() {	// 27
		      live[0]->w[0] = live[1];
		      live[1]->x = live[1], live[1]->a = live[0], live[1]->b = live[2];
		      live[2]->a = live[0];
		    }}),
      ({3, 0, 0, 0, lambda() {	// 28
		      live[0]->a = live[0], live[0]->v[0] = live[1];
		      live[1]->a = live[1], live[1]->v[0] = live[2];
		      live[2]->a = live[2];
		    }}),
      ({2, 2, 0, 0, lambda() {	// 29
		      live[0]->x = live[1], live[0]->v[0] = dead[0];
		      live[1]->x = live[0];
		      dead[0]->a = dead[1];
		      dead[1]->a = dead[0];
		    }}),
      ({4, 0, 0, 0, lambda() {	// 30
		      live[0]->a = live[1], live[0]->b = live[2], live[0]->v[0] = live[3];
		      live[1]->w[0] = live[0];
		      live[2]->a = live[3];
		      live[3]->w[0] = live[2];
		    }}),
      ({2, 1, 0, 0, lambda() {	// 31
		      live[0]->a = dead[0];
		      dead[0]->a = live[0], dead[0]->b = live[1];
		      live[1]->a = live[1];
		    }}),
      ({2, 1, 0, 0, lambda() {	// 32
		      live[0]->a = live[0], live[0]->b = dead[0];
		      live[1]->a = dead[0];
		      dead[0]->a = live[1];
		    }}),
      ({2, 1, 0, 0, lambda() {	// 33
		      dead[0]->a = live[0];
		      live[0]->a = dead[0], live[0]->b = live[1];
		      live[1]->a = live[1];
		    }}),
      ({2, 1, 0, 0, lambda() {	// 34
		      live[0]->a = dead[0];
		      dead[0]->b = live[0], dead[0]->a = live[1];
		      live[1]->a = live[1];
		    }}),
      ({2, 1, 0, 0, lambda() {	// 35
		      live[0]->b = live[0], live[0]->a = dead[0];
		      live[1]->a = dead[0];
		      dead[0]->a = live[1];
		    }}),
      ({2, 1, 0, 0, lambda() {	// 36
		      dead[0]->a = live[0];
		      live[0]->b = dead[0], live[0]->a = live[1];
		      live[1]->a = live[1];
		    }}),
      ({3, 0, 0, 0, lambda() {	// 37
		      live[0]->a = live[0], live[0]->v[0] = live[1];
		      live[0]->checkfn = lambda (object o) {
					   return o->v[0]->w[0];
					 };
		      live[1]->w[0] = live[2];
		      live[2]->a = live[1], live[2]->b = live[2];
		    }}),
      ({4, 0, 0, 0, lambda() {	// 38
		      live[0]->x = live[1];
		      live[1]->x = live[2];
		      live[2]->x = live[0], live[2]->w[0] = live[3];
		      live[3]->a = live[1], live[3]->b = live[3];
		    }}),
      ({0, 2, 2, 0, lambda() {	// 39
		      dead[0]->x = dead[0], dead[0]->a = live_nested[0];
		      dead[1]->x = dead[1], dead[1]->a = live_nested[1];
		      live_nested[0]->x = live_nested[1];
		    }}),
      ({0, 2, 2, 0, lambda() {	// 40
		      dead[0]->x = dead[0], dead[0]->a = live_nested[0];
		      dead[1]->x = dead[1], dead[1]->a = live_nested[1];
		      live_nested[0]->w[0] = live_nested[1];
		    }}),
      ({3, 0, 3, 0, lambda() {	// 41
		      live[0]->x = live[0], live[0]->a = live_nested[0];
		      live[1]->x = live[1], live[1]->a = live_nested[2];
		      live[2]->x = live[2], live[2]->a = live_nested[1];
		      live_nested[0]->x = live_nested[2];
		    }}),
      ({4, 0, 4, 0, lambda() {	// 42
		      live[0]->x = live[0], live[0]->a = live_nested[0];
		      live[1]->x = live[1], live[1]->a = live_nested[1];
		      live[2]->x = live[2], live[2]->a = live_nested[2];
		      live[3]->x = live[3], live[3]->a = live_nested[3];
		      live_nested[0]->x = live_nested[3];
		    }}),
      ({3, 0, 2, 0, lambda() {	// 43
		      live[0]->x = live[0], live[0]->a = live_nested[0];
		      live[1]->x = live[1], live[1]->a = live_nested[1];
		      live_nested[0]->a = live[2];
		      live[2]->x = live_nested[1];
		    }}),
      ({3, 0, 3, 0, lambda() {	// 44
		      live[0]->x = live[0], live[0]->a = live_nested[0];
		      live[1]->x = live[1], live[1]->a = live_nested[2];
		      live[2]->x = live[2], live[2]->a = live_nested[1];
		      live_nested[0]->x = live_nested[2];
		      live_nested[1]->a = live[0];
		    }}),
      ({0, 2, 0, 2, lambda() {	// 45
		      dead[0]->x = dead[0], dead[0]->a = dead_nested[0];
		      dead[1]->x = dead[1], dead[1]->a = dead_nested[1];
		      dead_nested[0]->x = dead_nested[1];
		    }}),
      ({0, 2, 0, 2, lambda() {	// 46
		      dead[0]->x = dead[0], dead[0]->a = dead_nested[0];
		      dead[1]->x = dead[1], dead[1]->a = dead_nested[1];
		      dead_nested[0]->w[0] = dead_nested[1];
		    }}),
      ({3, 0, 0, 3, lambda() {	// 47
		      live[0]->x = live[0], live[0]->a = dead_nested[0];
		      live[1]->x = live[1], live[1]->a = dead_nested[2];
		      live[2]->x = live[2], live[2]->a = dead_nested[1];
		      dead_nested[0]->x = dead_nested[2];
		    }}),
      ({4, 0, 0, 4, lambda() {	// 48
		      live[0]->x = live[0], live[0]->a = dead_nested[0];
		      live[1]->x = live[1], live[1]->a = dead_nested[1];
		      live[2]->x = live[2], live[2]->a = dead_nested[2];
		      live[3]->x = live[3], live[3]->a = dead_nested[3];
		      dead_nested[0]->x = dead_nested[3];
		    }}),
      ({3, 0, 0, 2, lambda() {	// 49
		      live[0]->x = live[0], live[0]->a = dead_nested[0];
		      live[1]->x = live[1], live[1]->a = dead_nested[1];
		      dead_nested[0]->a = live[2];
		      live[2]->x = dead_nested[1];
		    }}),
      ({3, 0, 0, 3, lambda() {	// 50
		      live[0]->x = live[0], live[0]->a = dead_nested[0];
		      live[1]->x = live[1], live[1]->a = dead_nested[2];
		      live[2]->x = live[2], live[2]->a = dead_nested[1];
		      dead_nested[0]->x = dead_nested[2];
		      dead_nested[1]->a = live[0];
		    }}),
      ({0, 4, 2, 2, lambda() {	// 51
		      dead[0]->x = dead[0], dead[0]->a = live_nested[0];
		      dead[1]->x = dead[1], dead[1]->a = live_nested[1];
		      dead[2]->x = dead[2], dead[2]->a = dead_nested[0];
		      dead[3]->x = dead[3], dead[3]->a = dead_nested[1];
		      live_nested[0]->x = dead_nested[1];
		      dead_nested[0]->x = live_nested[1];
		    }}),
      ({4, 0, 0, 0, lambda() {	// 52
		      live[0]->w[0] = live[1];
		      live[1]->x = live[1], live[1]->a = live[0], live[1]->b = live[2];
		      live[2]->w[0] = live[3];
		      live[3]->x = live[3], live[3]->a = live[0];
		    }}),
      ({4, 0, 0, 0, lambda() {	// 53
		      live[0]->w[0] = live[1];
		      live[1]->x = live[1], live[1]->b = live[0], live[1]->a = live[2];
		      live[2]->w[0] = live[3];
		      live[3]->x = live[3], live[3]->a = live[0];
		    }}),
      ({4, 0, 0, 0, lambda() {	// 54
		      live[0]->x = live[0], live[0]->w[0] = live[1];
		      live[1]->w[0] = live[2];
		      live[2]->x = live[2], live[2]->a = live[1], live[2]->b = live[3];
		      live[3]->x = live[3], live[3]->a = live[0];
		    }}),
      ({4, 0, 0, 0, lambda() {	// 55
		      live[0]->x = live[0], live[0]->w[0] = live[1];
		      live[1]->w[0] = live[2];
		      live[2]->x = live[2], live[2]->b = live[1], live[2]->a = live[3];
		      live[3]->x = live[3], live[3]->a = live[0];
		    }}),
      ({3, 0, 0, 0, lambda() {	// 56
		      live[0]->a = live[2];
		      live[1]->x = live[1], live[1]->a = live[0], live[1]->b = live[2];
		    }}),
      ({3, 0, 0, 0, lambda() {	// 57
		      live[0]->a = live[2];
		      live[1]->x = live[1], live[1]->b = live[0], live[1]->a = live[2];
		    }}),
      ({2, 1, 0, 0, lambda() {	// 58
		      live[0]->x = live[1], live[0]->y = dead[0];
		      live[0]->checkfn = lambda (object o) {
					   return o->y;
					 };
		      live[1]->x = live[0];
		      dead[0]->x = dead[0];
		    }}),
      ({2, 1, 0, 0, lambda() {	// 59
		      live[0]->y = live[1], live[0]->x = dead[0];
		      live[0]->checkfn = lambda (object o) {
					   return o->x;
					 };
		      live[1]->x = live[0];
		      dead[0]->x = dead[0];
		    }}),
      ({1, 2, 0, 2, lambda() {	// 60
		      live[0]->x = dead_nested[0], live[0]->y = dead_nested[0];
		      dead[0]->x = dead[0], dead[0]->y = dead_nested[0];
		      dead[1]->x = dead[1], dead[1]->y = dead_nested[1];
		      dead_nested[0]->x = live[0], dead_nested[0]->y = dead_nested[1];
		    }}),
      ({1, 2, 0, 2, lambda() {	// 61
		      live[0]->x = dead_nested[0], live[0]->y = dead_nested[0];
		      dead[0]->x = dead[0], dead[0]->y = dead_nested[0];
		      dead[1]->x = dead[1], dead[1]->y = dead_nested[1];
		      dead_nested[0]->y = live[0], dead_nested[0]->x = dead_nested[1];
		    }}),
      ({3, 0, 0, 0, lambda() {	// 62
		      live[0]->x = live[1];
		      live[1]->x = live[0], live[1]->y = live[2];
		      live[2]->x = live[1];
		    }}),
      ({3, 0, 0, 0, lambda() {	// 63
		      live[0]->x = live[1];
		      live[1]->y = live[0], live[1]->x = live[2];
		      live[2]->x = live[1];
		    }}),
      ({2, 0, 2, 0, lambda() {	// 64
		      live[0]->x = live[1], live[0]->y = live_nested[1];
		      live[1]->w[0] = live_nested[0];
		      live_nested[0]->y = live[0];
		    }}),
      ({2, 0, 2, 0, lambda() {	// 65
		      live[0]->y = live[1], live[0]->x = live_nested[1];
		      live[1]->w[0] = live_nested[0];
		      live_nested[0]->y = live[0];
		    }}),
      ({1, 1, 3, 0, lambda() {	// 66
		      dead[0]->x = dead[0], dead[0]->a = live_nested[0];
		      live_nested[0]->x = live[0], live_nested[0]->y = live_nested[2];
		      live[0]->x = live_nested[1];
		    }}),
      ({1, 1, 3, 0, lambda() {	// 67
		      dead[0]->x = dead[0], dead[0]->a = live_nested[0];
		      live_nested[0]->y = live[0], live_nested[0]->x = live_nested[2];
		      live[0]->x = live_nested[1];
		    }}),
      ({0, 1, 2, 2, lambda() {	// 68
		      dead[0]->x = dead[0], dead[0]->a = live_nested[0];
		      live_nested[0]->y = live_nested[1], live_nested[0]->x = dead_nested[0];
		      live_nested[1]->x = dead_nested[1];
		      dead_nested[0]->x = live_nested[1];
		    }}),
      ({0, 1, 2, 2, lambda() {	// 69
		      dead[0]->x = dead[0], dead[0]->a = live_nested[0];
		      live_nested[0]->x = live_nested[1], live_nested[0]->y = dead_nested[0];
		      live_nested[1]->x = dead_nested[1];
		      dead_nested[0]->x = live_nested[1];
		    }}),
      ({0, 1, 2, 2, lambda() {	// 70
		      dead[0]->x = dead[0], dead[0]->a = live_nested[0];
		      live_nested[0]->x = live_nested[1], live_nested[0]->y = dead_nested[1];
		      live_nested[1]->x = dead_nested[0];
		      dead_nested[0]->x = live_nested[0];
		    }}),
      ({0, 1, 2, 2, lambda() {	// 71
		      dead[0]->x = dead[0], dead[0]->a = live_nested[0];
		      live_nested[0]->y = live_nested[1], live_nested[0]->x = dead_nested[1];
		      live_nested[1]->x = dead_nested[0];
		      dead_nested[0]->x = live_nested[0];
		    }}),
      ({2, 0, 2, 0, lambda() {	// 72
		      live[0]->x = live[1];
		      live[1]->x = live_nested[1];
		      live_nested[1]->x = live[0];
		      live_nested[0]->x = live[1];
		    }}),
      ({2, 0, 4, 0, lambda() {	// 73
		      live[0]->x = live[1], live[0]->y = live_nested[2], live[0]->z = live_nested[3];
		      live[1]->x = live[0];
		      live_nested[1]->x = live[0];
		    }}),
      ({2, 0, 4, 0, lambda() {	// 74
		      live[0]->y = live[1], live[0]->z = live_nested[2], live[0]->x = live_nested[3];
		      live[1]->x = live[0];
		      live_nested[1]->x = live[0];
		    }}),
      ({2, 0, 4, 0, lambda() {	// 75
		      live[0]->z = live[1], live[0]->x = live_nested[2], live[0]->y = live_nested[3];
		      live[1]->x = live[0];
		      live_nested[1]->x = live[0];
		    }}),
      ({2, 1, 2, 0, lambda() {	// 76
		      dead[0]->x = dead[0], dead[0]->a = live_nested[0];
		      live_nested[0]->y = live_nested[1], live_nested[0]->x = live[1];
		      live_nested[1]->x = live[0];
		      live[0]->x = live_nested[0];
		      live[1]->x = live[0];
		    }}),
      //       ({3, 0, 0, 0, lambda() { // Not possible without weak refs directly in objects.
      // 		   live[0]->x = live[0], live[0]->v[0] = live[1];
      // 		   live[1]->x = live[1], live[1]->w[0] = live[2];
      // 		   live[2]->x = live[2], live[2]->a = live[0];
      // 		 }}),
    });

    int quiet;
    string testargs=getenv()->TESTARGS;
    if(testargs &&
       (has_value(testargs/" ", "-q") ||
        has_value(testargs/" ", "-quiet") ) )
      quiet=1;

    switch(getenv("TERM"))
    {
      case "dumb":
      case "emacs":
        quiet=1;
    }

    int test_failed = 0;
    for (int test = 0; test < sizeof (destruct_order_tests); test++) {
      [int nlive, int ndead, int nlnested, int ndnested, function(void:void) setup] =
	destruct_order_tests[test];
      int objs = nlive + ndead;
      array(int) idx = indices (allocate (objs));
      int n = 1;
      for (int f = nlive + ndead; f > 1; f--) n *= f;
      if(!quiet)
        werror ("GC destruct order test %d, %d permutations      \r", test, n);
      while (n--) {
	array(int) alloc_order = Array.permute (idx, n);
	array(int) create_order = ({});
	live = allocate (nlive);
	dead = allocate (ndead);
	if (nlnested >= 1) {
	  // Creating these before the Dead and Live objects below assumes
	  // that the gc will start with the last created object first, so
	  // the order can be controlled with those objects.
	  live_nested = ({LiveNested()});
	  if (nlnested >= 2) live_nested += ({live_nested[0]->LiveNested1()});
	  if (nlnested >= 3) live_nested += ({live_nested[1]->LiveNested2()});
	  if (nlnested >= 4) live_nested += ({live_nested[1]->LiveNested3()});
	}
	if (ndnested >= 1) {
	  dead_nested = ({DeadNested()});
	  if (ndnested >= 2) dead_nested += ({dead_nested[0]->DeadNested1()});
	  if (ndnested >= 3) dead_nested += ({dead_nested[1]->DeadNested2()});
	  if (ndnested >= 4) dead_nested += ({dead_nested[1]->DeadNested3()});
	}
	for (int i = 0; i < objs; i++) {
	  int p = alloc_order[i];
	  if (p < nlive) live[p] = Live (p), create_order += ({p});
	  else p -= nlive, dead[p] = Dead (p), create_order += ({-p - 1});
	}
	destruct_order = ({""}); // Using ({}) would alloc a new array in destructing().
	setup();
	live = dead = live_nested = dead_nested = 0;
	int garbed = gc() + gc(); // Second gc to garb live object leftovers.
	destruct_order = destruct_order[1..];
	if (!got_error && (got_error = sizeof (destruct_order) != nlive + nlnested))
	  werror ("\nGC should garb %d live objects, "
		  "but took %d.\n", nlive + nlnested, sizeof (destruct_order));
	if (!got_error && (got_error = garbed < 3 * (objs + nlnested + ndnested)))
	  werror ("\nGC should garb at least %d things, "
		  "but took only %d.\n", 3 * (objs + nlnested + ndnested), garbed);
	if (got_error) {
	  werror ("Create order was: " +
		  map (create_order, lambda (int i) {
				       if (i < 0) return "dead[" + (-i - 1) + "]";
				       else return "live[" + i + "]";
				     }) * ", " + "\n"
		  "Destruct order was: " + destruct_order * ", " + "\n");
	  test_failed = 1;
	  got_error = 0;
	  break;
	}
      }
    }
    if (test_failed) error ("GC destruct order test failed.\n");
    werror ("%60s\r", "");
  }]])

]])

ifefun(gc,
[[

  test_any([[mapping q=([ "t":class {} ()]); gc(); if(!objectp(q->t)) return -1; set_weak_flag(q,1); gc(); if(objectp(q->t)) return -2; return 0;]],0);

  test_do([[class bar { object foo; void create(void|object tmp) { foo=tmp; } };
             object o=bar(),o2=o;
             for(int e=0;e<10000;e++) o=bar(o);
             o2->foo=o;
             o=o2=0;
             gc();
          ]])

  test_any([[
    object o = class{}();
    mapping m = set_weak_flag (([o: "x"]), Pike.WEAK_INDICES);
    gc();
    return sizeof (m);
  ]], 1)
  test_any([[
    object o = class{}();
    mapping m = set_weak_flag (([o: "x"]), Pike.WEAK_VALUES);
    gc();
    return sizeof (m);
  ]], 1)
  test_any([[
    object o = class{}();
    mapping m = set_weak_flag ((["x": o]), Pike.WEAK_INDICES);
    gc();
    return sizeof (m);
  ]], 1)
  test_any([[
    object o = class{}();
    mapping m = set_weak_flag ((["x": o]), Pike.WEAK_VALUES);
    gc();
    return sizeof (m);
  ]], 1)
  test_any([[
    mapping m = set_weak_flag (([class{}(): "x"]), Pike.WEAK_INDICES);
    gc();
    return sizeof (m);
  ]], 0)
  test_any([[
    mapping m = set_weak_flag (([class{}(): "x"]), Pike.WEAK_VALUES);
    gc();
    return sizeof (m);
  ]], 1)
  test_any([[
    mapping m = set_weak_flag ((["x": class{}()]), Pike.WEAK_INDICES);
    gc();
    return sizeof (m);
  ]], 1)
  test_any([[
    mapping m = set_weak_flag ((["x": class{}()]), Pike.WEAK_VALUES);
    gc();
    return sizeof (m);
  ]], 0)
  test_any([[
    object o = class{}();
    mapping m = set_weak_flag (([o: o]), Pike.WEAK_INDICES);
    o = 0;
    gc();
    return sizeof (m);
  ]], 1)
  test_any([[
    object o = class{}();
    mapping m = set_weak_flag (([o: o]), Pike.WEAK_VALUES);
    o = 0;
    gc();
    return sizeof (m);
  ]], 1)
  test_any([[
    object o = class{}();
    mapping m = set_weak_flag (([o: o]), Pike.WEAK);
    o = 0;
    gc();
    return sizeof (m);
  ]], 0)
  test_any([[
    object o = class{}();
    mapping m = set_weak_flag (([o: "x"]), Pike.WEAK_INDICES);
    destruct (o);
    gc();
    return sizeof (m);
  ]], 0)
  test_any([[
    object o = class{}();
    mapping m = set_weak_flag (([o: "x"]), Pike.WEAK_VALUES);
    destruct (o);
    gc();
    return sizeof (m);
  ]], 0)
  test_any([[
    object o = class{}();
    mapping m = ([o: "x"]);
    destruct (o);
    gc();
    return sizeof (m);
  ]], 0)
  test_any([[
    object o = class{}();
    mapping m = set_weak_flag ((["x": o]), Pike.WEAK_INDICES);
    destruct (o);
    gc();
    return sizeof (m);
  ]], 1)
  test_any([[
    object o = class{}();
    mapping m = set_weak_flag ((["x": o]), Pike.WEAK_VALUES);
    destruct (o);
    gc();
    return sizeof (m);
  ]], 0)
  test_any([[
    object o = class{}();
    mapping m = (["x": o]);
    destruct (o);
    gc();
    return sizeof (m);
  ]], 1)

  test_do([[
    mapping m = set_weak_flag (([]), Pike.WEAK_INDICES);
    object o = class {object o;}();
    m[o] = ({1});
    o->o = o;
    o = 0;
    gc();
  ]])

  test_do([[
    mapping m = set_weak_flag (([]), Pike.WEAK_INDICES);
    object o = class {object o;}();
    m[o] = ({1});
    array a = set_weak_flag (({class (object o) {} (o)}), 1);
    o = 0;
    gc();
  ]])

  test_any([[
    return class {
      mapping x;
      int test()
      {
	object o = class {
	    mapping a = ([1: this_object()]);
	    void destroy() {x = a;}
	  }();
	o = 0;
	gc();
	return x && !x[1];
      }
    }()->test();
  ]], 1)
  test_any([[
    return class {
      multiset x;
      int test()
      {
	object o = class {
	    multiset a = (<this_object()>);
	    void destroy() {x = a;}
	  }();
	o = 0;
	gc();
	return x && !sizeof (x + (<>));
      }
    }()->test();
  ]], 1)
  test_any([[
    return class {
      array x;
      int test()
      {
	object o = class {
	    array a = ({this_object()});
	    void destroy() {x = a;}
	  }();
	o = 0;
	gc();
	return x && !x[0];
      }
    }()->test();
  ]], 1)
  test_any([[
    return class {
      class Obj (object o) {void destroy() {}}
      Obj x;
      int test()
      {
	object o = class {
	    Obj a = Obj (this_object());
	    void destroy() {x = a;}
	  }();
	o = 0;
	gc();
	return !x;
      }
    }()->test();
  ]], 1)
  test_any([[
    return class {
      class Obj (object o) {}
      Obj x;
      int test()
      {
	object o = class {
	    Obj a = Obj (this_object());
	    void destroy() {x = a;}
	  }();
	o = 0;
	gc();
	return x && !x->o;
      }
    }()->test();
  ]], 1)
]])

cond([[ sizeof( cpp("__AUTO_BIGNUM__")/"__AUTO_BIGNUM__" ) == 1 ]],
[[
  // Test the lexer.
  test_eq("2147483648", [[ (string)0x80000000 ]])
  test_eq("2147483649", [[ (string)0x80000001 ]])
  test_eq("-2147483648", [[ (string)-0x80000000 ]])
  test_eq("-2147483649", [[ (string)-0x80000001 ]])
  test_eq("2147483648", [[ (string)-(-0x80000000) ]])
  test_eq("2147483649", [[ (string)-(-0x80000001) ]])
  test_eq("123456789123456789", [[ (string)123456789123456789 ]])
  test_eq("-123456789123456789", [[ (string)-123456789123456789 ]])
  test_eq("335812727629498640265", [[ (string)0x123456789123456789 ]])
  test_eq("-335812727629498640265", [[ (string)-0x123456789123456789 ]])
  test_eq("718046312823", [[ (string)012345671234567 ]])
  test_eq("-718046312823", [[ (string)-012345671234567 ]])
  test_eq("1125899906842624", [[ (string)0b100000000000000000000000000000000000000000000000000 ]])
  test_eq("-1125899906842624", [[ (string)-0b100000000000000000000000000000000000000000000000000 ]])
    
  // These numbers should be ordinary integers.
  test_false([[ objectp(-0x80000000) ]])
  test_false([[ objectp(-0x7fffffff) ]])
  test_false([[ objectp( 0x7fffffff) ]])
    
  // Test incrementations (FIXME: More cases?).
  test_eq("2147483648",
   [[ (string)(class { int f(int x) { x++; return x; } })()->f(0x7fffffff) ]])
  test_eq("2147483648",
   [[ (string)(class { int f(int x) { ++x; return x; } })()->f(0x7fffffff) ]])
  test_eq("2147483648",
   [[ (string)(class { int x=0x7fffffff;int f() { ++x;return x; } })()->f() ]])
  test_eq("2147483648",
   [[ (string)(class { int x=0x7fffffff;int f() { x++;return x; } })()->f() ]])
  test_eq("2147483648",
   [[ (string)(class { int f() { int x=0x7fffffff;++x;return x; } })()->f() ]])
  test_eq("2147483648",
   [[ (string)(class { int f() { int x=0x7fffffff;x++;return x; } })()->f() ]])
  
  // Test decrementations (FIXME: More cases?).
  test_eq("-2147483649",
   [[ (string)(class { int f(int x) { x--; return x; } })()->f(-0x80000000) ]])
  test_eq("-2147483649",
   [[ (string)(class { int f(int x) { --x; return x; } })()->f(-0x80000000) ]])
  test_eq("-2147483649",
   [[ (string)(class { int x=-0x80000000;int f() { --x;return x; } })()->f()]])
  test_eq("-2147483649",
   [[ (string)(class { int x=-0x80000000;int f() { x--;return x; } })()->f()]])
  test_eq("-2147483649",
   [[ (string)(class { int f() { int x=-0x80000000;--x;return x; } })()->f()]])
  test_eq("-2147483649",
   [[ (string)(class { int f() { int x=-0x80000000;x--;return x; } })()->f()]])

  test_encode(1<<99);
]])

cond([[ sizeof( cpp("__AUTO_BIGNUM__")/"__AUTO_BIGNUM__" ) == 1 ]],
[[
  // - Left shift.
  test_eq("1073741824", [[ (string)(1<<30) ]])
  test_eq("2147483648", [[ (string)(1<<31) ]])
  test_eq("4294967296", [[ (string)(1<<32) ]])
  test_eq("8589934592", [[ (string)(1<<33) ]])
  test_eq("1267650600228229401496703205376", [[ (string)(1<<100) ]])
  
  // - Right shift.
  test_eq("53265209898187398182",
		[[ (string)((int)"54543574935743895738479">>10) ]])
  test_false([[ objectp((int)"54543574935743895738479">>60) ]])
  test_eq(0, [[ 25>>30 ]])
  test_eq(0, [[ 25>>31 ]])
  test_eq(0, [[ 25>>32 ]])
  test_eq(0, [[ 25>>33 ]])

  // - abs.
  test_eq("2147483648", [[ (string)abs(-0x80000000) ]])
  test_eq("2147483648", [[ (string)abs(0x80000000) ]])
  test_eq("2147483649", [[ (string)abs(0x80000001) ]])
  test_eq("2147483649", [[ (string)abs(-0x80000001) ]])

  // - Add.
  test_eq("2147483648", [[ (string)(0x7fffffff + 1) ]])
  test_eq("2147483649", [[ (string)(0x7fffffff + 2) ]])
  test_eq("2684354560", [[ (string)(0x50000000 + 0x50000000) ]])
  test_eq("-2684354560", [[ (string)((-0x50000000) + (-0x50000000)) ]])
  test_eq("-2147483648", [[ (string)((-0x80000001) + 1) ]])
  test_false([[ objectp((-0x80000001) + 1) ]])

  // - Add-eq.
  test_eq([[lambda() { int a=0x100000000; int b = a; a += 1; return b+a; }()]],
	  [[0x200000001]])

  // - Sub.
  test_eq("-2147483648", [[ (string)(-0x7fffffff - 1) ]])
  test_eq("-2147483649", [[ (string)(-0x80000000 - 1) ]])
  test_eq("2147483647", [[ (string)(0x80000000 - 1) ]])
  test_false([[ objectp(0x80000000 - 1) ]])

  // - Multiplication.
  test_eq("6442450941", [[ (string)(0x7fffffff * 3) ]])
  test_eq("-6442450941", [[ (string)(0x7fffffff * -3) ]])
  test_eq(-2147483648*-1,2147483648)

  // Division.
  test_eq("1073741824", [[ (string)((int)"2147483648" / 2) ]])
  test_false([[ objectp((int)"2147483648" / 2) ]])
  test_eq("13934998268672547360069539025",
          [[ (string)(48324683476346278246238462784624627348 / 3467864333) ]])

]])

cond([[ sizeof( cpp("__AUTO_BIGNUM__")/"__AUTO_BIGNUM__" ) == 1 ]],
[[

  // - sscanf.
  test_eq("12345678901234567890",
	   [[ (string)array_sscanf("12345678901234567890", "%d")[0] ]])
  test_eq("1375488932614371410344080",
	   [[ (string)array_sscanf("123456789F01234567890", "%x")[0] ]])
  test_eq("1375488932614371410344080",
	   [[ (string)array_sscanf("0x123456789F01234567890", "%x")[0] ]])
  test_eq("1375488932614371410344080",
	   [[ (string)array_sscanf("0X123456789F01234567890", "%x")[0] ]])
  test_eq("1375488932614371410344080",
	   [[ (string)array_sscanf("0x123456789F01234567890", "%i")[0] ]])
  test_eq("1375488932614371410344080",
	   [[ (string)array_sscanf("0X123456789F01234567890", "%i")[0] ]])
  test_eq("45954944846776",
	   [[ (string)array_sscanf("1234567012345670", "%o")[0] ]])
  test_eq("45954944846776",
	   [[ (string)array_sscanf("01234567012345670", "%i")[0] ]])
  test_eq("11", [[ (string)array_sscanf("1011", "%b")[0] ]])
  test_eq("1125968643114208", [[ (string)array_sscanf("100000000000001000000000001000000000100010011100000", "%b")[0] ]])
  test_eq("11", [[ (string)array_sscanf("0b1011", "%i")[0] ]])
  test_eq("1125968643114208", [[ (string)array_sscanf("0b100000000000001000000000001000000000100010011100000", "%i")[0] ]])
  
  test_eq("-12345678901234567890",
	   [[ (string)array_sscanf("-12345678901234567890", "%d")[0] ]])
  test_eq("-1375488932614371410344080",
	   [[ (string)array_sscanf("-123456789F01234567890", "%x")[0] ]])
  test_eq("-1375488932614371410344080",
	   [[ (string)array_sscanf("-0x123456789F01234567890","%i")[0] ]])
  test_eq("-45954944846776",
	   [[ (string)array_sscanf("-1234567012345670", "%o")[0] ]])
  test_eq("-45954944846776",
	   [[ (string)array_sscanf("-01234567012345670", "%i")[0] ]])
  test_eq("-11", [[ (string)array_sscanf("-1011", "%b")[0] ]])
  test_eq("-1125968643114208", [[ (string)array_sscanf("-100000000000001000000000001000000000100010011100000", "%b")[0] ]])
  test_eq("-11", [[ (string)array_sscanf("-0b1011", "%i")[0] ]])
  test_eq("-1125968643114208", [[ (string)array_sscanf("-0b100000000000001000000000001000000000100010011100000", "%i")[0] ]])

  test_eq([[ sprintf("%x", @array_sscanf("\0\0\0\0\1\2\3\4", "%4c")) ]], "0")
  test_eq([[ sprintf("%x", @array_sscanf("\0\0\0\0\1\2\3\4", "%8c")) ]], "1020304")
  test_eq([[ sprintf("%08x", @array_sscanf("\0\0\0\0\1\2\3\4", "%8c")) ]], "01020304")
  test_eq([[ sprintf("%08x", @array_sscanf("\0\0\0\5\1\2\3\4", "%8c")) ]], "501020304")
  test_eq([[ sprintf("%08x", @array_sscanf("\0\0\6\5\1\2\3\4", "%8c")) ]], "60501020304")
  test_eq([[ sprintf("%08x", @array_sscanf("\0\7\6\5\1\2\3\4", "%8c")) ]], "7060501020304")
  test_eq([[ sprintf("%08x", @array_sscanf("\8\7\6\5\1\2\3\4", "%8c")) ]], "3807060501020304")
  test_eq([[ sprintf("%08x", @array_sscanf("\010\7\6\5\1\2\3\4", "%8c")) ]], "807060501020304")

  test_equal([[ ({ 118 }) ]], [[ array_sscanf("0x76", "%x") ]])
  test_equal([[ ({42 }) ]], [[ array_sscanf("101010", "%b") ]])
  test_equal([[ ({42 }) ]], [[ array_sscanf("0b101010", "%b") ]])
  test_equal([[ ({42 }) ]], [[ array_sscanf("0B101010", "%b") ]])
  test_equal([[ ({ 557239244978618154304871 }) ]],
             [[ array_sscanf("0x76000000000001234567", "%x") ]])

  test_equal([[array_sscanf("foo \12345 bar <fie>","%[^<]")]],
	     [[ ({"foo \12345 bar " }) ]])

  test_equal(471100000000000000000000000000000000000000000000042,
             (int)(mixed)471100000000000000000000000000000000000000000000042)
  test_eq(6745697846498645967,
          [[ Gmp.mpz("6745697846498645967")->cast_to_int(); ]])
]])

cond([[ sizeof( cpp("__AUTO_BIGNUM__")/"__AUTO_BIGNUM__" ) == 1 ]],
[[
  test_eq(0x7fffffff, [[ decode_value(encode_value(0x7fffffff)) ]])
  test_eq(0x7ffffffff, [[ decode_value(encode_value(0x7ffffffff)) ]])
  test_eq(0x7fffffffff, [[ decode_value(encode_value(0x7fffffffff)) ]])
  test_eq(0x7ffffffffff, [[ decode_value(encode_value(0x7ffffffffff)) ]])
  test_eq(0x7fffffffffff, [[ decode_value(encode_value(0x7fffffffffff)) ]])
  test_eq(0x7ffffffffffff, [[ decode_value(encode_value(0x7ffffffffffff)) ]])
  test_eq(0x80000000, [[ decode_value(encode_value(0x80000000)) ]])
  test_eq(0x800000000, [[ decode_value(encode_value(0x800000000)) ]])
  test_eq(0x8000000000, [[ decode_value(encode_value(0x8000000000)) ]])
  test_eq(0x80000000000, [[ decode_value(encode_value(0x80000000000)) ]])
  test_eq(0x800000000000, [[ decode_value(encode_value(0x800000000000)) ]])
  test_eq(0x8000000000000, [[ decode_value(encode_value(0x8000000000000)) ]])
  test_eq(0x12345678, [[ decode_value(encode_value(0x12345678)) ]])
  test_eq(0x123456780, [[ decode_value(encode_value(0x123456780)) ]])
  test_eq(0x1234567801, [[ decode_value(encode_value(0x1234567801)) ]])
  test_eq(0x12345678012, [[ decode_value(encode_value(0x12345678012)) ]])
  test_eq(0x123456780123, [[ decode_value(encode_value(0x123456780123)) ]])
  test_eq(0x1234567801234, [[ decode_value(encode_value(0x1234567801234)) ]])

  test_eq(-0x7fffffff, [[ decode_value(encode_value(-0x7fffffff)) ]])
  test_eq(-0x7ffffffff, [[ decode_value(encode_value(-0x7ffffffff)) ]])
  test_eq(-0x7fffffffff, [[ decode_value(encode_value(-0x7fffffffff)) ]])
  test_eq(-0x7ffffffffff, [[ decode_value(encode_value(-0x7ffffffffff)) ]])
  test_eq(-0x7fffffffffff, [[ decode_value(encode_value(-0x7fffffffffff)) ]])
  test_eq(-0x7ffffffffffff, [[ decode_value(encode_value(-0x7ffffffffffff))]])
  test_eq(-0x80000000, [[ decode_value(encode_value(-0x80000000)) ]])
  test_eq(-0x800000000, [[ decode_value(encode_value(-0x800000000)) ]])
  test_eq(-0x8000000000, [[ decode_value(encode_value(-0x8000000000)) ]])
  test_eq(-0x80000000000, [[ decode_value(encode_value(-0x80000000000)) ]])
  test_eq(-0x800000000000, [[ decode_value(encode_value(-0x800000000000)) ]])
  test_eq(-0x8000000000000, [[ decode_value(encode_value(-0x8000000000000))]])
  test_eq(-0x12345678, [[ decode_value(encode_value(-0x12345678)) ]])
  test_eq(-0x123456780, [[ decode_value(encode_value(-0x123456780)) ]])
  test_eq(-0x1234567801, [[ decode_value(encode_value(-0x1234567801)) ]])
  test_eq(-0x12345678012, [[ decode_value(encode_value(-0x12345678012)) ]])
  test_eq(-0x123456780123, [[ decode_value(encode_value(-0x123456780123)) ]])
  test_eq(-0x1234567801234, [[ decode_value(encode_value(-0x1234567801234))]])
]])

cond([[ sizeof( cpp("__AUTO_BIGNUM__")/"__AUTO_BIGNUM__" ) == 1 ]],
[[
  test_eq(2147483648, -2147483648/-1)
  test_eq(2147483648, -2147483648*-1)

  test_true([[ random(0x7fffffff)+1 ]])
  test_true([[ random(0x7ffffffff)+1 ]])
  test_true([[   sqrt(0x7fffffff)+1 ]])
  test_true([[   sqrt(0x7ffffffff)+1 ]])

  test_true([[ catch { destruct((mixed)0x4783647824687234628462); } ]])

  test_any_equal([[
    array a = ({4711, 0x54325827a124*0x12348795482485425});
    set_weak_flag (a, 1);
    gc();
    return a;
  ]], [[ ({4711, 0x54325827a124*0x12348795482485425}) ]])

  test_any_equal([[
    mapping m = ([
      4711: 0x54325827a124*0x12348795482485425,
      0x54325827124*0x1234879548a2485425: 1174,
    ]);
    set_weak_flag (m, 1);
    gc();
    return m;
  ]], [[ ([
    4711: 0x54325827a124*0x12348795482485425,
    0x54325827124*0x1234879548a2485425: 1174,
  ]) ]])
]])

cond([[ sizeof( cpp("__AUTO_BIGNUM__")/"__AUTO_BIGNUM__" ) == 1 ]],
[[
  test_any([[int a=2147483648; a=a+17;  return a]], 2147483665)
  test_any([[int a=2147483648; a=a-17;  return a]], 2147483631)
  test_any([[int a=2147483648; a=a*17;  return a]], 36507222016)
  test_any([[int a=2147483648; a=a/17;  return a]], 126322567)
  test_any([[int a=2147483648; a=a%17;  return a]], 9)
  test_any([[int a=2147483648; a=a^17;  return a]], 2147483665)
  test_any([[int a=2147483648; a=a&17;  return a]], 0)
  test_any([[int a=2147483648; a=a|17;  return a]], 2147483665)
  test_any([[int a=2147483648; a=a<<17; return a]], 281474976710656)
  test_any([[int a=2147483648; a=a>>17; return a]], 16384)

  test_eq([[2147483648+17 ]], 2147483665)
  test_eq([[2147483648-17 ]], 2147483631)
  test_eq([[2147483648*17 ]], 36507222016)
  test_eq([[2147483648/17 ]], 126322567)
  test_eq([[2147483648%17 ]], 9)
  test_eq([[2147483648^17 ]], 2147483665)
  test_eq([[2147483648&17 ]], 0)
  test_eq([[2147483648|17 ]], 2147483665)
  test_eq([[2147483648<<17]], 281474976710656)
  test_eq([[2147483648>>17]], 16384)

  test_true([[ floatp((1<<99)/3.14) ]]);
  test_true([[ floatp((1<<99)*3.14) ]]);
  test_true([[ floatp((1<<99)-3.14) ]]);
  test_true([[ floatp((1<<99)+3.14) ]]);
]])

cond([[ sizeof( cpp("__AUTO_BIGNUM__")/"__AUTO_BIGNUM__" ) == 1 ]],
[[
  test_any([[int a=10->pow(30); int b=1000000000000000000000000000000; 
            return ([a:1])[b]]],1);
  test_any([[int a=10->pow(30); int b=1000000000000000000000000000000; 
            return (<a>)[b]]],1);
  test_any([[int a=10->pow(30); int b=1000000000000000000000000000000; 
            return sizeof( ({a})-({b}) )]],0);
  test_any([[int a=10->pow(30); int b=1000000000000000000000000000000; 
            return sizeof( ({a})&({b}) )]],1);
  test_any([[int k=10->pow(30); 
	    array a=({k+17,k+16,k+13,k+14,k+12,k,k+9});
            return sort(a)[0]==k && sort(a)[-1]==k+17]],1)

// test the corresponding integer operations first
  test_any([[int k=100; int j=k+1;
	    array a=({k+17,k+16,k+13,k+14,k+12,k,k+9});
	    array b=({j+16,j+15,j+12,j+13,j+11,j-1,j+8});
            return sizeof( a&b )]],7);
  test_any([[int k=100; int j=k+1;
	    array a=({k+17,k+16,k+13,k+14,k+12,k,k+9});
	    array b=({j+13,j+11,j-1,j+8,j+16,j+15,j+12});
            return sizeof( a-b )]],0);

// now the bignum ones
  test_any([[int k=10->pow(30); int j=k+1;
	    array a=({k+17,k+16,k+13,k+14,k+12,k,k+9});
	    array b=({j+16,j+15,j+12,j+13,j+11,j-1,j+8});
            return sizeof( a&b )]],7);
  test_any([[int k=10->pow(30); int j=k+1;
	    array a=({k+17,k+16,k+13,k+14,k+12,k,k+9});
	    array b=({j+13,j+11,j-1,j+8,j+16,j+15,j+12});
            return sizeof( a-b )]],0);

]])

cond([[all_constants()->_verify_internals]],
[[
  test_do(_verify_internals())
]])

test_eq("\377"[0],255)
test_do(add_constant("foo",clone(class c {int i;})))
test_eq(foo->i,0)
test_do(foo->i=17)
test_eq(foo->i,17)
test_do(add_constant("foo"));
test_do(add_constant("foo",clone(class c {array(int) i=({0});})))
test_eq(foo->i[0],0)
test_do(foo->i[0]=17)
test_eq(foo->i[0],17)
test_do(add_constant("foo"));

// signum, signame
test_true(intp(signum("SIGKILL")))

// kill, signal, getpid
test_true(intp(getpid()))
cond([[all_constants()->kill && (cpp("__NT__")/"\n")[1]=="__NT__" ]],
[[
  test_do(signal(signum("SIGFPE"),lambda() { add_constant("AFJLLAF",17); }))
  test_do(kill(getpid(),signum("SIGFPE")))
  test_do(sleep(2))
  test_eq(AFJLLAF,17)
  test_do(add_constant("AFJLLAF"))
  test_do(signal(signum("SIGFPE"), 0))
  test_do(signal(signum("SIGFPE")))
]])

// typeof
test_eq(sprintf("%O", typeof(1)),"int(1..1)")
test_eq(sprintf("%O", typeof("")),"string")
test_eq(sprintf("%O", typeof(""[0])),"int")
test_eq(sprintf("%O", typeof(0.0)),"float")
test_eq(sprintf("%O", typeof(all_constants()["all_constants"])),"mixed")

// _typeof
test_eq(sprintf("%O", _typeof(1)),"int(1..1)")
test_eq(sprintf("%O", _typeof("")),"string")
test_eq(sprintf("%O", _typeof("x"[0])),"int(120..120)")
test_eq(sprintf("%O", _typeof(0.0)),"float")
test_eq(sprintf("%O", _typeof(this_object))-" ","function(:object)")


// class
test_true(programp(class c {}))
test_true(functionp(clone(class c { int foo() { return 1; }})->foo))
test_true(clone(class c { int foo() { return 1; }})->foo())
test_true(clone(class c { int i=1; })->i)
test_false(clone(class c { int foo() { return 1; }})->bar)
test_eq(clone(clone(class c { program foo=class c { int i=20; }; })->foo)->i,20)

// class()
test_true(programp(class c(){}))
test_equal(indices(class c(string a,static int b){}("foo",0)), ({"a"}))
test_equal(values(class c(string a,static int b){}("foo",0)), ({"foo"}))
test_true(programp(class c(string ... a){}))
test_equal(indices(class c(string a,static int ... b){}("foo",0)), ({"a"}))
test_equal(values(class c(static string a, int ... b){}("foo",0)), ({({0})}))

// type checks
test_compile_error([[} int foo() { return]]);
test_compile_error([[} void foo() { return 1]]);
test_compile([[mapping a; int b; a = b = 0;]]);
test_compile_error([[mapping a; int b; a = b = 1;]]);
test_compile_any([[void a(int q){} void b(function(int:void) f){} void c(){b(a);}]]);
test_compile_error_low([[void a(int i){} void b(function(:void) f){} void c(){b(a);}]]);
test_compile_any([[void a(){} function(int:void) b = a;]]);
test_compile_error_low([[void a(int i){} function(:void) b = a;]]);

// Duplicate local variable
test_compile_error([[void f() {int i; int i;}]]);
test_compile_error([[void f() {int i; mapping i;}]]);
test_compile_error([[void f() {int i; void i() {};}]]);
test_compile_error([[void f (int i) {string i;}]]);

// Not yet cataloged
test_any(int i=10; { int i; } return i, 10)
test_program(void foo(int a, int b){} function(int,int:void) a() { return foo; })
test_program(void foo(int a, int ... b){} function(int,int ...:void) a() { return foo; })
test_program(void foo(){} function(:void) a() { return foo; })
test_compile_error([[} void foo(){} function(:string) a() { return foo;]])

test_do(lambda(){return;}())
test_equal( ({ lambda() { return 3; } , lambda() { return 7; }, lambda() { return 9; } })(), ({ 3,7,9 }))
test_any(array(int) a=({10}); a[0]++; return a[0], 11)
test_any(mapping a=([10:11]); a[10]++; return a[10], 12)
test_equal(mkmapping( ({3,6,2}), ({"3","6","2"})), ([3:"3", 6:"6", 2:"2"]))
test_equal(`+(([3:"3", 6:"6", 2:"2"])), ([3:"3", 6:"6", 2:"2"]))
test_true(`+(([3:"3", 6:"6", 2:"2"])) != ([3:"3", 6:"6", 2:"2"]))

test_true(predef::stringp(""))
test_equal([["a,b,4,7,8s,asfd,a,d,f" / ","]],[["a,b,4,7,8s,asfd,a,d,f" / ","]])
test_any([[array(string) a="a,b"/","; a[0]="c"; return equal(a,({"c","b"}))]],1)
test_true(0||1)
test_true(1||0)
test_true(!0||!0)
test_true(!0&&!0)
test_any(mixed a=1; a+=1; return a,2)
test_any(mixed a=1; a-=1; return a,0)
test_equal("abcd"/"" - indices("abcd"),({"a","b","c","d"}))
test_equal("abcd"/"" & indices("abcd"),({}))
test_eq(sizeof("abcd"/"" & "de"/""),1)
test_equal( ({0,0,0,0,0}), ({0,0,0,0,0}))
test_equal( ({"object","object","object","object","object"}), allocate(5,"object"))
test_equal(mkmapping("abcd"/"","jklm"/"") | mkmapping("jclm"/"","alcd"/""),
	mkmapping("abcdjlm"/"","jklmacd"/""))
test_program(int foo() { return 17;} mixed a() { return foo() == 17; })
test_any([[mixed a; a=2; a=a*3; return a]],6)
test_any([[mixed a = ({1}); a=a+({2}); return equal(a,({1,2}))]],1)
test_define_program(test,[[int foo() { return 17; }]])
test_any(function bar=clone(test)->foo; return bar(),17)

// sscanf
test_any([[mixed a; return sscanf("11","%d",a)]],1)

test_any([[mixed a; sscanf("11","%d",a); return a]],11)
test_any([[mixed a; sscanf("11","%o",a); return a]],011)
test_any([[mixed a; sscanf("11","%x",a); return a]],0x11)
test_any([[mixed a; sscanf("11","%D",a); return a]],11)


test_any([[mixed a; sscanf("11","%2d",a); return a]],11)
test_any([[mixed a; sscanf("11","%2o",a); return a]],011)
test_any([[mixed a; sscanf("11","%2x",a); return a]],0x11)
test_any([[mixed a; sscanf("11","%2D",a); return a]],11)

test_any([[mixed a; sscanf("11","%4711d",a); return a]],11)
test_any([[mixed a; sscanf("11","%4711o",a); return a]],011)
test_any([[mixed a; sscanf("11","%4711x",a); return a]],0x11)
test_any([[mixed a; sscanf("11","%4711D",a); return a]],11)

test_any([[mixed a; sscanf("11","%1d",a); return a]],1)
test_any([[mixed a; sscanf("11","%1o",a); return a]],1)
test_any([[mixed a; sscanf("11","%1x",a); return a]],1)
test_any([[mixed a; sscanf("11","%1D",a); return a]],1)

test_any([[mixed a; sscanf("0x11","%D",a); return a]],0x11)
test_any([[mixed a; sscanf("011","%D",a); return a]],011)
test_any([[mixed a,b; return sscanf("11foo","%dfoo",a)]],1)
test_any([[mixed a,b; sscanf("11foo","%dfoo",a); return a]],11)
test_any([[mixed a,b; return sscanf("11foo","%d%s",a,b)]],2)
test_any([[mixed a,b; sscanf("11foo","%d%s",a,b); return b]],"foo")
test_any([[mixed a,b; return sscanf("foo","%c%s",b,a)]],2)
test_any([[mixed a,b; sscanf("foo","%c%s",b,a); return b]],'f')
test_any([[mixed a,b; sscanf("foo","%c%s",b,a); return a]],"oo")
test_any([[mixed a,b; return sscanf("1.0","%f",a),a]],1.0)
test_any([[mixed a,b; return sscanf("-1.0","%f",a),a]],-1.0)
test_any([[mixed a,b; return sscanf("1.25","%f",a),a]],1.25)
test_any([[mixed a,b; return sscanf("-1.25","%f",a),a]],-1.25)
test_any([[mixed a,b; return sscanf("1.25e3","%f",a),a]],1.25e3)
test_any([[mixed a,b; return sscanf("-1.25e3","%f",a),a]],-1.25e3)
test_any([[mixed a,b; return sscanf("1.25e-3","%f",a),a]],1.25e-3)
test_any([[mixed a,b; return sscanf("-1.25e-3","%f",a),a]],-1.25e-3)
test_any([[mixed a,b; sscanf("1.0","%f",a); return a]],1.0)
test_any([[mixed a,b; sscanf("-z ","%[-z]%s",a,b); return a]],"-z")
test_any([[mixed a,b; sscanf("-z ","%[z-]%s",a,b); return a]],"-z")
test_any([[mixed a,b; sscanf("abcdeFGji","%[a-z]%s",a,b); return a]],"abcde")
test_any([[mixed a,b; sscanf("abcdeFGji","%[a-z]%s",a,b); return b]],"FGji")

test_any([[mixed a,b; return sscanf("foo-%-bar","%s-%%-%s",a,b);]],2)
test_any([[mixed a,b; sscanf("foo-%-bar","%s-%%-%s",a,b); return a]],"foo")
test_any([[mixed a,b; sscanf("foo-%-bar","%s-%%-%s",a,b); return b]],"bar")
test_any([[mixed a; sscanf("ab","%2c",a); return a]],'a'*256+'b')
test_any([[mixed a; sscanf("abc","%3c",a); return a]],'a'*256*256+'b'*256+'c')
test_any([[mixed a; sscanf("abc","%2c",a); return a]],'a'*256+'b')
test_any([[mixed a; sscanf("ac","%3c",a); return a]],0)
test_any([[mixed a; sscanf("ab","%2s",a); return a]],"ab")
test_any([[mixed a; sscanf("abc","%3s",a); return a]],"abc")
test_any([[mixed a; sscanf("abc","%2s",a); return a]],"ab")
test_any([[mixed a; sscanf("ac","%3s",a); return a]],0)
test_any([[mixed a; sscanf("a3","%*s%d",a); return a]],3)
test_any([[mixed a; sscanf("a3","%s%*d",a); return a]],"a")
test_any([[mixed a; sscanf("a93","%s%*o",a); return a]],"a9")
test_any([[mixed a; sscanf("a93","%*s%o",a); return a]],3)
test_any([[mixed a; sscanf("a93","%s%*x",a); return a]],"")
test_any([[mixed a; sscanf("a93","%*s%x",a); return a]],0xa93)
test_any([[mixed a; sscanf("f","f%n",a); return a]],1)

test_any([[mixed a; sscanf("\102\052\100\000","%F",a); return a]],42.5625)
test_any([[mixed a; sscanf("\102\052\100\000","%4F",a); return a]],42.5625)
test_any([[mixed a; sscanf("\100\105\110\000\0\0\0\0","%8F",a); return a]],42.5625)
test_any([[mixed a; sscanf("\275\007\053\002","%4F",a); return a]],-0.032999999821186065673828125)
test_any([[mixed a; sscanf("\277\240\345\140\100\0\0\0","%8F",a); return a]],-0.032999999821186065673828125)

// Inf
test_any([[mixed a; sscanf("\177\200\0\0","%4F",a); return a>0.0]],1)
test_any([[mixed a; sscanf("\177\200\0\0","%4F",a); return (a/2)==a]],1)
// -Inf
test_any([[mixed a; sscanf("\377\200\0\0","%4F",a); return a<0.0]],1)
test_any([[mixed a; sscanf("\377\200\0\0","%4F",a); return (a/2)==a]],1)
// NaN
test_any([[mixed a; sscanf("\177\300\0\0","%4F",a); return a>0.0]],0)
test_any([[mixed a; sscanf("\177\300\0\0","%4F",a); return a<0.0]],0)
test_any([[mixed a; sscanf("\177\300\0\0","%4F",a); return a==0.0]],0)
// -NaN
test_any([[mixed a; sscanf("\377\300\0\0","%4F",a); return a>0.0]],0)
test_any([[mixed a; sscanf("\377\300\0\0","%4F",a); return a<0.0]],0)
test_any([[mixed a; sscanf("\377\300\0\0","%4F",a); return a==0.0]],0)

// Inf
test_any([[mixed a; sscanf("\177\360\0\0\0\0\0\0","%8F",a); return a>0.0]],1)
test_any([[mixed a; sscanf("\177\360\0\0\0\0\0\0","%8F",a); return(a/2)==a]],1)
// -Inf
test_any([[mixed a; sscanf("\377\360\0\0\0\0\0\0","%8F",a); return a<0.0]],1)
test_any([[mixed a; sscanf("\377\360\0\0\0\0\0\0","%8F",a); return(a/2)==a]],1)
// NaN
test_any([[mixed a; sscanf("\177\370\0\0\0\0\0\0","%8F",a); return a>0.0]],0)
test_any([[mixed a; sscanf("\177\370\0\0\0\0\0\0","%8F",a); return a<0.0]],0)
test_any([[mixed a; sscanf("\177\370\0\0\0\0\0\0","%8F",a); return a==0.0]],0)
// -NaN
test_any([[mixed a; sscanf("\377\370\0\0\0\0\0\0","%8F",a); return a>0.0]],0)
test_any([[mixed a; sscanf("\377\370\0\0\0\0\0\0","%8F",a); return a<0.0]],0)
test_any([[mixed a; sscanf("\377\370\0\0\0\0\0\0","%8F",a); return a==0.0]],0)

test_equal([[array_sscanf("10 20 30","%d %d %d")]],[[({10,20,30})]])
test_equal([[array_sscanf("1 2 3 4 5 6 7 8 9","%d %d %d %d %d %d %d %d %s")]],[[({1,2,3,4,5,6,7,8,"9"})]])
test_equal([[array_sscanf("abc","%{%c%}")]],[[ ({ ({ ({'a'}), ({'b'}), ({'c'}) }) }) ]])

test_equal([[array_sscanf("\x7fffffab#", "%c%c")]], [[ ({ 0x7fffffab, '#' }) ]])
test_equal([[array_sscanf("\x7fffffab#", "%1c%1c")]], [[ ({  }) ]])

test_true([[array_sscanf("(02323) 23455 344","%{%*[^0-9]%[0-9]%}")]])

test_eq([[ array_sscanf(sprintf("%4c",16909060),"%4c")[0] ]],16909060)
test_eq([[ array_sscanf(sprintf("%-4c",16909060),"%-4c")[0] ]],16909060)

test_equal([[array_sscanf("\1000\1001\2000","%[\1000-\1111]%s")]],
	[[ ({ "\1000\1001", "\2000" }) ]])

test_equal([[array_sscanf("foo\1000\1001\1111\1110\2000","%s%[\1000-\1111]%s")]],
	[[ ({ "foo", "\1000\1001\1111\1110", "\2000" }) ]])

test_equal([[array_sscanf("\2000\1000\1111\1001\1110foo","%s%[\1000-\1111]%s")]],
	[[ ({  "\2000", "\1000\1111\1001\1110", "foo"}) ]])

test_equal([[ array_sscanf("02 00 DC 00 0B","%{%x%*[\0-/:-@]%}")[0] ]],
    [[ ({ ({2}), ({0}), ({220}),({0}), ({11}) }) ]])

test_equal([[ array_sscanf("\51726\30212\66610\30131", "%*[ \t]%s")[0] ]],
    [[ "\51726\30212\66610\30131" ]])

test_equal([[ array_sscanf("hej","%s") ]], [[ ({ "hej" }) ]])
test_equal([[ array_sscanf("hej","%s%n") ]], [[ ({ "hej", 3 }) ]])
test_eval_error([[ function f=array_sscanf; f("hej","%s% ") ]])
	
test_any([[
class Bar {
  string sum = "";
  void bar(string s) {
    sum += s;
  }
  string foo()
  {
    foreach(({ "foo ", "bar ", "baz " }), string s) {
      sscanf(s, "%*[\t ]%[^ \t]", s);
      switch(foo) {
      default:
        bar(s);
        break;
      }
    }
    return sum;
  }
};
  return Bar()->foo()
]], "foobarbaz")


// Basics
test_true(1)
test_true("")
test_true(!0)
test_true(!(!1))
test_true(this_object())
test_true(a) // a is the test function
test_true(0.0)
test_true(([]))
test_true(({}))
test_true((<>))
test_true(object_program(this_object()))

// testing !
test_equal(!"",0)
test_equal(!this_object(),0)
test_equal(
#pike 7.0
!Simulate.this_function(),0)

// testing ==
test_true(1==1)
test_true(!(1==2))
test_true(""=="")
test_true(!(""=="foo"))
test_true(this_object()==this_object())
test_true(
#pike 7.0
Simulate.this_function()==a)
test_true(2.0==2.0)
test_true(({})==({}))

// testing !=
test_true(({1})!=({1}))
test_true(1!=2)
test_true(!(1==2))
test_true(!(""!=""))
test_true(""!="foo")

test_cmp3(1,2,3)
test_cmp3(1.0,2.0,3.0)
test_cmp3(1,2.0,3.6)
test_cmp3(1.0,2,4)
test_cmp3("a","b","c")
test_cmp3("","b","cc")
test_cmp3("\x0","\x100","\x10000")
test_cmp3("a\x10000","b\x100","c\x100")

// hex construction
test_eq(0,0x0)
test_eq(1,0x1)
test_eq(10,0xa)
test_eq(16,0x10)
test_eq(65535,0xffff)
test_eq(17*257*65537,0x11111111)

// octal construction
test_eq(0,00)
test_eq(1,01)
test_eq(8,010)
test_eq(64,0100)
test_eq(1073741824,010000000000)
test_eq((8+1)*(8*8+1)*(8*8*8*8+1),011111111)

// string construction tests
test_eq(16,"\20"[0])
test_eq(16,"\020"[0])
test_eq(255,"\377"[0])
test_eq(4,'\4')
test_true("\r"[0]!='r')
test_eq("\r"[0],'\r')
test_eq("\n"[0],'\n')

// testing +
test_eq(1+1,2)
test_eq(1+(-2),-1)
test_eq((-2)+(-2),-4)
test_eq("hi"+"there","hithere")
test_eq("human"+"number"+666,"humannumber666")
test_eq("human"+("number"+666),"humannumber666")
test_eq(("human"+"number")+666,"humannumber666")
test_eq(("human"+"number")+666+111,"humannumber666111")
test_eq("humannumber"+(666+111),"humannumber777")
test_eq("a"+"b"+"c"+"d"+"e"+"f"+"g"+"h"+"i"+"j"+"k"+"l"+"m"+"n"+"o"+"p"+"q"+"r"+"s"+"t"+"u"+"v"+"x"+"y","abcdefghijklmnopqrstuvxy")
test_eq(1.0+1.0,2.0)
test_eq(1.0+(-1.0),0.0)
test_eq((-1.0)+(-1.0),-2.0)
test_eq(1.0+1,2.0)
test_eq(1+1.0,2.0)
test_eq(1+(-1.0),0.0)
test_eq(1.0+(-1),0.0)
test_eq((-1)+(-1.0),-2.0)
test_eq((-1.0)+(-1),-2.0)
test_equal(({1,2,3})+({4,5,6}),({1,2,3,4,5,6}))
test_equal((<1,2,3,4>)+(<4,5,6>),(<1,2,3,4,4,5,6>))
test_equal(([0:1,3:6])+([5:2,3:6]),([0:1,3:6,3:6,5:2]))
test_eval_error(return this_object() + this_object())

// testing -
test_eq(10-3,7)
test_eq(3-10,-7)
test_eq(10.0-3.0,7.0)
test_eq(3.0-10.0,-7.0)
test_eq(10-3.0,7.0)
test_eq(3-10.0,-7.0)
test_eq(10.0-3,7.0)
test_eq(3.0-10,-7.0)
test_eq(034567 - 10000,4711)
test_eq("foobargazonk"-"o","fbargaznk")
test_equal(({"foo","bar","gazonk"})-({"foo","gazonk"}),({"bar"}))
test_equal(({"c","foo","bar","gazonk","a","b",})-({"foo","gazonk"}),({"c","bar","a","b"}))
test_equal((<"foo","bar","gazonk">)-(<"foo","gazonk">),(<"bar">))
test_equal((["foo":3,"bar":4,"gazonk":5])-(["foo":3,"gazonk":8]),(["bar":4]))

// testing ~
test_eq(-1-4,~4)
test_eq(-1-627893874,~627893874)
test_eq(~1.0,-2.0)
test_eq(~"\x55","\xaa")

// testing *
test_eq(3*4,12)
test_eq(4*3,12)
test_eq(2*2*2*2*2,32)
test_eq(3.0*4.0,12.0)
test_eq(4.0*3.0,12.0)
test_eq(2.0*2.0*2.0*2.0*2.0,32.0)
test_eq(3*4.0,12.0)
test_eq(4*3.0,12.0)
test_eq(2*2.0*2.0*2.0*2.0,32.0)
test_eq(3.0*4,12.0)
test_eq(4.0*3,12.0)
test_eq(2.0*2*2.0*2*2.0,32.0)

test_eq(({"foo","bar","gazonk"})*"-","foo-bar-gazonk")
test_eq(({"f\777\777","bar","gaz\777nk"})*"-","f\777\777-bar-gaz\777nk")
test_eq(({"f\7777777\7777777","bar","gaz\7777777nk"})*"-","f\7777777\7777777-bar-gaz\7777777nk")

test_eq(({"foo","bar","gazonk"})*"\777","foo\777bar\777gazonk")
test_eq(({"f\777\777","bar","gaz\777nk"})*"\777","f\777\777\777bar\777gaz\777nk")
test_eq(({"f\7777777\7777777","bar","gaz\7777777nk"})*"\777","f\7777777\7777777\777bar\777gaz\7777777nk")

test_eq(({"foo","bar","gazonk"})*"\7777777","foo\7777777bar\7777777gazonk")
test_eq(({"f\777\777","bar","gaz\777nk"})*"\7777777","f\777\777\7777777bar\7777777gaz\777nk")
test_eq(({"f\7777777\7777777","bar","gaz\7777777nk"})*"\7777777","f\7777777\7777777\7777777bar\7777777gaz\7777777nk")


test_equal( ({ ({1}), ({2}), ({3}) })*({8}), ({1,8,2,8,3}))
test_equal( ({ 1 })*3, ({1,1,1}) )
test_equal( "foo"*3, "foofoofoo" )
test_equal( "foo"*2.5, "foofoofo" )
test_equal( "\1234oo"*2.5, "\1234oo\1234oo\1234o" )

test_equal( ({1,2,3})*1.5, ({1,2,3,1,2}))
test_equal( ({1,2,3})*1.4, ({1,2,3,1}))
test_equal( ({1,2,3})*0.0, ({}))
test_equal( ({})*3.0, ({}))



// testing /
test_eq(12/3,4)
test_eq(13/3,4)
test_eq(14/3,4)
test_eq(15/3,5)
test_eq(-2/4,-1)
test_eq(-12/3,-4)
test_eq(-13/3,-5)
test_eq(-14/3,-5)
test_eq(-15/3,-5)
test_eval_error(return 15/0)
test_eq(12.0/3.0,4.0)
test_eq(14.0/4.0,3.5)
test_eq(15.0/3.0,5.0)
test_eq(12/3.0,4.0)
test_eq(14/4.0,3.5)
test_eq(15/3.0,5.0)
test_eq(12.0/3,4.0)
test_eq(14.0/4,3.5)
test_eq(15.0/3,5.0)
test_eval_error(return 15.0/0.0)
test_equal("foo-bar-gazonk"/"-",({"foo","bar","gazonk"}))
test_equal("foobargazonk"/"",({"f","o","o","b","a","r","g","a","z","o","n","k"}))
test_equal(({1,0,1,2,1,2,2,2,1,1,1})/({2}),({ ({1,0,1}), ({1}), ({}), ({}), ({1,1,1}) }))
test_equal(({1,2,3,4})/({}),({ ({1}), ({2}), ({3}), ({4}) }))
test_equal(({1,0,1,2,1,2,2,2,1,1,1})/({2,1}),({ ({1,0,1}), ({2,2}), ({1,1}) }))
test_equal( ({1,2,3})/({2,3}), ({ ({1}), ({}) }) )
test_eq([[`/(20,2,2)]],5)
test_eq([[`/(13,2,3)]],2)
test_equal("foobargazonk"/1,"foobargazonk"/"")
test_equal("foobargazonk"/2,({"fo","ob","ar","ga","zo","nk"}))
test_equal("foobargazonk"/3,({"foo","bar","gaz","onk"}))
test_equal("foobargazonk"/4,({"foob","arga","zonk"}))
test_equal("foobargazonk"/5,({"fooba","rgazo"}))
test_equal("foobargazonk"/-6,({"foobar","gazonk"}))
test_equal("foobargazonk"/-7,({"rgazonk"}))

test_equal("foobargazonk"/5.0,({"fooba","rgazo","nk"}))
test_equal("foobargazonk"/-5.0,({"fo","obarg","azonk"}))
test_equal("foobargazonk"/2.5,({"foo","ba","rga","zo","nk"}))
test_equal("foo"/2.6,({"foo",""}))
test_equal("\1233oo"/2.6,({"\1233oo",""}))

test_equal("f\777\777bargaz\777nk"/1,"f\777\777bargaz\777nk"/"")
test_equal("f\777\777bargaz\777nk"/2,({"f\777","\777b","ar","ga","z\777","nk"}))
test_equal("f\777\777bargaz\777nk"/3,({"f\777\777","bar","gaz","\777nk"}))
test_equal("f\777\777bargaz\777nk"/4,({"f\777\777b","arga","z\777nk"}))
test_equal("f\777\777bargaz\777nk"/5,({"f\777\777ba","rgaz\777"}))
test_equal("f\777\777bargaz\777nk"/-6,({"f\777\777bar","gaz\777nk"}))
test_equal("f\777\777bargaz\777nk"/-7,({"rgaz\777nk"}))

test_equal("f\777\777bargaz\777nk"/5.0,({"f\777\777ba","rgaz\777","nk"}))
test_equal("f\777\777bargaz\777nk"/-5.0,({"f\777","\777barg","az\777nk"}))
test_equal("f\777\777bargaz\777nk"/2.5,({"f\777\777","ba","rga","z\777","nk"}))

test_equal("f\7777777\7777777bargaz\7777777nk"/1,"f\7777777\7777777bargaz\7777777nk"/"")
test_equal("f\7777777\7777777bargaz\7777777nk"/2,({"f\7777777","\7777777b","ar","ga","z\7777777","nk"}))
test_equal("f\7777777\7777777bargaz\7777777nk"/3,({"f\7777777\7777777","bar","gaz","\7777777nk"}))
test_equal("f\7777777\7777777bargaz\7777777nk"/4,({"f\7777777\7777777b","arga","z\7777777nk"}))
test_equal("f\7777777\7777777bargaz\7777777nk"/5,({"f\7777777\7777777ba","rgaz\7777777"}))
test_equal("f\7777777\7777777bargaz\7777777nk"/-6,({"f\7777777\7777777bar","gaz\7777777nk"}))
test_equal("f\7777777\7777777bargaz\7777777nk"/-7,({"rgaz\7777777nk"}))

test_equal("f\7777777\7777777bargaz\7777777nk"/5.0,({"f\7777777\7777777ba","rgaz\7777777","nk"}))
test_equal("f\7777777\7777777bargaz\7777777nk"/-5.0,({"f\7777777","\7777777barg","az\7777777nk"}))
test_equal("f\7777777\7777777bargaz\7777777nk"/2.5,({"f\7777777\7777777", "ba","rga","z\7777777","nk"}))

test_equal(({1,2,3})/1,({ ({1}), ({2}), ({3}) }))
test_equal(({1,2,3})/2,({ ({1,2}) }))
test_equal(({1,2,3})/-2,({ ({2,3}) }))

test_equal(({1,2,3})/2.0,({ ({1,2}), ({3}) }))
test_equal(({1,2,3})/-2.0,({ ({1}), ({2,3}) }))
test_equal(({1,2,3})/1.5,({ ({1, 2}), ({3}) }))

// testing %
test_eq(12%3,0)
test_eq(13%3,1)
test_eq(14%3,2)
test_eq(15%3,0)
test_eq(2%17,2)
test_eq(2%-17,-15)
test_eq(-2%17,15)
test_eq(-2%-17,-2)
test_eq(-10%10,0)
test_eq(10%-10,0)
test_eq(-10%-10,0)
test_eq(10%10,0)
test_eval_error(return 15 % 0)
test_eq(12.0 % 3.0,0.0)
test_eq(13.0 % 3.0,1.0)
test_eq(14.0 % 3.0,2.0)
test_eq(14.5 % 3.0,2.5)
test_eq(15.0 % 3.0,0.0)
test_eq(13 % 3.0,1.0)
test_eq(14 % 3.0,2.0)
test_eq(13.0 % 3,1.0)
test_eq(14.0 % 3,2.0)
test_eq(14.5 % 3,2.5)
test_eval_error(return 15.0 % 0.0)

test_eq("foobargazonk"%5,"nk")
test_eq("foobargazonk"%-5,"fo")
test_eq("f\777\777bargaz\777nk"%5,"nk")
test_eq("f\777\777bargaz\777nk"%-5,"f\777")
test_eq("f\7777777\7777777bargaz\7777777nk"%5,"nk")
test_eq("f\7777777\7777777bargaz\7777777nk"%-5,"f\7777777")
test_equal(({1,2,3})%2,({3}))
test_equal(({1,2,3})%-2,({1}))


// testing &&
test_eq(0 && 1,0)
test_eq(1 && 0,0)
test_eq(0 && 0,0)
test_eq(1 && 1,1)
test_eq(78 && 1,1)
test_eq(78 && 99,99)
test_eq(78 && 99,99)

// testing ||
test_eq(0 || 1,1)
test_eq(1 || 0,1)
test_eq(0 || 0,0)
test_eq(1 || 1,1)
test_eq(78 || 1,78)
test_eq(78 || 0,78)

// testing |
test_eq(0 | 0,0)
test_eq(1 | 1,1)
test_eq(4 | 1,5)
test_eq(1 | 9,9)
test_equal( ({1,2,3,4,4}) | ({3,5,6}), ({1,2,4,4,3,5,6}))
test_equal( (<4,5,6>) | (<5,5,5>), (<4,5,5,5,6>) )
test_equal( ([-4:8,8:7]) | ([3:3,8:3]), ([-4:8,8:3,3:3]) )
test_any([[
  class Foo {int `< (object o) {return 0;}};
  return sizeof (({Foo()}) | ({Foo()}));
]], 2)

// testing &
test_eq(0 & 0,0)
test_eq(1 & 1,1)
test_eq(4 & 1,0)
test_eq(1 & 9,1)
test_equal( ({1,2,3,4,4}) & ({3,5,6}), ({3}))
test_equal( (<4,5,6>) & (<5,5,5>), (<5>) )
test_equal( ([-4:8,8:7]) & ([3:3,8:3]), ([8:3]) )

// testing ^
test_eq(0 ^ 0,0)
test_eq(1 ^ 1,0)
test_eq(4 ^ 1,5)
test_eq(1 ^ 9,8)
test_equal( Array.sort( ({1,2,3,4,4}) ^ ({3,5,6}) ) , ({1,2,4,4,5,6}))
test_equal( (<4,5,6>) ^ (<5,5,5>), (<4,5,5,6>) )
test_equal( ([-4:8,8:7]) ^ ([3:3,8:3]), ([-4:8,3:3]) )

// testing <<
test_eq(1<<0,1)
test_eq(1<<1,2)
test_eq(1<<10,1024)
test_eq(5<<3,40)

// testing >>
test_eq(9>>2,2)
test_eq(1>>1,0)
test_eq(1024>>10,1)
test_eq(47>>3,5)

// testing ? :
test_true(0?0:1)
test_true(1?1:0)
test_true(""?1:0)
test_true(!0?1:0)
test_true(!(!1)?1:0)
test_true(this_object()?1:0)
test_true(a?1:0) // a is the test function
test_true(0.0?1:0)
test_true(([])?1:0)
test_true(({})?1:0)
test_true((<>)?1:0)
test_true(object_program(this_object())?1:0)
test_eq(1 ? "a" : 1 ? "b" : 1, "a")
test_eq(0 ? "a" : 1 ? "b" : 1 ? "c" : 1, "b")
test_eq(0 ? "a" : 0 ? "b" : 1 ? "c" : 1, "c")

// testing indexing
test_eq("foo"[0],'f')
test_eq("foo"[1],'o')
test_eq("foo"[2],'o')
test_eq("foo"[-1],'o')
test_eq("foo"[-2],'o')
test_eq("foo"[-3],'f')

test_eq("f\777\777"[0],'f')
test_eq("f\777\777"[1],'\777')
test_eq("f\777\777"[2],'\777')
test_eq("f\777\777"[-1],'\777')
test_eq("f\777\777"[-2],'\777')
test_eq("f\777\777"[-3],'f')

test_eq("f\77777777\77777777"[0],'f')
test_eq("f\77777777\77777777"[1],'\77777777')
test_eq("f\77777777\77777777"[2],'\77777777')
test_eq("f\77777777\77777777"[-1],'\77777777')
test_eq("f\77777777\77777777"[-2],'\77777777')
test_eq("f\77777777\77777777"[-3],'f')

test_eq(({'f','o','o'})[0],'f')
test_eq(({'f','o','o'})[1],'o')
test_eq(({'f','o','o'})[2],'o')
test_eq(({'f','o','o'})[-1],'o')
test_eq(({'f','o','o'})[-2],'o')
test_eq(({'f','o','o'})[-3],'f')
test_eq(([0:'f',1:'o',2:'o'])[0],'f')
test_eq(([0:'f',1:'o',2:'o'])[1],'o')
test_eq(([0:'f',1:'o',2:'o'])[2],'o')
test_eq(([0:'f',1:'o',2:'o'])[3],0)
test_eq(([0:'f',1:'o',2:'o'])[-1],0)
test_eq((<'f','o','o'>)['o'],1)
test_eq((<'f','o','o'>)['f'],1)
test_eq((<'f','o','o'>)['b'],0)
test_eq((<'f','o','o'>)[-1],0)

test_eq([[class Z { mixed `->(mixed x) { return this_object()[x]; } int foo() { return 1; }}()->foo()]],1)

// index assigning
test_any(mixed a=({1}); a[0]=2; return equal(a,({2})),1)
test_any(mixed a=(<1>); a[1]=2; return equal(a,(<1>)),1)
test_any(mixed a=(<1>); a[0]=2; return equal(a,(<1,0>)),1)
test_any(mixed a=(<1>); a[1]=0; return equal(a,(<>)),1)
test_any(mixed a=(<1>); a[0]=0; return equal(a,(<1>)),1)
test_any(mixed a=([1:1]); a[0]=0; return equal(a,([1:1,0:0])),1)
test_any(mixed a=([1:1]); a[1]=0; return equal(a,([1:0])),1)

test_define_program(test,[[public int q,w,e,r; mixed t; mixed getw() { return w; } void setw(int _) { w=_; }]])
test_eq(clone(test)->q,0)
test_eq(clone(test)->w,0)
test_eq(clone(test)->e,0)
test_eq(clone(test)->r,0)
test_eq(clone(test)->getw(),0)
test_any(object o=clone(test); o->setw(17); return o->w,17)
test_any(object o=clone(test); o->w=17; return o->getw(),17)

test_eq(clone(test)["q"],0)
test_eq(clone(test)["w"],0)
test_eq(clone(test)["e"],0)
test_eq(clone(test)["r"],0)
test_eq(clone(test)["getw"](),0)
test_any(object o=clone(test); o["setw"](17); return o["w"],17)
test_any(object o=clone(test); o["w"]=17; return o["getw"](),17)

// testing range
test_eq("foObar"[0..0],"f")
test_eq("foobargazonk"[3..5],"bar")
test_eq("foo"[1..10],"oo")
test_eq("foo"[-100..0],"f")
test_eq("foo"[-100..100],"foo")
test_eq("foo"[1..0],"")
test_eq("foo"[0..-100],"")
test_eq("foobargazonk"[0..],"foobargazonk")
test_eq("foobargazonk"[1..],"oobargazonk")
test_eq("foobargazonk"[5..],"rgazonk")
test_eq("foobargazonk"[..2],"foo")
test_eq("foobargazonk"[..5],"foobar")

test_eq("f\7777\7777bargaz\7777nk"[0..],"f\7777\7777bargaz\7777nk")
test_eq("f\7777\7777bargaz\7777nk"[1..],"\7777\7777bargaz\7777nk")
test_eq("f\7777\7777bargaz\7777nk"[5..],"rgaz\7777nk")
test_eq("f\7777\7777bargaz\7777nk"[..2],"f\7777\7777")
test_eq("f\7777\7777bargaz\7777nk"[..5],"f\7777\7777bar")

test_eq("f\77777777\77777777bargaz\77777777nk"[0..],"f\77777777\77777777bargaz\77777777nk")
test_eq("f\77777777\77777777bargaz\77777777nk"[1..],"\77777777\77777777bargaz\77777777nk")
test_eq("f\77777777\77777777bargaz\77777777nk"[5..],"rgaz\77777777nk")
test_eq("f\77777777\77777777bargaz\77777777nk"[..2],"f\77777777\77777777")
test_eq("f\77777777\77777777bargaz\77777777nk"[..5],"f\77777777\77777777bar")

test_equal(({1,2,3})[0..0],({1}))
test_equal(({1,2,3})[1..2],({2,3}))
test_equal(({1,2,3})[2..10],({3}))
test_equal(({1,2,3})[-100..0],({1}))
test_equal(({1,2,3})[-100..100],({1,2,3}))
test_equal(({1,2,3})[1..0],({}))
test_equal(({1,2,3})[0..-100],({}))

// casting
test_eq([[(int)1]],[[1]])
test_eq([[(int)-1]],[[-1]])
test_eq([[(int)1.0]],[[1]])
test_eq([[(int)-1.0]],[[-1]])
test_eq([[(int)"1"]],[[1]])
test_eq([[(int)"-1"]],[[-1]])
test_eq([[(int)"0x1"]],[[0]])
test_eq([[(int)"010"]],[[10]])
test_eq([[(float)"1"]],[[1.0]])
test_eq([[(float)"-1"]],[[-1.0]])
test_eq([[(float)"1.0"]],[[1.0]])
test_eq([[(float)"-1.0"]],[[-1.0]])
test_eq([[(float)1.0]],[[1.0]])
test_eq([[(float)-1.0]],[[-1.0]])
test_eq([[(float)1]],[[1.0]])
test_eq([[(float)-1]],[[-1.0]])
test_eq([[(string)1]],[["1"]])
test_eq([[(string)-1]],[["-1"]])
test_equal([[(array)(["1":1])]],[[ ({ ({"1", 1}) }) ]])
test_equal([[(array(int)) ({"1","4711",2.0,4})]],[[({1,4711,2,4})]])
test_equal([[(array(array))({({})})]],[[({({})})]])
test_equal([[ (array(array(int))) ({ ({"1","4711",2.0,4}) }) ]],[[ ({ ({1,4711,2,4}) }) ]])
test_equal([[ (array(array(array(int)))) ({ ({ ({"1","4711",2.0,4}) }) }) ]],[[ ({ ({ ({1,4711,2,4}) }) }) ]])
test_equal([[ (array(array(array(array(int))))) ({ ({ ({ ({"1","4711",2.0,4}) }) }) }) ]],[[ ({ ({ ({ ({1,4711,2,4}) }) }) }) ]])

test_equal([[(array)"foo"]],[[ values("foo") ]])
test_equal([[(array)(<1,2,3>)]],[[ indices( (<1,2,3>) )]])
test_equal([[sort(column((array)([1:2,3:4]),0))]],[[ sort(indices(([1:2,3:4])) )]])
test_equal([[sort(column((array)([1:2,3:4]),1))]],[[ sort(values(([1:2,3:4])))]])
test_true([[(array(array))([]) ]])
test_true([[(array(array))([1:2]) ]])
test_true([[(array(array))([1:2,3:4]) ]])
test_true([[(array(array))([1:2,3:4,5:6]) ]])
test_equal( [[ (multiset) ({1})]], [[ (< 1 >) ]] )
test_eval_error([[return (mapping)""]])
test_equal([[ (mapping)({({1,2}),({3,4})})]], [[([1:2,3:4]) ]])
test_equal([[ ({({1,2})})]], [[(array)([1:2]) ]])
test_equal([[ (mapping)({})]], [[ ([]) ]])
test_equal([[ ({}) ]], [[ (array)([]) ]])
test_eval_error([[ mapping m=(mapping)({ ({1,2,3}), ({4,5,6}) }); ]])

// testing @
test_equal(({1,2,3}),lambda(mixed ... x) { return x; }(@a()))
test_equal("foo"/"",lambda(mixed ... x) { return x; }(@a()))
test_any([[array a=({1,2,3}); return lambda(mixed ... x) { return x; }(@a) !=a]],1)
test_any([[array z=({lambda(mixed x){return x;},17});return `()(@z);]],17)

// testing +=
test_any(int a=1; a+=10; return a,11)
// testing -=
test_any(int a=1; a-=10; return a,-9)
// testing &=
test_any(int a=3; a&=10; return a,2)
// testing |=
test_any(int a=3; a|=10; return a,11)
// testing ^=
test_any(int a=3; a^=10; return a,9)
// testing <<=
test_any(int a=3; a<<=2; return a,12)
// testing <<=
test_any(int a=12; a>>=2; return a,3)
// testing *=
test_any(int a=12; a*=2; return a,24)
// testing /=
test_any(int a=12; a/=2; return a,6)
// testing %=
test_any(int a=12; a%=7; return a,5)

// testing control structs
test_any(return 1,1)
test_any(return lambda(){return 1;} (),1 )
test_any(if(0) return 0; else return 1,1)
test_any(if(0) return 0; return 1,1)
test_any(if(1) return 1; else return 0,1)
test_any(if("") return 1; else return 0,1)
test_any(if(!0) return 1; else return 0,1)
test_any(if(!(!1)) return 1; else return 0,1)
test_any(if(this_object()) return 1; else return 0,1)
test_any(if(a) return 1; else return 0,1) dnl a is the test function
test_any(if(0.0) return 1; else return 0,1)
test_any(if(([])) return 1; else return 0,1)
test_any(if(({})) return 1; else return 0,1)
test_any(if((<>)) return 1; else return 0,1)
test_any(if(object_program(this_object())) return 1; else return 0,1)

// break
test_any(while(1) break; return 1,1)
test_any(while(1) if(1) break; return 1,1)

// for
test_program(
array(int) ia=({1,2,3,4,5,6});

int a()
{
  int i;
  for (i=0; i<sizeof(ia); i++)
    {
      if (ia[i]==3)
	{
	  ia=ia[..i-1]+ia[i+1..];
	  --i;
	}
    }
  return 1;
}
)
test_any(int e; for(e=0;e<10;e++) break; return e,0)
test_any(int e; for(e=0;e<10;e++) continue; return e,10)
test_any(int e;string t=""; for(e=0;e<10;e++) t+=e; return t,"0123456789")
test_any(int e;string t=""; for(e=0;e<=10;e++) t+=e; return t,"012345678910")
test_any(int e;string t=""; for(e=9;e>0;e--) t+=e; return t,"987654321")
test_any(int e;string t=""; for(e=9;e>=0;e--) t+=e; return t,"9876543210")
test_any(int e;string t=""; for(e=9;e!=0;e--) t+=e;  return t,"987654321")
test_any(int e;string t=""; for(e=2;e!=10;e++) t+=e; return t,"23456789")
test_any(int e;string t=""; for(e=0;e>-10;e--) t+=e; return t,"0-1-2-3-4-5-6-7-8-9")

// foreach
test_any([[int e;string t=""; foreach(({7,6,3,8}),e) t+=e; return t]],"7638")
test_any([[
  /* FIXME: This test needs to be proofed against the optimizer. */
  string s;if(1) foreach(({}),s); else foreach(({}),s); return 1
]],1)

test_any([[
  int ret;
  foreach( ([1:2,3:5,7:11,13:17]) ; int a ; int b) ret+=a*b;
  return ret;
]],315)

test_any([[
  int ret;
  foreach( ([1:2,3:5,7:11,13:17]) ; ; int b) ret+=b;
  return ret;
]],35)

test_any([[
  int ret;
  foreach( ([1:2,3:5,7:11,13:17]) ; int a; ) ret+=a;
  return ret;
]],24)

test_any([[
  int ret;
  foreach( (<1,3,7,13>) ; ; int b) ret+=b;
  return ret;
]],4)

test_any([[
  int ret;
  foreach( (<1,3,7,13>) ; int a; ) ret+=a;
  return ret;
]],24)


test_any([[
  int ret;
  foreach( (<1,3,7,13>) ; int a; int b) ret+=a+b;
  return ret;
]],24+4)

test_any([[
  int ret;
  foreach( ({2,5,11,17}) ; int a; ) ret+=a;
  return ret;
]],6)

test_any([[
  int ret;
  foreach( ({2,5,11,17}) ; ; int b) ret+=b;
  return ret;
]],35)

test_any([[
  int ret;
  foreach( ({2,5,11,17}) ; int a; int b) ret+=a*b;
  return ret;
]],78)

test_any([[
  int ret;
  foreach( "foobar" ; int a; int b) ret+=a*b;
  return ret;
]],1585)

test_any([[
  int ret;
  foreach( "foobar" ; int a;) ret+=a;
  return ret;
]],15)

test_any([[
  int ret;
  foreach( "foobar" ; ; int b) ret+=b;
  return ret;
]],633)

test_any([[
  mapping m=([1:2,3:5,7:11,13:17]);
  foreach(m  ; int a ; int b) m_delete(m,a);
  return sizeof(m);
]],0)


test_any([[
  mapping m=([1:2,3:5,7:11,13:17]);
  int ret;
  foreach(m  ; int a ; int b) { m_delete(m,a); ret+=a*b; }
  return ret;
]],315)

// String.SplitIterator
test_any([[
  object it = String.SplitIterator("  foobar gazonk  gurka baz  ", ' ');
  array res = ({});
  foreach(it; int i; string part) {
    res += ({ part });
  }
  return equal(res, "  foobar gazonk  gurka baz  "/" ");
]], 1)
test_any([[
  object it = String.SplitIterator("  foobar gazonk  gurka baz  ", ' ');
  return sizeof(it);
]], [[
  sizeof("  foobar gazonk  gurka baz  "/" ");
]])
test_any([[
  object it = String.SplitIterator("foobar gazonk  gurka baz", ' ');
  array res = ({});
  foreach(it; int i; string part) {
    res += ({ part });
  }
  return equal(res, "foobar gazonk  gurka baz"/" ");
]], 1)
test_any([[
  object it = String.SplitIterator("foobar gazonk  gurka baz", ' ');
  return sizeof(it);
]], [[
  sizeof("foobar gazonk  gurka baz"/" ");
]])
test_any([[
  object it = String.SplitIterator("  foobar gazonk  gurka baz  ", ' ', 1);
  array res = ({});
  foreach(it; int i; string part) {
    res += ({ part });
  }
  return equal(res, "foobar gazonk gurka baz"/" ");
]], 1)
test_any([[
  object it = String.SplitIterator("  foobar gazonk  gurka baz  ", ' ', 1);
  return sizeof(it);
]], [[
  sizeof("foobar gazonk gurka baz"/" ");
]])
test_any([[
  object it = String.SplitIterator("foobar gazonk  gurka baz", ' ', 1);
  array res = ({});
  foreach(it; int i; string part) {
    res += ({ part });
  }
  return equal(res, "foobar gazonk gurka baz"/" ");
]], 1)
test_any([[
  object it = String.SplitIterator("foobar gazonk  gurka baz", ' ', 1);
  return sizeof(it);
]], [[
  sizeof("foobar gazonk gurka baz"/" ");
]])



// do-while
test_any(int e;string t=""; e=0; do{ t+=e; }while(++e<6); return t,"012345";)

// while
test_any(int e;string t=""; e=8; while(--e) t+=e; return t,"7654321";)
test_any(int e;string t=""; e=8; while(e--) t+=e; return t,"76543210";)
test_any(int e;string t=""; e=0; while(++e<6) t+=e; return t,"12345";)
test_any(int e=1;string t=""; while(e<20){t+=e;e*=2;} return t,"124816";)

// Switch
test_any(switch((mixed)"") { case -1: case "gazonk": return 0; } return 1,1)
test_any(switch((mixed)"") { case -2: case "gazonk": return 0; } return 1,1)
test_any(switch((mixed)"") { case 0: case "gazonk": return 0; } return 1,1)
test_any(switch((mixed)"") { case "gazonk": case 0: return 0; } return 1,1)
test_any(switch((mixed)0) { case 0: case "gazonk": return 0; } return 1,0)
test_any(switch((mixed)"gazonk") { case "gazonk": case 0: return 0; } return 1,0)
test_any(switch((mixed)0) { case "": } return 1,1)
test_any(switch((mixed)1) { case 1: return 1; default: } return 0,1)
test_any(switch((mixed)2) { case 1: return 0; default: return 1;} return 0,1)
test_any(switch((mixed)1) { default: return 0; case 1: return 1; } return 0,1)
test_any(switch((mixed)2) { default: return 1; case 1: return 0; } return 0,1)
test_any(switch((mixed)0) { case "apa": case 1.0: return 0; }  return 1,1)
test_any(switch((mixed)"apa") { case "apa": return 1; case 1.0: }  return 0,1)
test_any(switch((mixed)1.0) { case "apa": return 0; case 1.0: return 1; } return 0,1)
test_any(switch((mixed)"sune") { case "gunnel": return 0; case "gunnar": return 1; case "sune": case "gusten": return 0; } return 0,0)
test_any(switch((mixed)"a") { case "a": return 1; case "b": case "c": case "d": case 'a': case '1': case '0': default: } return 0,1)
test_any(switch((mixed)"b") { case "a": return 0; case "b": return 1; case "c": case "d": case 'a': case '1': case '0': default: } return 0,1)
test_any(switch((mixed)"c") { case "a": case "b": return 0; case "c": return 1; case "d": case 'a': case '1': case '0': default: } return 0,1)
test_any(switch((mixed)"d") { case "a": case "b": case "c": return 0; case "d": return 1; case 'a': case '1': case '0': default: } return 0,1)
test_any(switch((mixed)'a') { case "a": case "b": case "c": case "d": return 0; case 'a': return 1; case '1': case '0': default: } return 0,1)
test_any(switch((mixed)'1') { case "a": case "b": case "c": case "d": case 'a': return 0; case '1': return 1; case '0': default: } return 0,1)
test_any(switch((mixed)'0') { case "a": case "b": case "c": case "d": case 'a': case '1': return 0; case '0': return 1; default: } return 0,1)
test_any(switch((mixed)"a") { case "a": return 1; case "b": return 2; case "c": return 3; case "d": return 4; case 'a': return 5; case '1': return 6; case '0': return 7; default: return 8; } return 9,1)
test_any(switch((mixed)"b") { case "a": return 1; case "b": return 2; case "c": return 3; case "d": return 4; case 'a': return 5; case '1': return 6; case '0': return 7; default: return 8; } return 9,2)
test_any(switch((mixed)"c") { case "a": return 1; case "b": return 2; case "c": return 3; case "d": return 4; case 'a': return 5; case '1': return 6; case '0': return 7; default: return 8; } return 9,3)
test_any(switch((mixed)"d") { case "a": return 1; case "b": return 2; case "c": return 3; case "d": return 4; case 'a': return 5; case '1': return 6; case '0': return 7; default: return 8; } return 9,4)
test_any(switch((mixed)'a') { case "a": return 1; case "b": return 2; case "c": return 3; case "d": return 4; case 'a': return 5; case '1': return 6; case '0': return 7; default: return 8; } return 9,5)
test_any(switch((mixed)'1') { case "a": return 1; case "b": return 2; case "c": return 3; case "d": return 4; case 'a': return 5; case '1': return 6; case '0': return 7; default: return 8; } return 9,6)
test_any(switch((mixed)'0') { case "a": return 1; case "b": return 2; case "c": return 3; case "d": return 4; case 'a': return 5; case '1': return 6; case '0': return 7; default: return 8; } return 9,7)
test_any(switch((mixed)'9') { case "a": return 1; case "b": return 2; case "c": return 3; case "d": return 4; case 'a': return 5; case '1': return 6; case '0': return 7; default: return 8; } return 9,8)

test_program([[
void bar() {}
int a()
{
  foreach( ({1}), int n)
  {
    switch(n)
    {
      default:
      bar();
      break;
    }
  }
  return 1;
}
]])


define(test_switch0,[[
test_any(switch((mixed)$1) { $2; $3; $4; $5; } return 0,$6)
test_any(switch((mixed)$1) { default: return 0; $2; $3; $4; $5; } return -1,$6)
test_any(switch((mixed)$1) { $2; default: return 0; $3; $4; $5; } return -1,$6)
test_any(switch((mixed)$1) { $2; $3; default: return 0; $4; $5; } return -1,$6)
test_any(switch((mixed)$1) { $2; $3; $4; default: return 0; $5; } return -1,$6)
test_any(switch((mixed)$1) { $2; $3; $4; $5; default: return 0; } return -1,$6)
]])

define(test_switch1,[[
test_switch0($1, $2,$3,$4,$5, $6)
test_switch0($1, $2,$3,$5,$4, $6)
]])

define(test_switch2,[[
test_switch1($1, $2,$3,$4,$5, $6)
test_switch1($1, $2,$4,$3,$5, $6)
test_switch1($1, $2,$5,$4,$3, $6)
]])

define(test_switch3,[[
test_switch2($1,case $2:return 2,case $3:return 3,case $4:return 4,case $5:return 5,$6)
test_switch2($1,case $3:return 3,case $2:return 2,case $4:return 4,case $5:return 5,$6)
test_switch2($1,case $4:return 4,case $3:return 3,case $2:return 2,case $5:return 5,$6)
test_switch2($1,case $5:return 5,case $3:return 3,case $4:return 4,case $2:return 2,$6)
]])

define(test_switch4,[[
test_switch3($1,$2,$3,$4,$5,0)
test_switch3($2,$2,$3,$4,$5,2)
test_switch3($3,$2,$3,$4,$5,3)
test_switch3($4,$2,$3,$4,$5,4)
test_switch3($5,$2,$3,$4,$5,5)
]])

test_switch4(17,18,19,20,21)
test_switch4("a","b","c","d","e")
test_switch4("a",0,"c","d","e")
test_switch4(1.0,2.0,3.0,4.0,5.0)
test_switch4(this_object(),"",0,4.0,1)

test_any(int e;string t=""; for(e=0;e<10;e++) switch(e) { default: t+=e; case 4..8: } return t,"01239")

// use sprintf here; the sums aren't totally equal for doubles (error~=1e-16)
test_any([[float e,q; q=0.0; for(e=0.1;e<10.0;e+=1.0) switch(e) { default: q+=e; case 4.0..8.0: } return sprintf("%.6f",q)]],[[sprintf("%.6f",0.1+1.1+2.1+3.1+8.1+9.1)]])

// Breaks and continues with labels
test_compile_error([[break;]])
test_compile_error([[continue;]])
test_compile_error([[foo: break;]])
test_compile_error([[foo: continue;]])
test_compile_error([[break foo;]])
test_compile_error([[continue foo;]])
test_any([[foo: break foo; return 1;]], 1)
test_compile_error([[foo: continue foo;]])
test_compile_error([[int a; foo: if (a++) a++; else foo: a++;]])
test_compile_error([[int a; foo: foo: if (a++) a++; else a++;]])
test_compile([[int a; foo: if (a++) a++; foo: a++;]])
test_compile_error([[int a; do if (a++) break foo; while (0);]])
test_compile([[int a; do foo: if (a++) break foo; while (0);]])
test_compile([[int a; foo: do if (a++) break foo; while (0);]])
test_compile_error([[int a; do foo: if (a++) continue foo; while (0);]])
test_compile([[int a; foo: do if (a++) continue foo; while (0);]])
test_any([[
  int i;
  for (i = 1; i <= 4; i++)
    foo: break;
  return i;
]], 1);
test_any([[
  int i;
  for (int j = 1; j <= 4; j++) {
    foo: continue;
    i = j;
  }
  return i;
]], 0);
test_any([[
  int i;
  for (i = 1; i <= 4; i++)
    foo: {
      if (i > 5) break foo;
      break;
    }
  return i;
]], 1);
test_any_equal([[
  int a, b;
foo:
  for (int i = 1; i <= 4; i++) {
    a = i;
    switch (1) {
      case 1:
	if (i >= 3) break foo;
	if (i >= 2) continue foo;
    }
    b = i;
  }
  return ({a, b});
]], ({3, 1}));
test_any_equal([[
  int a, b;
foo: {
    for (int i = 1; i <= 4; i++) {
      a = i;
      switch (1) {
	case 1:
	  if (i >= 3) break foo;
      }
      b = i;
    }
  }
  return ({a, b});
]], ({3, 2}));
test_any_equal([[
  array res = ({});
  foreach (({1, 2, 3}), int x) {
    res += ({-x});
  foo:
    foreach (({1, 2, 3, 4}), int i) {
      res += ({i});
      foreach (({1, 2}), int y) {
	if (i >= 3) break foo;
	if (i >= 2) continue foo;
      }
      res += ({i});
    }
  }
  return res;
]], ({-1, 1, 1, 2, 3, -2, 1, 1, 2, 3, -3, 1, 1, 2, 3}));
test_any_equal([[
  int a, b;
foo:
  for (int i = 1; i <= 4; i++) {
    a = i;
    catch {
      catch {
	if (i >= 3) break foo;
	if (i >= 2) continue foo;
      };
    };
    b = i;
  }
  return ({a, b});
]], ({3, 1}));
test_any_equal([[
  int a, b;
foo:
  for (int i = 1; i <= 4; i++) {
    a = i;
    catch {
      catch {
	if (i >= 3) break;
	if (i >= 2) continue;
      };
    };
    b += i;
  }
  return ({a, b});
]], ({4, 8}));
test_any([[
foo:
  if (stringp (catch {break foo;}) + 1) return 1;
  else return 2;
  return 3;
]], 3);
test_any([[
foo:
  do {
    if ((3*time() + 5) + stringp (catch {break foo;})) return 1;
    else return 2;
  } while (0);
  return 3;
]], 3);
test_do([[
  void gnu (mixed... args) {};
foo:
  gnu (1,2,3, gauge {break foo;},4,5);
]]);
test_do([[
  void gnu (mixed... args) {};
foo:
  gnu (@indices (all_constants()), gauge {break foo;});
]]);
test_do([[
  void gnu (mixed... args) {};
foo:
  gnu (1,2,3, catch {break foo;},4,5);
]]);
test_do([[
  void gnu (mixed... args) {};
foo:
  gnu (@indices (all_constants()), catch {break foo;});
]]);
test_do([[
  void gnu (mixed... args) {};
foo:
  gnu (@({1,2,3,4,5}), catch {break foo;});
]]);
test_do([[
  void gnu (mixed... args) {};
foo:
  gnu (@indices (all_constants()), @allocate (511, 1), catch {break foo;});
]]);
test_do([[
  void gnu (mixed... args) {};
foo:
  gnu (@allocate (511, 1), @indices (all_constants()), catch {break foo;});
]]);
test_compile_error([[
foo: {
    @indices (all_constants());
    break foo;
  }
]]);
test_do([[
  // Note: This is valid <= 7.0 code.
  foreach (({1,2,3}), int j)
    do
      if (17 + j + gauge {break;}) return 0;
    while (0);
]]);
test_do([[
  int gnu (mixed... args) {};
  gnu(@indices (all_constants()), gauge {
    foreach (({1,2,3}), int j)
      do
        if (gnu(@indices (all_constants()),
		17 + gauge {break;}))
	  return 0;
      while (0);
  });
]]);
test_do([[
  int gnu (mixed... args) {};
foo:
  gnu(@indices (all_constants()), gauge {
    foreach (({1,2,3}), int j)
      do
        if (gnu(@indices (all_constants()),
		17 + gauge {break foo;}))
	  return 0;
      while (0);
  });
]]);

cond([[all_constants()->_verify_internals]],
[[
  test_do(_verify_internals())
]])

// testing preprocessor
test_eq([[cpp("#define FOO(X,Y) (X) (Y)\nFOO( (A),(B) )")]],"# 1 \"-\"\n\n( (A) ) ( (B) )")
test_eq([[cpp("#define F 'F'\nF")]],"# 1 \"-\"\n\n'F'")
test_eq([[cpp("#define MAX(X,Y) ((X)>(Y)?(X):(Y))\n#define MAX3(X,Y,Z) MAX(MAX(X,Y),Z)\nMAX3(1,2,3)")]],"# 1 \"-\"\n\n\n(( (( 1 )>( 2 )?( 1 ):( 2 )) )>( 3 )?( (( 1 )>( 2 )?( 1 ):( 2 )) ):( 3 ))")
test_eq([[cpp("foo\xfeff""bar \xfeff gazonk")]],[[cpp("foobar  gazonk")]])

test_eq([[compile_string(#"
#define Y(y) #y
#define X(x) x(z)
string a() {return X(Y);}
")()->a()]], "z")
test_eq([[compile_string(#"
#define Y() \"z\"
#define X(x) x()
string a() {return X(Y);}
")()->a()]], "z")
test_compile_error([[
#define Y(y) y
#define X(x) x()
X(Y)
]])
test_compile_error([[
#define Y() y
#define X(x) x(z)
X(Y)
]])
test_true([[compile_string(#"
#define Y() z
#define X(x) x()
int z() {return 0;}
mixed a() {return functionp(X(Y));}
")()->a()]])
test_false([[compile_string(#"
#define Y z
#define X(x) x()
int z() {return 0;}
mixed a() {return functionp(X(Y));}
")()->a()]])

test_any(int e; object o=clone(Stdio.File); if(!o->open("conftest.h","wct")) return -1; e=o->write("return 17;\n"); if(!o->close()) return -1; return e,11)

test_compile_any([[import Stdio.Readline; mapping x=([]);]]);

test_any([[
#include "conftest.h"
]],17)
dnltest_any([[
dnl#include <conftest.h>
dnl]],17)
test_true(intp(__LINE__))
test_true(stringp(__FILE__))
test_true(stringp(__DATE__))
test_true([[ sscanf(__DATE__, "%3s %d %d", string m, int d, int y) == 3 &&
	     search(({"Jan", "Feb", "Mar", "Apr", "May", "Jun",
		      "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}), m) != -1 &&
	     intp(d) && d>0 && d<32 && intp(y) ]])
test_true(stringp(__TIME__))
test_true([[ sscanf(__TIME__, "%d:%d:%d", int h, int m, int s) == 3 &&
	     intp(h) && intp(m) && intp(s) &&
	     h>=0 && m>=0 && s>=0 &&
	     h<24 && m<60 && s<61 ]])
test_true(floatp(__VERSION__))
test_true(intp(__MAJOR__))
test_true(intp(__MINOR__))
test_true(intp(__BUILD__))

// #define
test_any([[
#define FOOa 1
return FOOa;
]],1)

test_any([[
#define FOOa array
FOOa(int) b;
return 1;
]],1)

test_any([[
#define FOOb 17
#undef FOOb
#define FOOb 1
return FOOb;
]],1)

test_compile_error([[
#define FOOc FOOc FOO
FOO
]])

test_compile_error([[
#error FOOd
FOO
]])

test_any([[
#define FOOa(X) (X)
return FOOa(2);
]],2)

test_any([[
#define FOOa(X) \
(X)
return FOOa(2);
]],2)

test_any([[
#define FOOa(X) \
(X)
return FOOa(3);
]],3)

test_any_equal([[
#define FOOa(X,Y...) ({X,Y})
return FOOa(3);
]],({3}))

test_any_equal([[
#define FOOa(X,Y...) ({X,Y})
return FOOa(3,4);
]],({3,4}))

test_any_equal([[
#define FOOa(X,Y...) ({X,Y})
return FOOa(3,4,5);
]],({3,4,5}))

test_any_equal([[
#define FOOa(X,Y...) ({X,Y})
return FOOa(3,4,5,6);
]],({3,4,5,6}))

test_any([[
#define FOOa(X) "bar\
gazonk"
return FOOa(3);
]],"bargazonk")

test_any([[
#define FOOa(X) "bar\
gazonk"
return FOOa(3);
]],"bargazonk")


// /* */
test_any([[
/* return 99; * /  /* */
return 1;
]],1)

// //
test_any([[
// return 99;
return 1;
]],1)

// #if
define(test_if_true,[[test_any([[
#if $1
return 1;
#else
return 0;
#endif
]],1)]])
define(test_if_false,[[test_any([[
#if $1
return 1;
#else
return 0;
#endif
]],0)]])

test_if_true(1)
test_if_false(0)

// #if ==
test_if_true(1==1)
test_if_false(1==2)

// #if !=
test_if_true(1!=2)
test_if_false(1!=1)

// #if ( )
test_if_true( (((1))==1) )
test_if_false( ((1)==(2)) )

// #if -1
test_if_true( -1 )
test_if_true( (-1) )
test_if_true( (-1==0-1) )

// #if ~
test_if_true( (-1-1==~1) )

// #if ?:
test_if_true( 17 == ( 1 ? 17 : 18 ) )
test_if_true( 18 == ( 0 ? 17 : 18 ) )

// #if ||
test_if_true( 10 == ( 10 || 20 ) )
test_if_true( 20 == ( 0 || 20 ) )

// #if &&
test_if_true( 0 == ( 0 && 20 ) )
test_if_true( 20 == ( 10 && 20 ) )

// #if |
test_if_true( 3 == ( 1 | 2 ) )
test_if_true( 2 == ( 2 | 2 ) )

// #if ^
test_if_true( 0 == ( 2 ^ 2 ) )
test_if_true( 3 == ( 1 ^ 2 ) )

// #if &
test_if_true( 0 == ( 1 & 2 ) )
test_if_true( 2 == ( 2 & 7 ) )

// #if <= >= < > ! strings, floats

define(test_if_cmp,[[
test_if_true($1<$2)
test_if_true(!($1>$2))
test_if_true($2>$1)
test_if_true(!($2<$1))
test_if_true($1<=$2)
test_if_true(!($1>=$2))
test_if_true($2>=$1)
test_if_true(!($2<=$1))
test_if_true($2<=$2)
test_if_true($1>=$1) ]])

test_if_cmp(1,2)
test_if_cmp(1.0,2.0)
test_if_cmp("a","b")

// #if <<
test_if_true(1<<10==1024)
test_if_true(5<<3==40)

// #if >>
test_if_true(1024>>10==1)
test_if_true(47>>3==5)

// #if +
test_if_true(1024+10==1034)
test_if_true(47+3==50)

// #if -
test_if_true(1024-10==1014)
test_if_true(47-3==44)

// #if *
test_if_true(1024*10==10240)

// #if /
test_if_true(47/3==15)

test_compile_error([[
#if 1/0
return 1;
#else
return 0;
#endif
]])

// #if %
test_if_true(47%3==2)
test_compile_error([[
#if 1%0
return 1;
#else
return 0;
#endif
]])

// #if [ ]
test_if_true("foo"[0]=='f')

// #if defined
test_any([[
#define FOOe 0
#if defined(FOOe)
return 1;
#else
return 0;
#endif
]],1)

// #if define < x
test_any([[
#define FOOf 1
#if FOOf < 2
return 1;
#else
return 0;
#endif
]],1)

// #if define < x
test_any([[
#define FOOg 1
#if FOOg < 0
return 0;
#else
return 1;
#endif
]],1)

// #if x < define
test_any([[
#define FOOh 1
#if 0 < FOOh
return 1;
#else
return 0;
#endif
]],1)

// #if x < define
test_any([[
#define FOOi 1
#if 2 < FOOi
return 0;
#else
return 1;
#endif
]],1)

// #if efun
// see test for add_constant()

// #if /* */
test_any([[
#if 1 /* trying to be mean //  * / */ /* /* */
return 1;  /* */
#define foo
# 1 "---"
#undef foo
#else /* trying to be mean //  * / */ /* /* */
return 0;  //
#endif /* trying to be mean //  * / */ /* /* */
]],1)

test_any([[
#if 0 /* trying to be mean //  * / */ /* /* */
return 0; /* */
#define foo
# 1 "---"
#undef foo
#else /* trying to be mean //  * / */ /* /* */
return 1; //
#endif /* trying to be mean //  * / */ /* /* */
]],1)

// #if //
test_any([[
#if 1 //* trying to be mean //  */ */
return 1;
#else //* trying to be mean //  */ */
return 0;
#endif //* trying to be mean //  */ */
]],1)

test_any([[
#if 0 //* trying to be mean //  */ */
return 0;
#else //* trying to be mean //  */ */
return 1;
#endif //* trying to be mean // */ */
]],1)

test_any([[
#define FOOj
#if defined(FOOj)
return 1;
#else
return 0;
#endif
]],1)

test_any([[
#if defined(FOOk)
return 0;
#else
return 1;
#endif
]],1)

// #ifdef
test_any([[
#ifdef FOOl
return 0;
#else
return 1;
#endif
]],1)

test_any([[
#define FOOm
#ifdef FOOm
return 1;
#else
return 0;
#endif
]],1)

// #ifndef
test_any([[
#define FOOo
#ifndef FOOo
return 0;
#else
return 1;
#endif
]],1)

test_any([[
#ifndef FOOp
return 1;
#else
return 0;
#endif
]],1)

// #else
test_any([[
#if 1
return 1;
#else
FEL
#if 0
FEL
#else
FEL
#endif
return 0;
#endif
]],1)

test_any([[
#if 0
FEL
#if 0
FEL
#else
FEL
#if 1
FEL
#else
FEL
#endif
#endif
return 0;
#else
return 1;
#endif
]],1)

// #elif
test_any([[
#if 0
return 0;
#elif 0
return 0;
#else
return 1;
#endif
]],1)

test_any([[
#if 0
return 0;
#elif 1
return 1;
#else
return 0;
#endif
]],1)

test_any([[
#if 1
return 1;
#elif 1
return 0;
#else
return 0;
#endif
]],1)

// #elseif
test_any([[
#if 0
return 0;
#elseif 0
return 0;
#else
return 1;
#endif
]],1)

test_any([[
#if 0
return 0;
#elseif 0
return 0;
#elseif 1
return 1;
#elseif 0
return 0;
#elseif 0
return 0;
#else
FEL
#endif
]],1)

test_any([[
#if 0
return 0;
#elseif 1
return 1;
#else
return 0;
#endif
]],1)

test_any([[
#if 1
return 1;
#elseif 1
return 0;
#else
return 0;
#endif
]],1)

// #pragma
// FIXME: add tests for real pragmas
test_any([[
#pragma whatever
return 1;
]],1)

// #include
// FIXME add test for #include
test_compile_any([[
#pike 7.0
#include <simulate.h>
]])

// #error
test_compile_error([[
#error Gurgel
]])

define(do_test_cpp_string,[[
test_eq([[ (({""}) + (string)indices("."*256)/"" + ({""})) * $1]],
	[[ Stdio.write_file("testsuite.tmp",a()),compile_string("string s=#string \"testsuite.tmp\";")()->s ]])
]])

do_test_cpp_string([["0"]])
do_test_cpp_string([["1"]])
do_test_cpp_string([["2"]])
do_test_cpp_string([["3"]])
do_test_cpp_string([["4"]])
do_test_cpp_string([["5"]])
do_test_cpp_string([["6"]])
do_test_cpp_string([["7"]])
do_test_cpp_string([["8"]])
do_test_cpp_string([["9"]])
do_test_cpp_string([["a"]])
do_test_cpp_string([["A"]])
do_test_cpp_string([["\\"]])
do_test_cpp_string([["\\\\"]])
do_test_cpp_string([["\\\\\\"]])
do_test_cpp_string([["\""]])

// #undef inside an evaluation of the macro.
test_compile_error([[
#define LOCALE(X,Y) (Y)
#define DEFVAR(X, Y) ret[(X)]=my_defvar((X),(Y),vars)

  DEFVAR("cm_wa",
         Sitebuilder.SBConnect()->
         ChooseWorkareaVariable(LOCALE(0, "Work area") + LOCALE(0, "Work area"),
                                LOCALE(0, "the"));

  DEFVAR("cr_startpage",
         Variable.URLList(LOCALE(0, "Crawling behaviour") + LOCALE(0, "Start pages"), ""));

#undef DEFVAR

constant cif_defines = #"
   <input align='&_.img-align;' type='image' name='&_.name;' value='&_.contents;' src='&var.url;' border='0' />
</define>";
]])

// foop
define(do_test_foop,[[
test_eq($1 (17), !($2))
test_eq($1 (1.7), !($2-1))
test_eq($1 ("17"), !($2-2))
test_eq($1 (this_object()), !($2-3))
test_eq($1 (a), !($2-4)) // a is the test function
test_eq($1 (({})), !($2-5))
test_eq($1 (([])), !($2-6))
test_eq($1 ((<>)), !($2-7))
test_eq($1 (object_program(this_object())), !($2-8))
]])

do_test_foop(intp,0)
do_test_foop(floatp,1)
do_test_foop(stringp,2)
do_test_foop(objectp,3)
do_test_foop(functionp,4)
do_test_foop(arrayp,5)
do_test_foop(mappingp,6)
do_test_foop(multisetp,7)
do_test_foop(programp,8)

// add_constant
test_do(add_constant("foobar",lambda() { return 1; }))
test_any([[
#if efun(foobar)
return 1;
#else
return 0;
#endif
]],1)
test_eq(foobar(),1)
test_do(add_constant("foobar"))
test_any([[
#if efun(foobar)
return 1;
#else
return 0;
#endif
]],0)

// - aggregate
test_true(arrayp(aggregate()))
test_eq(sizeof(aggregate()),0)
test_equal(aggregate(1,2,3,4),({1,2,3,4}))

// - aggregate_multiset
test_true(multisetp(aggregate_multiset()))

// - aggregate_mapping
test_true(multisetp(aggregate_multiset()))

// - all_constants
test_true(mappingp(all_constants()))
test_true(all_constants()["all_constants"])
test_eq(all_constants()["all_constants"],all_constants)

// - allocate
test_true(arrayp(allocate(0)))
test_equal(allocate(2),({0,0}))
test_false(allocate(2)==({0,0}))
test_true(allocate(65536,random))

// - backtrace
test_true(arrayp(backtrace()))
test_eq(backtrace()[-1][2],a)

// - call_function
test_eq(1,call_function(a))
test_eq(1,call_function(lambda(int a){ return a; },1))
test_eq(1,call_function(intp,1))

// - String.capitalize
test_eq(String.capitalize("fubar"),"Fubar")
test_eq(String.capitalize("FooBar"),"FooBar")
test_eq(String.capitalize("-"),"-")

// - String.common_prefix
test_eq(String.common_prefix(({ "soliloquise" })), "soliloquise")
test_eq(String.common_prefix(({ "muzzle", "muzzy" })), "muzz")
test_eq(String.common_prefix(({ "labyrinth", "diatom" })), "")
test_eq(String.common_prefix(({ "abc", "abc", "abc" })), "abc")
test_eq(String.common_prefix(({})), "")

// - clone
// clone is already tested a lot by this script
test_true(objectp(clone(compile_string("int foo() { return 17; }"))))
test_eq(clone(compile_string("int foo() { return 17; }"))->foo(),17)

// - combine_path
test_eq([[combine_path("/foo/bar/gazonk/","..")]],"/foo/bar")
test_eq([[combine_path("/foo/bar/gazonk","..")]],"/foo/bar")
test_eq([[combine_path("/foo/bar/", "gazonk")]],"/foo/bar/gazonk")
test_eq([[combine_path("/foo/bar", "gazonk")]],"/foo/bar/gazonk")
test_eq([[combine_path("/.../","sune")]],"/.../sune")
test_eq([[combine_path("/",".")]],"/")
test_eq([[combine_path("/","foo/.../sune")]],"/foo/.../sune")
test_eq([[combine_path("/./foo/bar//gazonk/","../")]],"/foo/bar/")
test_eq([[combine_path("/","/foo/./bar/gazonk/..")]],"/foo/bar")
test_eq([[combine_path("/","/foo/bar/gazonk/../../")]],"/foo/")
test_eq([[combine_path("/","/foo//bar/gazonk/../..")]],"/foo")
test_eq([[combine_path("/","/foo/bar/./gazonk/../../..")]],"/")
test_eq([[combine_path("/","/foo/../bar//./gazonk/../..")]],"/")
test_eq([[combine_path("/","/foo/././/bar/gazonk/../../../..")]],"/")
test_eq([[combine_path("/","..")]],"/")
test_eq([[combine_path("./","..")]],"..")
test_eq([[combine_path("./.","..")]],"..")
test_eq([[combine_path("/","../../foo")]],"/foo")
test_eq([[combine_path("./foobar/.","..")]],".")
test_eq([[combine_path("/","foo","bar","gazonk")]],"/foo/bar/gazonk")
test_eq([[combine_path("/", "foo", "")]], "/foo/")

test_eq([[combine_path("/","/foo/bar/ga\11111zonk/../../")]],"/foo/")
test_eq([[combine_path("/","/fo\1111/bar/ga\11111zonk/../../")]],"/fo\1111/")
test_eq([[combine_path("/","/fo\1111/bar/gazonk/../../")]],"/fo\1111/")
test_eq([[combine_path_nt("/","/fo\1111/bar/gazonk/../../")]],"/fo\1111/")
test_eq([[combine_path_unix("/","/fo\1111/bar/gazonk/../../")]],"/fo\1111/")
test_eq([[combine_path_nt("a:/","/fo\1111/bar/gazonk/../../")]],"a:/fo\1111/")
test_eq([[combine_path_nt("a:/", "/foo","bar")+combine_path_nt("/foo","bar")]],
	  "a:/foo/bar/foo/bar")

// - Stdio.append_path
test_eq([[ Stdio.append_path("../foo/", "../bar") ]], "../foo/bar")
test_eq([[ Stdio.append_path("../foo/", "../bar", "../baz") ]], "../foo/bar/baz")
test_eq([[ Stdio.append_path("../foo/", "../bar", "../baz", "../fie/../faz") ]], "../foo/bar/baz/faz")

// - compile_file
// FIXME: add tests for compile_file

// - compile_string
// see test for clone()

cond([[all_constants()->thread_create]],
[[
  test_any([[
    string file = #"
/*
 * Attempt to trigg the lex.current_file == NULL bug.
 *
 * Henrik Grubbström 1999-07-01
 */

string file = Stdio.File(__FILE__, \"r\")->read();

void thread_func()
{
  int i;

  for (i=0; i < 1000; i++) {
    compile_string(file);
  }
}

int main(int argc, array(string) argv)
{
  array(object) a = allocate(10, thread_create)(thread_func);

  a->wait();

  return 0;
}

";
  allocate(10, thread_create)(lambda() {
    int i;
    for(i = 0; i < 1000; i++) {
      compile_string(file);
    }
  } )->wait();

  return 0;
  ]], 0)
]])

// - copy_value
test_eq(copy_value(1),1)
test_eq(copy_value(""),"")
test_eq(copy_value(1.0),1.0)
test_eq(copy_value(this_object()),this_object())
test_eq(copy_value(a),a)
define(do_test_copy_value,[[
test_any([[mixed x=$1; return x==x]],1)
test_any([[mixed x=$1; return copy_value(x)!=x]],1)
test_any([[mixed x=$1; return equal(copy_value(x),x)]],1)]])
do_test_copy_value( ({1}) )
do_test_copy_value( ([]) )
do_test_copy_value( (<>) )
do_test_copy_value( (< ([]), ({1}) ,"" , 1.0 >) )
test_true(get_weak_flag(copy_value(set_weak_flag(({17}), 1))))
test_true(get_weak_flag(copy_value(set_weak_flag((<17>), 1))))
test_true(get_weak_flag(copy_value(set_weak_flag(([17:17]), 1))))
test_true(get_weak_flag(copy_value(set_weak_flag(([17:({17})]), 1))))

// - crypt
test_true(stringp(crypt("hej")))
test_true(crypt("hej",crypt("hej")))
test_false(crypt("hej","hej"))
test_false(crypt("h","hej"))

// - ctime
test_true(stringp(ctime(0)))

// - destruct
// FIXME put tests for destruct here.
test_do(add_constant("PROG",compile_string("int foo() { return 1; }")));
test_any([[object o=clone(PROG); destruct(o); return o]],0);
test_any([[object o=clone(PROG); destruct(o); return objectp(o)]],0);
test_any([[array(object) o=({clone(PROG)}); destruct(o[0]); return o-({0}) ]],({}));
test_any([[mapping o=(["foo":clone(PROG)]); destruct(o["foo"]); return o["foo"]; ]],0);
dnl test_any([[object t; mapping o=([t=clone(PROG):"foo"]); destruct(t); return sizeof(o)]],0);
test_do([[object t; array(object) o=({}); o+=({t=clone(PROG)}); destruct(t); o=({});]]);

// - Array.diff
test_equal(Array.diff(({ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }),
                      ({ 6, 7, 8, 9, 3, 4, 5, 1, 2, 0 })),
           ({ ({ ({ 0, 1, 2, 3, 4, 5 }),
                 ({ 6, 7, 8, 9 }), ({}) }),
              ({ ({}), ({ 6, 7, 8, 9 }),
                 ({ 3, 4, 5, 1, 2, 0 }) }) }))
test_equal(Array.diff(({ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }),
                      ({ 9, 7, 8, 4, 5, 6, 0, 1, 2, 3 })),
           ({ ({ ({}), ({ 0, 1, 2, 3 }),
                 ({ 4, 5, 6, 7, 8, 9 }) }),
              ({ ({ 9, 7, 8, 4, 5, 6 }),
                 ({ 0, 1, 2, 3 }), ({}) }) }))
test_equal(Array.diff("qadfgoksdfäojerjgöohjgdgkm"/"",
                      "xadfgokälojeorjgöoyjgdgkmzzz"/""),
           ({ ({ ({ "q" }), "adfgok"/"", "sdf"/"", ({ "ä" }), ({}),
                 "oje"/"", ({}), "rjgöo"/"", ({ "h" }), "jgdgkm"/"", ({}) }),
              ({ ({ "x" }), "adfgok"/"", ({}), ({ "ä" }), ({ "l" }),
                 "oje"/"", ({ "o" }), "rjgöo"/"", ({ "y" }), "jgdgkm"/"",
                 "zzz"/"" }) }))
test_equal(Array.diff("123.org"/"","http://123.org/"/""),
	   ({ ({ ({}), "123.org"/"", ({}) }),
	      ({ "http://"/"", "123.org"/"", ({ "/" }) }) }))

// - Array.diff3 (note that the results would be different for a really optimal diff3)
test_equal(Array.diff3(({}),({"a","c"}),({"b","y"})),
	   ({({({       })}),
	     ({({"a","c"})}),
	     ({({"b","y"})})}))
test_equal(Array.diff3(({"a"}),({"a","b"}),({"b"})),
	   ({({({"a"}),({   })}),
	     ({({"a"}),({"b"})}),
	     ({({   }),({"b"})})}))
test_equal(Array.diff3(({"a"}),({"a","c"}),({"b"})),
	   ({({({"a"}),({   })}),
	     ({({"a"}),({"c"})}),
	     ({({   }),({"b"})})}))
test_equal(Array.diff3(({"a","d"}),({"a","d"}),({"a","b"})),
	   ({({({"a"}),({"d"})}),
	     ({({"a"}),({"d"})}),
	     ({({"a"}),({"b"})})}))
test_equal(Array.diff3(({"a","b"}),({"b"}),({"c","b"})),
	   ({({({"a"}),({"b"})}),
	     ({({   }),({"b"})}),
	     ({({"c"}),({"b"})})}))
// The following is not optimal.
test_equal(Array.diff3(({"a","b"}),({"b"}),({"b","b"})),
	   ({({({"a"}),({"b"}),({   })}),
	     ({({   }),({"b"}),({   })}),
	     ({({   }),({"b"}),({"b"})})}))
test_equal(Array.diff3(({"a","c","d"}),({"a","d","d"}),({"a","b"})),
	   ({({({"a"}),({"c"}),({"d"}),({   })}),
	     ({({"a"}),({   }),({"d"}),({"d"})}),
	     ({({"a"}),({"b"}),({   }),({   })})}))
test_equal(Array.diff3(({"a","b","c"}),({"b","e","c"}),({"b","e","c"})),
	   ({({({"a"}),({"b"}),({   }),({"c"})}),
	     ({({   }),({"b"}),({"e"}),({"c"})}),
	     ({({   }),({"b"}),({"e"}),({"c"})})}))
test_equal(Array.diff3(({"a","b","x"}),({"y","b","c","x"}),({"y","c","a"})),
	   ({({({"a"}),({"b"}),({   }),({"x"})}),
	     ({({"y"}),({"b"}),({"c"}),({"x"})}),
	     ({({"y"}),({   }),({"c"}),({"a"})})}))
test_equal(Array.diff3(({"y","b","c","x"}),({"y","c","a"}),({"a","b","x"})),
	   ({({({"y"}),({"b"}),({"c"}),({"x"})}),
	     ({({"y"}),({   }),({"c"}),({"a"})}),
	     ({({"a"}),({"b"}),({   }),({"x"})})}))
test_equal(Array.diff3(({"y","b","c","x"}),({"a","b","x"}),({"y","c","a"})),
	   ({({({"y"}),({"b"}),({"c"}),({"x"})}),
	     ({({"a"}),({"b"}),({   }),({"x"})}),
	     ({({"y"}),({   }),({"c"}),({"a"})})}))
test_equal(Array.diff3(({"a","a","b","b"}),({"b","b","c","c"}),({"c","c","a","a"})),
	   ({({({"a","a"}),({"b","b"}),({       }),({       })}),
	     ({({       }),({"b","b"}),({"c","c"}),({       })}),
	     ({({       }),({       }),({"c","c"}),({"a","a"})})}))
// The following is not optimal.
test_equal(Array.diff3(({"a","x","b","c"}),({"b","x","c"}),({"b","x","c"})),
	   ({({({"a","x"}),({"b"}),({   }),({"c"})}),
	     ({({       }),({"b"}),({"x"}),({"c"})}),
	     ({({       }),({"b"}),({"x"}),({"c"})})}))
test_equal(Array.diff3(({"x","x","a","x"}),({"a","x","b","x"}),({"a","x","b","x"})),
	   ({({({"x","x"}),({"a","x"}),({       })}),
	     ({({       }),({"a","x"}),({"b","x"})}),
	     ({({       }),({"a","x"}),({"b","x"})})}))
test_equal(Array.diff3(({"a","a","b"}),({"b","c"}),({"c","a","a"})),
	   ({({({   }),({   }),({"a","a"}),({"b"})}),
	     ({({"b"}),({"c"}),({       }),({   })}),
	     ({({   }),({"c"}),({"a","a"}),({   })})}))
test_equal(Array.diff3(({"x","x","x","a"}),({"y","b"}),({"x","x","x","c"})),
	   ({({({"x","x","x"}),({"a"    })}),
	     ({({           }),({"y","b"})}),
	     ({({"x","x","x"}),({"c"    })})}))
test_equal(Array.diff3(({"a","x","x","x","a"}),({"b","y","y","b"}),({"c","x","x","x","c"})),
	   ({({({"a"            }),({"x","x","x"}),({"a"})}),
	     ({({"b","y","y","b"}),({           }),({   })}),
	     ({({"c"            }),({"x","x","x"}),({"c"})})}))
test_equal(Array.diff3(({"a","b","c","d"}),({"x","x","x","d"}),({"a","y","y","y"})),
	   ({({({"a"}),({"b","c"    }),({"d"})}),
	     ({({   }),({"x","x","x"}),({"d"})}),
	     ({({"a"}),({"y","y","y"}),({   })})}))
test_equal(Array.diff3(({"a","b","c","d"}),({"a","x","x","d"}),({"a","y","y","y"})),
	   ({({({"a"}),({"b","c"    }),({"d"})}),
	     ({({"a"}),({"x","x"    }),({"d"})}),
	     ({({"a"}),({"y","y","y"}),({   })})}))
test_equal(Array.diff3(({"a","b","c","d"}),({"x","x","x","b"}),({"a","y","y","y"})),
	   ({({({"a"        }),({"b"}),({"c","d"    })}),
	     ({({"x","x","x"}),({"b"}),({           })}),
	     ({({"a"        }),({   }),({"y","y","y"})})}))
test_equal(Array.diff3(({"a","b","c","d"}),({"x","x","x","c"}),({"a","y","y","y"})),
	   ({({({"a"}),({"b"        }),({"c"}),({"d"})}),
	     ({({   }),({"x","x","x"}),({"c"}),({   })}),
	     ({({"a"}),({"y","y","y"}),({   }),({   })})}))
test_equal(Array.diff3(({"a","b","b","c","d"}),({"z","a","b","b","x"}),({"z","b","c","x"})),
	   ({({({   }),({"a"}),({"b"}),({"b"}),({"c"}),({"d"})}),
	     ({({"z"}),({"a"}),({"b"}),({"b"}),({   }),({"x"})}),
	     ({({"z"}),({   }),({"b"}),({   }),({"c"}),({"x"})})}))
test_equal(Array.diff3(({"a","b","c","d"}),({"b","a","c","c"}),({"b","b","d","d","a"})),
	   ({({({"a"}),({"b"}),({"c"}),({"d"}),({   }),({   }),({       })}),
	     ({({   }),({"b"}),({   }),({   }),({   }),({"a"}),({"c","c"})}),
	     ({({   }),({"b"}),({"b"}),({"d"}),({"d"}),({"a"}),({       })})}))
// The following is not optimal.
test_equal(Array.diff3(({"a"}),({"b","a"}),({"a","b","a"})),
	   ({({({   }),({"a"}),({       })}),
	     ({({"b"}),({"a"}),({       })}),
	     ({({   }),({"a"}),({"b","a"})})}))
// The following is not optimal.
test_equal(Array.diff3(({"a","c"}),({"b","a","c"}),({"a","c","b","a","c"})),
	   ({({({   }),({"a","c"}),({           })}),
	     ({({"b"}),({"a","c"}),({           })}),
	     ({({   }),({"a","c"}),({"b","a","c"})})}))
// The following is not optimal.
test_equal(Array.diff3(({"a","d"}),({"b","a","c"}),({"a","c","b","a","c"})),
	   ({({({   }),({"a"}),({"d"        }),({   })}),
	     ({({"b"}),({"a"}),({           }),({"c"})}),
	     ({({   }),({"a"}),({"c","b","a"}),({"c"})})}))
// The following is not optimal.
test_equal(Array.diff3(({"a","a"}),({"b","a","d","a"}),({"a","a","b","a","a"})),
	   ({({({   }),({"a"}),({   }),({"a"}),({           })}),
	     ({({"b"}),({"a"}),({"d"}),({"a"}),({           })}),
	     ({({   }),({"a"}),({   }),({"a"}),({"b","a","a"})})}))
test_equal(Array.diff3(({"a"}),({"a","b"}),({"b","a"})),
	   ({({({   }),({"a"}),({   })}),
	     ({({   }),({"a"}),({"b"})}),
	     ({({"b"}),({"a"}),({   })})}))
test_equal(Array.diff3(({"a","b"}),({"b","a"}),({"a"})),
	   ({({({   }),({"a"}),({"b"})}),
	     ({({"b"}),({"a"}),({   })}),
	     ({({   }),({"a"}),({   })})}))
test_equal(Array.diff3(({"b","a"}),({"a"}),({"a","b"})),
	   ({({({"b"}),({"a"}),({   })}),
	     ({({   }),({"a"}),({   })}),
	     ({({   }),({"a"}),({"b"})})}))
test_equal(Array.diff3(({"a","b"}),({"a"}),({"b","a"})),
	   ({({({   }),({"a"}),({"b"})}),
	     ({({   }),({"a"}),({   })}),
	     ({({"b"}),({"a"}),({   })})}))
test_equal(Array.diff3(({"a","c"}),({"a","c","b","a"}),({"b","a","c"})),
	   ({({({   }),({"a","c"}),({       })}),
	     ({({   }),({"a","c"}),({"b","a"})}),
	     ({({"b"}),({"a","c"}),({       })})}))
test_equal(Array.diff3(({"a","c","b","a"}),({"a","c"}),({"b","a","c"})),
	   ({({({   }),({"a","c"}),({"b","a"})}),
	     ({({   }),({"a","c"}),({       })}),
	     ({({"b"}),({"a","c"}),({       })})}))

// - equal
// equal is already tested by this script

// - exit
// FIXME put test for exit here

// - explode
test_equal(({"a","b","c",}), "anna bnna c"/"nna ")
test_equal(({"\3333","\3333","\3333",}), "\3333nna \3333nna \3333"/"nna ")
test_equal(({"\3333333","\3333333","\3333333",}), "\3333333nna \3333333nna \3333333"/"nna ")
test_equal(({"","",}),"hej"/"hej")
test_equal(({""}),""/"hej")

// - fork()
// FIXME: add tests for fork

cond([[all_constants()->_verify_internals]],
[[
  test_do(_verify_internals())
]])

// - function_name
test_eq(function_name(a),"a")
test_eq(function_name(function_name),0)

// - function_object
test_eq(function_object(a),this_object())
test_eq(function_name(function_object),0)

// - get_function (actually in simulate.pike)
test_eq(a,
#pike 7.0
Simulate.get_function(this_object(),"a"))
test_eq(a,this_object()->a)

// - hash
test_true(intp(hash("foo")))
test_true(intp(hash("foo",10)))
test_true(hash("foo",10)<10)
test_true(hash("bar",10)<10)
test_true(hash("gazonk",10)<10)
test_eq(hash("foobargazonk"),hash("foobargazonk"))
test_false(hash(""))

// - implode
test_eq([[({})*""]],"")
test_eq([[("foo"/"o")*"o"]],"foo")
test_eq([[({"foo","bar"})*"-"]],"foo-bar")
test_eq([[({"foo",0,"bar"})*"-"]],"foo-bar")
test_eq([[({1.0,"foo",0,"bar",this_object(),([])})*"-"]],"foo-bar")
test_eq([[({"f","o","o"})*""]],"foo")

// - indices
test_equal(indices("foo"),({0,1,2}))
test_equal(indices(({'f','o','o'})),({0,1,2}))
test_equal(Array.sort_array(indices(([7:3,8:9,99:12]))),({7,8,99}))
test_equal(Array.sort_array(indices((<7,8,99>))),({7,8,99}))
test_equal(mkmultiset(indices(class{constant a="a"; constant b="b";}())),
	   (<"a","b">))

// - Array.longest_ordered_sequence
test_equal(Array.longest_ordered_sequence("dfgaokäpojghadjjioijrgxcvb"/""),
	   ({ 0, 1, 2, 10, 11, 16, 18, 19, 20, 22 }));

// - lower_case
test_equal(lower_case("foo"),"foo")
test_equal(lower_case("Foo"),"foo")
test_equal(lower_case("Foo1234-*~\n"),"foo1234-*~\n")
test_equal(lower_case("foo\x3000"),"foo\x3000")
test_equal(lower_case("Foo\x3000"),"foo\x3000")
test_equal(lower_case("Foo1234-*~\n\x3000"),"foo1234-*~\n\x3000")
test_equal(lower_case("foo\x13000"),"foo\x13000")
test_equal(lower_case("Foo\x13000"),"foo\x13000")
test_equal(lower_case("Foo1234-*~\n\x13000"),"foo1234-*~\n\x13000")
test_equal(lower_case("Foo\x178"),"foo\xff")
test_equal(lower_case("Foo\x39c"),"foo\x3bc")
test_equal(lower_case((string) ({
0x0000, 0x0041, 0x005b, 0x0061, 0x007b, 0x00b5, 0x00b6, 0x00c0, 
0x00d7, 0x00d8, 0x00df, 0x00e0, 0x00f7, 0x00f8, 0x00ff, 0x0100, 
0x0130, 0x0131, 0x0132, 0x0138, 0x0139, 0x0149, 0x014a, 0x0178, 
0x0179, 0x017f, 0x0180, 0x0181, 0x0182, 0x0186, 0x0187, 0x0189, 
0x018b, 0x018d, 0x018e, 0x018f, 0x0190, 0x0191, 0x0193, 0x0194, 
0x0195, 0x0196, 0x0197, 0x0198, 0x019a, 0x019c, 0x019d, 0x019e, 
0x019f, 0x01a0, 0x01a6, 0x01a7, 0x01a9, 0x01aa, 0x01ac, 0x01ae, 
0x01af, 0x01b1, 0x01b3, 0x01b7, 0x01b8, 0x01ba, 0x01bc, 0x01be, 
0x01bf, 0x01c0, 0x01c4, 0x01c5, 0x01c7, 0x01c8, 0x01ca, 0x01cb, 
0x01dd, 0x01de, 0x01f0, 0x01f1, 0x01f2, 0x01f6, 0x01f7, 0x01f8, 
0x0250, 0x0253, 0x0254, 0x0255, 0x0256, 0x0258, 0x0259, 0x025a, 
0x025b, 0x025c, 0x0260, 0x0261, 0x0263, 0x0264, 0x0268, 0x0269, 
0x026a, 0x026f, 0x0270, 0x0272, 0x0273, 0x0275, 0x0276, 0x0280, 
0x0281, 0x0283, 0x0284, 0x0288, 0x0289, 0x028a, 0x028c, 0x0292, 
0x0293, 0x0345, 0x0346, 0x0386, 0x0387, 0x0388, 0x038c, 0x038e, 
0x0390, 0x0391, 0x03a0, 0x03ac, 0x03ad, 0x03b0, 0x03b1, 0x03c0, 
0x03c2, 0x03c3, 0x03cc, 0x03cd, 0x03d0, 0x03d1, 0x03d2, 0x03d5, 
0x03d6, 0x03d7, 0x03da, 0x03f0, 0x03f1, 0x03f2, 0x03f3, 0x0400, 
0x0410, 0x0420, 0x0430, 0x0440, 0x0450, 0x0460, 0x0482, 0x048c, 
0x04c0, 0x04c1, 0x04d0, 0x0531, 0x0559, 0x0561, 0x0587, 0x1e00, 
0x1e96, 0x1e9b, 0x1ea0, 0x1f00, 0x1f08, 0x1f10, 0x1f18, 0x1f20, 
0x1f28, 0x1f30, 0x1f38, 0x1f40, 0x1f48, 0x1f50, 0x1f51, 0x1f52, 
0x1f53, 0x1f54, 0x1f55, 0x1f56, 0x1f57, 0x1f59, 0x1f60, 0x1f68, 
0x1f70, 0x1f72, 0x1f76, 0x1f78, 0x1f7a, 0x1f7c, 0x1f80, 0x1f88, 
0x1f90, 0x1f98, 0x1fa0, 0x1fa8, 0x1fb0, 0x1fb2, 0x1fb3, 0x1fb4, 
0x1fb8, 0x1fba, 0x1fbc, 0x1fbd, 0x1fbe, 0x1fbf, 0x1fc3, 0x1fc4, 
0x1fc8, 0x1fcc, 0x1fcd, 0x1fd0, 0x1fd2, 0x1fd8, 0x1fda, 0x1fdd, 
0x1fe0, 0x1fe2, 0x1fe5, 0x1fe6, 0x1fe8, 0x1fea, 0x1fec, 0x1fed, 
0x1ff3, 0x1ff4, 0x1ff8, 0x1ffa, 0x1ffc, 0x1ffd, 0x2126, 0x2127, 
0x212a, 0x212b, 0x212c, 0x2160, 0x2180, 0x24b6, 0x24d0, 0x24ea, 
0xff21, 0xff3b, 0xff41, 0xff5b, })), (string) ({
0x0000, 0x0061, 0x005b, 0x0061, 0x007b, 0x00b5, 0x00b6, 0x00e0, 
0x00d7, 0x00f8, 0x00df, 0x00e0, 0x00f7, 0x00f8, 0x00ff, 0x0101, 
0x0069, 0x0131, 0x0133, 0x0138, 0x013a, 0x0149, 0x014b, 0x00ff, 
0x017a, 0x017f, 0x0180, 0x0253, 0x0183, 0x0254, 0x0188, 0x0256, 
0x018c, 0x018d, 0x01dd, 0x0259, 0x025b, 0x0192, 0x0260, 0x0263, 
0x0195, 0x0269, 0x0268, 0x0199, 0x019a, 0x026f, 0x0272, 0x019e, 
0x0275, 0x01a1, 0x0280, 0x01a8, 0x0283, 0x01aa, 0x01ad, 0x0288, 
0x01b0, 0x028a, 0x01b4, 0x0292, 0x01b9, 0x01ba, 0x01bd, 0x01be, 
0x01bf, 0x01c0, 0x01c6, 0x01c6, 0x01c9, 0x01c9, 0x01cc, 0x01cc, 
0x01dd, 0x01df, 0x01f0, 0x01f3, 0x01f3, 0x0195, 0x01bf, 0x01f9, 
0x0250, 0x0253, 0x0254, 0x0255, 0x0256, 0x0258, 0x0259, 0x025a, 
0x025b, 0x025c, 0x0260, 0x0261, 0x0263, 0x0264, 0x0268, 0x0269, 
0x026a, 0x026f, 0x0270, 0x0272, 0x0273, 0x0275, 0x0276, 0x0280, 
0x0281, 0x0283, 0x0284, 0x0288, 0x0289, 0x028a, 0x028c, 0x0292, 
0x0293, 0x0345, 0x0346, 0x03ac, 0x0387, 0x03ad, 0x03cc, 0x03cd, 
0x0390, 0x03b1, 0x03c0, 0x03ac, 0x03ad, 0x03b0, 0x03b1, 0x03c0, 
0x03c2, 0x03c3, 0x03cc, 0x03cd, 0x03d0, 0x03d1, 0x03d2, 0x03d5, 
0x03d6, 0x03d7, 0x03db, 0x03f0, 0x03f1, 0x03f2, 0x03f3, 0x0450, 
0x0430, 0x0440, 0x0430, 0x0440, 0x0450, 0x0461, 0x0482, 0x048d, 
0x04c0, 0x04c2, 0x04d1, 0x0561, 0x0559, 0x0561, 0x0587, 0x1e01, 
0x1e96, 0x1e9b, 0x1ea1, 0x1f00, 0x1f00, 0x1f10, 0x1f10, 0x1f20, 
0x1f20, 0x1f30, 0x1f30, 0x1f40, 0x1f40, 0x1f50, 0x1f51, 0x1f52, 
0x1f53, 0x1f54, 0x1f55, 0x1f56, 0x1f57, 0x1f51, 0x1f60, 0x1f60, 
0x1f70, 0x1f72, 0x1f76, 0x1f78, 0x1f7a, 0x1f7c, 0x1f80, 0x1f80, 
0x1f90, 0x1f90, 0x1fa0, 0x1fa0, 0x1fb0, 0x1fb2, 0x1fb3, 0x1fb4, 
0x1fb0, 0x1f70, 0x1fb3, 0x1fbd, 0x1fbe, 0x1fbf, 0x1fc3, 0x1fc4, 
0x1f72, 0x1fc3, 0x1fcd, 0x1fd0, 0x1fd2, 0x1fd0, 0x1f76, 0x1fdd, 
0x1fe0, 0x1fe2, 0x1fe5, 0x1fe6, 0x1fe0, 0x1f7a, 0x1fe5, 0x1fed, 
0x1ff3, 0x1ff4, 0x1f78, 0x1f7c, 0x1ff3, 0x1ffd, 0x03c9, 0x2127, 
0x006b, 0x00e5, 0x212c, 0x2170, 0x2180, 0x24d0, 0x24d0, 0x24ea, 
0xff41, 0xff3b, 0xff41, 0xff5b, }))


// - next_object
test_true(objectp(next_object()))
test_any(int e;object o=next_object(); for(e=0;e<10000 && (o || objectp(o));e++) o=next_object(o); return o,0)

// - object_program
test_true(programp(object_program(this_object())))

// - query_num_arg
test_eq(lambda(int ... q) { return query_num_arg(); }(),0)
test_eq(lambda(int ... q) { return query_num_arg(); }(1),1)
test_eq(lambda(int ... q) { return query_num_arg(); }(1,1),2)
test_eq(lambda(int ... q) { return query_num_arg(); }(1,1,1),3)
test_eq(lambda(int ... q) { return query_num_arg(); }(1,1,1,1),4)

// - random
test_any([[int e,d;for(e=0;e<1000;e++){d=random(10); if(d<0 || d>=10) return 0;} return 1]],1)
test_eq([[ random( ({11,21,31,41}) ) % 10 ]], 1)
test_eq([[ random( ({11,21,31,41}) ) % 10 ]], 1)
test_eq([[ random( ({11,21,31,41}) ) % 10 ]], 1)
test_eq([[ random( ({11,21,31,41}) ) % 10 ]], 1)
test_eq([[ random( (<11,21,31,41>) ) % 10 ]], 1)
test_eq([[ random( (<11,21,31,41>) ) % 10 ]], 1)
test_eq([[ random( (<11,21,31,41>) ) % 10 ]], 1)
test_eq([[ random( (<11,21,31,41>) ) % 10 ]], 1)
test_eq([[ random( (<11,21,31,41>) ) % 10 ]], 1)
test_eq([[ random( (<11,21,31,41>) ) % 10 ]], 1)
test_eq([[ `-( @random( ([11:21,31:41]) )) ]], -10)
test_eq([[ `-( @random( ([11:21,31:41]) )) ]], -10)
test_eq([[ `-( @random( ([11:21,31:41]) )) ]], -10)
test_eq([[ `-( @random( ([11:21,31:41]) )) ]], -10)
test_eval_error([[ return random( ({}) ) ]])
test_eval_error([[ return random( (<>) ) ]])
test_eval_error([[ return random( ([]) ) ]])
test_eq([[ random( class() { int _random() { return 17; }}()) ]], 17)

// random_seed
test_do(int p; foreach(({1,2,3,4,5}),p) random_seed(p))
test_eq([[random_seed(17),random(20000)]],[[random_seed(17),random(20000)]])
test_eq([[random_seed(18),random(20000)]],[[random_seed(18),random(20000)]])
test_eq([[random_seed(19),random(20000)]],[[random_seed(19),random(20000)]])

// - replace
test_eq(replace("foo","f","\x9999"),"\x9999oo")
test_eq(replace("foo",({"f"}),({"\x9999"})),"\x9999oo")
test_eq([[replace("11013",({"1","100","108","13","1069","1067","106","10"}),
	({"A","B","C","D","E","F","G","H"}))]],"AHD")
test_eq([[replace("1264412124",({"126","124","12","122","1260"}),
         ({"13333","13335","883","13329","226709"}))]],"133334488313335")
test_eq(replace("foobargazonk","o","-"),"f--bargaz-nk")
test_eq(replace("foobargazonk",({"o","a"}),({"()","<>"})),"f()()b<>rg<>z()nk")
test_eq(replace("f--barf--",({"f--","f--bar"}),({"f--bar","f--"})),"f--f--bar")
test_eq(replace("f--barf--",({"f--bar","f--"}),({"f--","f--bar"})),"f--f--bar")
test_eq(replace("test\ntest\n\ntest\ntest",({"\n","\n\n"}),({" ","<p>"})),"test test<p>test test")
test_eq(replace("test\ntest\n\ntest\ntest",({"\n\n","\n"}),({"<p>"," "})),"test test<p>test test")
test_eq(replace("\xfffffff0", ({ "\xfffffff0" }), ({ "" })), "")

test_eq("123\000456""890"-"\0", "123\456""890")
test_eq("123\456000""890"-"\0", "123\456000""890")

test_any([[
  array a=({ 1 });
  replace(a,1,2);
  return a[0];
]], 2)

test_any([[
  mapping a=([ 1:1 ]);
  replace(a,1,2);
  return a[1];
]], 2)

test_any([[
function reference=lambda(string x, array(string) a, array(string) b)
{
  string ret="";
  for(int pos=0;pos<strlen(x);)
  {
    int best=-1;
    int bestlen=-1;
    for(int e=0;e<sizeof(a);e++)
    {
      if(strlen(a[e])>bestlen)
      {
	if(x[pos..pos+strlen(a[e])-1] == a[e])
	{
	  best=e;
	  bestlen=strlen(a[e]);
	}
      }
    }

    if(best==-1)
    {
      ret+=x[pos..pos];
      pos++;
    }else{
      ret+=b[best];
      pos+=bestlen;
    }
  }
  return ret;
};

  for(int e=0;e<10000;e++)
  {
    array(string) base=(array(string)) ( (({random})*(1+random(10)))(20) );

    for(int d=0;d<random(random(40));d++)
      base+=({ base[ random(sizeof(base))] + random(10) });

    base=Array.uniq(base);
    string *to=(array(string))Array.map(base,hash);

    string text="";
    for(int d=0;d<1+random(random(50));d++)
    {
      if(random(2))
	text+=base[ random(sizeof(base))];
      else
	text+=sprintf("%2d",random(100));
    }

    string r1=replace(text,base,to);
    string r2=reference(text,base,to);

    if(r1 != r2)
    {
      werror("\nFailiure:\n");
      werror("Text: %O\n",text);
      werror("From: %O\n",base);
      werror("To  : %O\n",to);
      werror("Builtin: %O\n",r1);
      werror("Ref    : %O\n",r2);
      return -1;
    }
  }
  return 1;
]],1)

test_eq(replace("f\777\777bargaz\777nk","\777","-"),"f--bargaz-nk")
test_eq(replace("f\777\777bargaz\777nk",({"\777","a"}),({"()","<>"})),"f()()b<>rg<>z()nk")
test_eq(replace("f\777\777barf\777\777",({"f\777\777","f\777\777bar"}),({"f\777\777bar","f\777\777"})),"f\777\777f\777\777bar")
test_eq(replace("f\777\777barf\777\777",({"f\777\777bar","f\777\777"}),({"f\777\777","f\777\777bar"})),"f\777\777f\777\777bar")

test_eq(replace("f\7777777\7777777bargaz\7777777nk","\7777777","-"),"f--bargaz-nk")
test_eq(replace("f\7777777\7777777bargaz\7777777nk",({"\7777777","a"}),({"()","<>"})),"f()()b<>rg<>z()nk")
test_eq(replace("f\7777777\7777777barf\7777777\7777777",({"f\7777777\7777777","f\7777777\7777777bar"}),({"f\7777777\7777777bar","f\7777777\7777777"})),"f\7777777\7777777f\7777777\7777777bar")
test_eq(replace("f\7777777\7777777barf\7777777\7777777",({"f\7777777\7777777bar","f\7777777\7777777"}),({"f\7777777\7777777","f\7777777\7777777bar"})),"f\7777777\7777777f\7777777\7777777bar")

test_equal(replace(({1,2,3,4,5,1,2,3,4}),3,-1),({1,2,-1,4,5,1,2,-1,4}))
test_equal(replace(([1:2,3:4,5:1,2:3]),3,-1),([1:2,3:4,5:1,2:-1]))

// - reverse
test_eq(reverse("reverse"),"esrever")
test_eq(reverse("r\777v\777rs\777"),"\777sr\777v\777r")
test_eq(reverse("r\7777777v\7777777rs\7777777"),"\7777777sr\7777777v\7777777r")
test_eq(reverse(""),"")
test_eq(reverse("a"),"a")
test_equal(reverse(({1,5,9})),({9,5,1}))
test_equal(reverse(({})),({}))
test_equal(reverse(({42})),({42}))
test_equal(reverse(({42,4711})),({4711,42}))
test_equal(reverse(0x12345678),0x1e6a2c48)

// - rusage
test_true(arrayp(rusage()))
test_true(sizeof(rusage())>28)

// - has_index
test_false([[ has_index([mixed] ({}), 0) ]])
test_false([[ has_index([mixed] ({}), "foo") ]])
test_false([[ has_index([mixed] ({ "a" }), -1) ]])
test_false([[ has_index([mixed] ({ "a" }), "a") ]])
test_true([[ has_index([mixed] ({ "a" }), 0) ]])
test_false([[ has_index([mixed] ({ "a" }), 1) ]])
test_true([[ has_index([mixed] ({ "a", "b" }), 1) ]])
test_false([[ has_index([mixed] ([ "a":"A" ]), 4711) ]])
test_true([[ has_index([mixed] ([ "a":"A" ]), "a") ]])
test_false([[ has_index([mixed] ([ "a":"A" ]), "A") ]])
test_true([[ has_index([mixed] ([ "a":"A", "b":"B", "c":"C" ]), "b") ]])
test_false([[ has_index([mixed] ([ "a":"A", "b":"B", "c":"C" ]), "B") ]])
test_false([[ has_index((class {})(), "foo") ]])
test_true([[has_index((class{array _indices(){return({"a","b"});}})(),"b")]])

// - has_value
test_false([[ has_value([mixed] ({}), 0) ]])
test_false([[ has_value([mixed] ({}), "foo") ]])
test_false([[ has_value([mixed] ({ "a" }), -1) ]])
test_true([[ has_value([mixed] ({ "a" }), "a") ]])
test_false([[ has_value([mixed] ({ "a" }), 0) ]])
test_true([[ has_value([mixed] ({ "a", "b" }), "b") ]])
test_false([[ has_value([mixed] ([ "a":"A" ]), 4711) ]])
test_true([[ has_value([mixed] ([ "a":"A" ]), "A") ]])
test_false([[ has_value([mixed] ([ "a":"A" ]), "a") ]])
test_true([[ has_value([mixed] ([ "a":"A", "b":"B", "c":"C" ]), "B") ]])
test_false([[ has_value([mixed] ([ "a":"A", "b":"B", "c":"C" ]), "b") ]])
test_false([[ has_value((class {})(), "foo") ]])
test_true([[has_value((class{array _values(){return({"a","b"});}})(),"b")]])

// - search
test_eval_error(return search("foolbar","o",-10))
test_eval_error(return search("foolbar","o",2983742))
test_eq(search("foolbar","gazonk"),-1)
test_eq(search("qowiueproqiuweproiwqueoplkjljlklksjjriwueproiuwerowieu","lkjljlklksjj"),24)
test_eq(search("lkjljlklksjjriwueproiuwerlskjdvlaskjfowieu","lkjljlklksjj"),0)
test_eq(search("aaaaaaaaaaaaaaaaaaaaaaaalkjljlklksjj","lkjljlklksjj"),24)
test_eq(search("foobargazonk","oo"),1)
test_eq(search("foobargazonk","o",3),9)
test_eq(search("foobargazonk","o",9),9)
test_eq(search("foobargazonk","o",10),-1)
test_eq(search("foobargazonk","x",9),-1)
test_eq(search(({56,8,2,6,2,7,3,56,7}),8),1)
test_eq(search(({56,8,2,6,2,7,3,56,7}),56,0),0)
test_eq(search(({56,8,2,6,2,7,3,56,7}),56,1),7)
test_eq(search(({56,8,2,6,2,7,3,56,7}),56,7),7)
test_eq(search(({56,8,2,6,2,7,3,56,7}),56,8),-1)
test_eq(search(({"foo"}),"foo"),0)
test_eq(search("fo-obar|gazonk"/"|","fo-obar"),0)
test_eq(search("fo-obar|gazonk"/"|","gazonk"),1)
test_eq(search(([1:2,3:4,5:6,7:8]),4),3)
test_true(zero_type(search(([1:2,3:4,5:6,7:8]),(int)3)))
test_eq(search(([1:2,3:4,5:6,7:8]),8),7)
test_any([[
  mapping m=([]);
  m+=(["x":([])]);
  m->x->y++;
  m=([]);
  m+=(["x":([])]);
  return m->x->y;
]], 0)

test_do([[
  class C
  {
    mapping m;
    
    int `==()
    {
      foreach(indices(m), mixed x)
  	m_delete(m, x);
      return 0;
    }
  
    void create(mapping _m)
    {
      m = _m;
    }
  };
  
  mapping m = ([ ]);
  C o = C(m);
  
  for(int i = 0; i < 100; i++)
    m[i] = o;
  
  return search(m, 4711);
]])

test_any_equal([[
  mapping m = (["foo": "bar", "bar": "gnu", "gnu": "bar"]);
  array a = ({});
  a += ({search (m, "bar")});
  a += ({search (m, "bar", a[-1])});
  a += ({search (m, "bar", a[-1])});
  return sort (a);
]], sort(({0, "foo", "gnu"})))

// test large searches (find string, size, pattern)
define(test_search,[[
test_eq(sprintf($1+"%'"+$3+"'*n",$2)[..strlen($1)-1],$1)
test_eq(search(sprintf($1+"%'"+$3+"'*n",$2),$1),0)
test_eq(search(sprintf("%'"+$3+"'*n" ,$2),$1),-1)
test_eq(search(sprintf("%'"+$3+"'*n"+$1,$2),$1),$2)
test_eq(search(sprintf("%'"+$3+"'*n"+$1+"%'"+$3+"'*n",$2,$2),$1),$2)
]])

define(test_search2,[[dnl
test_search($1,$2,$3)
test_search($1,$2+1,$3)
test_search($1,$2+2,$3)
test_search($1,$2+3,$3)
test_search($1,$2+4,$3)
test_search($1,$2+5,$3)
]])

define(test_search3,[[dnl
test_search2($1,10,$2)
test_search2($1,1000,$2)
test_search2($1,100000,$2)
]])

define(test_search4,[[dnl
test_search3($1,"+-*")
test_search3($1,($1[..strlen($1)-2]))
test_search3($1,($1[..strlen($1)-3]))
test_search3($1,($1[1..]))
]])

dnl some m4's don't handle 8 bit characters...
test_search4("SUNE")
test_search4("kapit\344l>")
test_search4("-------------------+")
test_search4("\345-------------------")
test_search4(sprintf("%'argel-bargel glop-glyf?'2000n"))

dnl these can be uncommented when sprintf handles wide strings
test_search4("\34567-------------------")
test_search4("\345677777-------------------")
test_search4("kapit\3333l>")
test_search4("kapit\3333333l>")


// - sprintf
test_eq(sprintf("%.1f",31415.9267),"31415.9")
test_eq(sprintf("%.0f",31415.9267),"31416")
test_eq(sprintf("%.-1f",31415.9267),"31420")
test_eq(sprintf("%.-2f",31415.9267),"31400")
test_eq(sprintf("%.-2f",-31415.9267),"-31400")
test_eq(sprintf("%.-10f",31415.9267),"0")
test_eq(sprintf("%20.-3f", 31415.92670),"               31000")
test_eq(sprintf("%t", ({"a"})), "array")
test_any([[array(string) a = ({"a"}); return sprintf("%t", a);]], "array")
test_eq(sprintf("%t", 0), "int")
test_any([[array(string) a = 0; return sprintf("%t", a);]], "int")

// - sizeof
test_eq(sizeof("felbar"),6)
test_eq(sizeof(({"fulbar","gazonk",7})),3)
test_eq(sizeof(([8:3,6:6,7:0])),3)
test_eq(sizeof((<8,7,6,5,4,7>)),6)

// - sleep
test_do(sleep(1))
test_do(sleep(0.5))
test_any([[int x=time(); sleep(2); return x!=time()]],1)
test_any([[int x=time(); sleep(2); return x!=time()]],1)

// - string_to_unicode, unicode_to_string
test_eq(string_to_unicode("foo"), "\0f\0o\0o")
test_eq(string_to_unicode("blä"), "\0b\0l\0ä")
test_eq(string_to_unicode("\77077"), "\176\77")
test_eq(string_to_unicode("\777077"), "\330\277\336\77")
test_eq(string_to_unicode("\777077foo\77077\777077blä\777077"), "\330\277\336\77\0f\0o\0o\176\77\330\277\336\77\0b\0l\0ä\330\277\336\77")
test_eq(unicode_to_string("\330\277\336\77\0f\0o\0o\176\77\330\277\336\77\0b\0l\0ä\330\277\336\77"), "\777077foo\77077\777077blä\777077")
test_eq(unicode_to_string("\330\277\336\77"), "\777077")
test_eq(unicode_to_string("\176\77"), "\77077")
test_eq(unicode_to_string("\0b\0l\0ä"), "blä")
test_eq(unicode_to_string("\0f\0o\0o"), "foo")
test_eq(unicode_to_string("\xfe\xff\330\277\336\77\0f\0o\0o\176\77\330\277\336\77\0b\0l\0ä\330\277\336\77"), "\777077foo\77077\777077blä\777077")
test_eq(unicode_to_string("\xfe\xff\330\277\336\77"), "\777077")
test_eq(unicode_to_string("\xfe\xff\176\77"), "\77077")
test_eq(unicode_to_string("\xfe\xff\0b\0l\0ä"), "blä")
test_eq(unicode_to_string("\xfe\xff\0f\0o\0o"), "foo")
test_eq(unicode_to_string("\xff\xfe\277\330\77\336f\0o\0o\0\77\176\277\330\77\336b\0l\0ä\0\277\330\77\336"), "\777077foo\77077\777077blä\777077")
test_eq(unicode_to_string("\xff\xfe\277\330\77\336"), "\777077")
test_eq(unicode_to_string("\xff\xfe\77\176"), "\77077")
test_eq(unicode_to_string("\xff\xfe""b\0l\0ä\0"), "blä")
test_eq(unicode_to_string("\xff\xfe""f\0o\0o\0"), "foo")

test_eval_error(return string_to_unicode("\7077077"))

// - string_to_utf8, utf8_to_string
test_eq(string_to_utf8("foo"), "foo")
test_eq(string_to_utf8("blä"), "bl\303\244")
test_eq(string_to_utf8("\77077"), "\347\270\277")
test_eq(string_to_utf8("\7077077"), "\367\207\270\277")
test_eq(string_to_utf8("\77077077"), "\370\277\207\270\277")
test_eq(string_to_utf8("\7077077077"), "\374\270\277\207\270\277")
test_eq(string_to_utf8("\77077077077", 1), "\376\203\270\277\207\270\277")
test_eq(utf8_to_string("\376\203\270\277\207\270\277", 1), "\77077077077")
test_eq(utf8_to_string("\374\270\277\207\270\277"), "\7077077077")
test_eq(utf8_to_string("\370\277\207\270\277"), "\77077077")
test_eq(utf8_to_string("\367\207\270\277"), "\7077077")
test_eq(utf8_to_string("\347\270\277"), "\77077")
test_eq(utf8_to_string("bl\303\244"), "blä")
test_eq(utf8_to_string("foo"), "foo")

test_eval_error(return string_to_utf8("\77077077077"))
test_eval_error(return utf8_to_string("\376\203\270\277\207\270\277"))
test_eval_error(return utf8_to_string("\277"));
test_eval_error(return utf8_to_string("\377"));
test_eval_error(return utf8_to_string("\376\203\270\277\207\270", 1));
test_eval_error(return utf8_to_string("\374\270\277\207\270"));
test_eval_error(return utf8_to_string("\370\277\207\270"));
test_eval_error(return utf8_to_string("\367\207\270"));
test_eval_error(return utf8_to_string("\347\270"));
test_eval_error(return utf8_to_string("\303"));
test_eval_error(return utf8_to_string("\376\203\270\277\207\270a"));
test_eval_error(return utf8_to_string("\374\270\277\207\270a"));
test_eval_error(return utf8_to_string("\370\277\207\270a"));
test_eval_error(return utf8_to_string("\367\207\270a"));
test_eval_error(return utf8_to_string("\347\270a"));
test_eval_error(return utf8_to_string("\303a"));

// - String.trim_whites, String.trim_all_whites
test_eq(String.trim_whites (" \t\0 \t"), "\0")
test_eq(String.trim_whites (" \t\400 \t"), "\400")
test_eq(String.trim_whites (" \t\200000 \t"), "\200000")
test_eq(String.trim_whites ("\0"), "\0")
test_eq(String.trim_whites ("\400"), "\400")
test_eq(String.trim_whites ("\200000"), "\200000")
test_eq(String.trim_whites (" \t "), "")
test_eq(String.trim_whites (""), "")
test_eq(String.trim_all_whites (" \t\n\r\0 \t\n\r"), "\0")
test_eq(String.trim_all_whites (" \t\n\r\400 \t\n\r"), "\400")
test_eq(String.trim_all_whites (" \t\n\r\200000 \t\n\r"), "\200000")
test_eq(String.trim_all_whites ("\0"), "\0")
test_eq(String.trim_all_whites ("\400"), "\400")
test_eq(String.trim_all_whites ("\200000"), "\200000")
test_eq(String.trim_all_whites (" \t\n\r "), "")
test_eq(String.trim_all_whites (""), "")

// - sum
test_eq(`+(1,1),2)
test_eq(`+(1,-2),-1)
test_eq(`+(-2,-2),-4)
test_eq(`+("hi","there"),"hithere")

test_eq(`+("hi\777","there"),"hi\777there")
test_eq(`+("hi","there\777"),"hithere\777")

test_eq(`+("hi\7777777","there"),"hi\7777777there")
test_eq(`+("hi","there\7777777"),"hithere\7777777")

test_eq(`+("human","number",666),"humannumber666")
test_eq(`+("human","number",666),"humannumber666")
test_eq(`+("human","number",666),"humannumber666")
test_eq(`+("human","number",666,111),"humannumber666111")
test_eq(`+("humannumber",`+(666+111)),"humannumber777")
test_eq(`+("a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","x","y"),"abcdefghijklmnopqrstuvxy")
test_eq(`+(1.0+1.0),2.0)
test_eq(`+(1.0,-1.0),0.0)
test_eq(`+(-1.0,-1.0),-2.0)
test_equal(`+(({1,2,3}),({4,5,6})),({1,2,3,4,5,6}))
test_equal(`+((<1,2,3,4>),(<4,5,6>)),(<1,2,3,4,4,5,6>))
test_equal(`+(([0:1,3:6]),([5:2,3:6])),([0:1,3:6,3:6,5:2]))

test_any(return((1+2+3)-(1+2-3)), 6)

// - this_object
test_true(objectp(this_object()))

// - throw
test_eq(20,catch(throw(a())))

// - catch compile-errors
test_any([[ master()->set_inhibit_compile_errors(lambda(){});mixed res = catch{compile_string("dfasfqw123");};master()->set_inhibit_compile_errors(0); return arrayp(res); ]], 1)

// catch
test_false([[class X { string test(string foo) { catch { return lower_case(foo); }; return foo; }}()->test(0); ]])

// - time
test_true(time())
test_true(time(1))
test_true(intp(time()))
test_true(intp(time(1)))
test_true(floatp(time(2)))


// gethrtime() may gethrtime(), RDTSC or gettimeofday
// sleep uses a combination of select/poll and the above
// time() uses gettimeofday
test_any([[
   float tts=2.0;

   int t0=time();
   float t1=time(t0);
   int hrt1=gethrtime();
   sleep(tts);
   int hrt2=gethrtime();
   float t2=time(t0);
   
   float e=(hrt2-hrt1)*1e-6;
   float f=t2-t1;

   array r=({});
   if (e<tts-0.1 || e>tts+0.1) 
      r+=({sprintf("hrtime %.6f, %+.6f",e,e-tts)});

   if (f<tts-0.1 || f>tts+0.1) 
      r+=({sprintf("timeofday %.6f, %+.6f",f,f-tts)});

   if (sizeof(r)) return r*" / ";
   return "no error";
]],"no error")


// Stdio.FILE gets/ngets tests

test_equal([[
lambda()
{
   Stdio.write_file("testsuite.tmp","hej\nhopp\ngazonk");
   Stdio.FILE r=Stdio.FILE("testsuite.tmp","r");
   array v=({});
   while (string s=r->gets())
      v+=({s});
   return v;
}()
]],({"hej","hopp","gazonk"}))

test_equal([[
lambda()
{
   Stdio.write_file("testsuite.tmp",        // 59 is a prime number:
	"abcdefghijklmnopqrstuvwxyzåäöABCDEFGHIJKLMNOPQRSTUVWXYZÅÄÖ!\n"*400);
   Stdio.FILE r=Stdio.FILE("testsuite.tmp","r");
   array v=({});
   while (string s=r->gets())
      v+=({s});
   return v;
}()
]],({"abcdefghijklmnopqrstuvwxyzåäöABCDEFGHIJKLMNOPQRSTUVWXYZÅÄÖ!"})*400)

test_equal([[
lambda()
{
   Stdio.write_file("testsuite.tmp",
	"abcdefghijklmnopqrstuvwxyzåäöABCDEFGHIJKLMNOPQRSTUVWXYZÅÄÖ!\n"*400);
   Stdio.FILE r=Stdio.FILE("testsuite.tmp","r");
   return r->ngets();
}()
]],({"abcdefghijklmnopqrstuvwxyzåäöABCDEFGHIJKLMNOPQRSTUVWXYZÅÄÖ!"})*400)

test_equal([[
lambda()
{
   Stdio.write_file("testsuite.tmp", "\n"*400);
   Stdio.FILE r=Stdio.FILE("testsuite.tmp","r");
   array v=({});
   while (string s=r->gets())
      v+=({s});
   return v;
}()
]],({""})*400)

test_equal([[
lambda()
{
   Stdio.write_file("testsuite.tmp","\n"*400);
   Stdio.FILE r=Stdio.FILE("testsuite.tmp","r");
   return r->ngets();
}()
]],({""})*400)

test_equal([[
lambda()
{
   Stdio.write_file("testsuite.tmp","hej\nhopp\ngazonk\n");
   Stdio.FILE r=Stdio.FILE("testsuite.tmp","r");
   array v=({});
   while (string s=r->gets())
      v+=({s});
   return v;
}()
]],({"hej","hopp","gazonk"}))

test_equal([[
lambda()
{
   Stdio.write_file("testsuite.tmp","hej\nhopp\ngazonk\n");
   Stdio.FILE r=Stdio.FILE("testsuite.tmp","r");
   return r->ngets();
}()
]],({"hej","hopp","gazonk"}))

test_equal([[
lambda()
{
   Stdio.write_file("testsuite.tmp","hej\nhopp\ngazonk");
   Stdio.FILE r=Stdio.FILE("testsuite.tmp","r");
   return r->ngets();
}()
]],({"hej","hopp","gazonk"}))

test_equal([[
lambda()
{
   Stdio.write_file("testsuite.tmp","hej\nhopp\ngazonk\n");
   Stdio.FILE r=Stdio.FILE("testsuite.tmp","r");
   return r->ngets(100);
}()
]],({"hej","hopp","gazonk"}))

test_equal([[
lambda()
{
   Stdio.write_file("testsuite.tmp","hej\nhopp\ngazonk");
   Stdio.FILE r=Stdio.FILE("testsuite.tmp","r");
   return r->ngets(100);
}()
]],({"hej","hopp","gazonk"}))
   
// - trace
test_do(trace(0))
test_eq(trace(0),0)

// - upper_case
test_equal(upper_case("fooq"),"FOOQ")
test_equal(upper_case("FooR"),"FOOR")
test_equal(upper_case("Foo1234-*~\n"),"FOO1234-*~\n")
test_equal(upper_case("fooq\x3000"),"FOOQ\x3000")
test_equal(upper_case("FooR\x3000"),"FOOR\x3000")
test_equal(upper_case("Foo1234-*~\n\x3000"),"FOO1234-*~\n\x3000")
test_equal(upper_case("fooq\x13000"),"FOOQ\x13000")
test_equal(upper_case("FooR\x13000"),"FOOR\x13000")
test_equal(upper_case("Foo1234-*~\n\x13000"),"FOO1234-*~\n\x13000")
test_equal(upper_case("Foo\xff"),"FOO\x178")
test_equal(upper_case("Foo\xb5"),"FOO\x39c")
test_equal(upper_case((string) ({
0x0000, 0x0041, 0x005b, 0x0061, 0x007b, 0x00b5, 0x00b6, 0x00c0, 
0x00d7, 0x00d8, 0x00df, 0x00e0, 0x00f7, 0x00f8, 0x00ff, 0x0100, 
0x0130, 0x0131, 0x0132, 0x0138, 0x0139, 0x0149, 0x014a, 0x0178, 
0x0179, 0x017f, 0x0180, 0x0181, 0x0182, 0x0186, 0x0187, 0x0189, 
0x018b, 0x018d, 0x018e, 0x018f, 0x0190, 0x0191, 0x0193, 0x0194, 
0x0195, 0x0196, 0x0197, 0x0198, 0x019a, 0x019c, 0x019d, 0x019e, 
0x019f, 0x01a0, 0x01a6, 0x01a7, 0x01a9, 0x01aa, 0x01ac, 0x01ae, 
0x01af, 0x01b1, 0x01b3, 0x01b7, 0x01b8, 0x01ba, 0x01bc, 0x01be, 
0x01bf, 0x01c0, 0x01c4, 0x01c5, 0x01c7, 0x01c8, 0x01ca, 0x01cb, 
0x01dd, 0x01de, 0x01f0, 0x01f1, 0x01f2, 0x01f6, 0x01f7, 0x01f8, 
0x0250, 0x0253, 0x0254, 0x0255, 0x0256, 0x0258, 0x0259, 0x025a, 
0x025b, 0x025c, 0x0260, 0x0261, 0x0263, 0x0264, 0x0268, 0x0269, 
0x026a, 0x026f, 0x0270, 0x0272, 0x0273, 0x0275, 0x0276, 0x0280, 
0x0281, 0x0283, 0x0284, 0x0288, 0x0289, 0x028a, 0x028c, 0x0292, 
0x0293, 0x0345, 0x0346, 0x0386, 0x0387, 0x0388, 0x038c, 0x038e, 
0x0390, 0x0391, 0x03a0, 0x03ac, 0x03ad, 0x03b0, 0x03b1, 0x03c0, 
0x03c2, 0x03c3, 0x03cc, 0x03cd, 0x03d0, 0x03d1, 0x03d2, 0x03d5, 
0x03d6, 0x03d7, 0x03da, 0x03f0, 0x03f1, 0x03f2, 0x03f3, 0x0400, 
0x0410, 0x0420, 0x0430, 0x0440, 0x0450, 0x0460, 0x0482, 0x048c, 
0x04c0, 0x04c1, 0x04d0, 0x0531, 0x0559, 0x0561, 0x0587, 0x1e00, 
0x1e96, 0x1e9b, 0x1ea0, 0x1f00, 0x1f08, 0x1f10, 0x1f18, 0x1f20, 
0x1f28, 0x1f30, 0x1f38, 0x1f40, 0x1f48, 0x1f50, 0x1f51, 0x1f52, 
0x1f53, 0x1f54, 0x1f55, 0x1f56, 0x1f57, 0x1f59, 0x1f60, 0x1f68, 
0x1f70, 0x1f72, 0x1f76, 0x1f78, 0x1f7a, 0x1f7c, 0x1f80, 0x1f88, 
0x1f90, 0x1f98, 0x1fa0, 0x1fa8, 0x1fb0, 0x1fb2, 0x1fb3, 0x1fb4, 
0x1fb8, 0x1fba, 0x1fbc, 0x1fbd, 0x1fbe, 0x1fbf, 0x1fc3, 0x1fc4, 
0x1fc8, 0x1fcc, 0x1fcd, 0x1fd0, 0x1fd2, 0x1fd8, 0x1fda, 0x1fdd, 
0x1fe0, 0x1fe2, 0x1fe5, 0x1fe6, 0x1fe8, 0x1fea, 0x1fec, 0x1fed, 
0x1ff3, 0x1ff4, 0x1ff8, 0x1ffa, 0x1ffc, 0x1ffd, 0x2126, 0x2127, 
0x212a, 0x212b, 0x212c, 0x2160, 0x2180, 0x24b6, 0x24d0, 0x24ea, 
0xff21, 0xff3b, 0xff41, 0xff5b  })), (string) ({
0x0000, 0x0041, 0x005b, 0x0041, 0x007b, 0x039c, 0x00b6, 0x00c0, 
0x00d7, 0x00d8, 0x00df, 0x00c0, 0x00f7, 0x00d8, 0x0178, 0x0100, 
0x0130, 0x0049, 0x0132, 0x0138, 0x0139, 0x0149, 0x014a, 0x0178, 
0x0179, 0x0053, 0x0180, 0x0181, 0x0182, 0x0186, 0x0187, 0x0189, 
0x018b, 0x018d, 0x018e, 0x018f, 0x0190, 0x0191, 0x0193, 0x0194, 
0x01f6, 0x0196, 0x0197, 0x0198, 0x019a, 0x019c, 0x019d, 0x019e, 
0x019f, 0x01a0, 0x01a6, 0x01a7, 0x01a9, 0x01aa, 0x01ac, 0x01ae, 
0x01af, 0x01b1, 0x01b3, 0x01b7, 0x01b8, 0x01ba, 0x01bc, 0x01be, 
0x01f7, 0x01c0, 0x01c4, 0x01c5, 0x01c7, 0x01c8, 0x01ca, 0x01cb, 
0x018e, 0x01de, 0x01f0, 0x01f1, 0x01f2, 0x01f6, 0x01f7, 0x01f8, 
0x0250, 0x0181, 0x0186, 0x0255, 0x0189, 0x0258, 0x018f, 0x025a, 
0x0190, 0x025c, 0x0193, 0x0261, 0x0194, 0x0264, 0x0197, 0x0196, 
0x026a, 0x019c, 0x0270, 0x019d, 0x0273, 0x019f, 0x0276, 0x01a6, 
0x0281, 0x01a9, 0x0284, 0x01ae, 0x0289, 0x01b1, 0x028c, 0x01b7, 
0x0293, 0x0399, 0x0346, 0x0386, 0x0387, 0x0388, 0x038c, 0x038e, 
0x0390, 0x0391, 0x03a0, 0x0386, 0x0388, 0x03b0, 0x0391, 0x03a0, 
0x03a3, 0x03a3, 0x038c, 0x038e, 0x0392, 0x0398, 0x03d2, 0x03a6, 
0x03a0, 0x03d7, 0x03da, 0x039a, 0x03a1, 0x03a3, 0x03f3, 0x0400, 
0x0410, 0x0420, 0x0410, 0x0420, 0x0400, 0x0460, 0x0482, 0x048c, 
0x04c0, 0x04c1, 0x04d0, 0x0531, 0x0559, 0x0531, 0x0587, 0x1e00, 
0x1e96, 0x1e60, 0x1ea0, 0x1f08, 0x1f08, 0x1f18, 0x1f18, 0x1f28, 
0x1f28, 0x1f38, 0x1f38, 0x1f48, 0x1f48, 0x1f50, 0x1f59, 0x1f52, 
0x1f5b, 0x1f54, 0x1f5d, 0x1f56, 0x1f5f, 0x1f59, 0x1f68, 0x1f68, 
0x1fba, 0x1fc8, 0x1fda, 0x1ff8, 0x1fea, 0x1ffa, 0x1f88, 0x1f88, 
0x1f98, 0x1f98, 0x1fa8, 0x1fa8, 0x1fb8, 0x1fb2, 0x1fbc, 0x1fb4, 
0x1fb8, 0x1fba, 0x1fbc, 0x1fbd, 0x0399, 0x1fbf, 0x1fcc, 0x1fc4, 
0x1fc8, 0x1fcc, 0x1fcd, 0x1fd8, 0x1fd2, 0x1fd8, 0x1fda, 0x1fdd, 
0x1fe8, 0x1fe2, 0x1fec, 0x1fe6, 0x1fe8, 0x1fea, 0x1fec, 0x1fed, 
0x1ffc, 0x1ff4, 0x1ff8, 0x1ffa, 0x1ffc, 0x1ffd, 0x2126, 0x2127, 
0x212a, 0x212b, 0x212c, 0x2160, 0x2180, 0x24b6, 0x24b6, 0x24ea, 
0xff21, 0xff3b, 0xff21, 0xff5b  }))


// - values
test_equal(values("foo"),({'f','o','o'}))
test_equal(values(({'f','o','o'})),({'f','o','o'}))
test_equal(Array.sort_array(values(([7:3,8:9,99:12]))),({3,9,12}))
test_equal(values((<7,8,99>)),({1,1,1}))
test_equal(mkmultiset(values(class{ constant a="a"; constant b="b";}())),
           (<"a","b">))

// - zero_type
test_eq(zero_type(0),0)
test_eq(zero_type(([])[7]),1)

test_true([[lambda (int|void a) { return zero_type(a); }()]])
test_true([[lambda () {mixed a; return zero_type(a = ([])[0]);}()]])
test_true([[lambda () {mapping a=([]); return zero_type(a[0] = ([])[0]);}()]])
test_true([[zero_type (lambda () {return ([])[0];}())]])

test_program(int b=10; mixed a() { return 1; })
test_program(mixed b=10; mixed a() { return 1;})
test_define_program(test,[[int q,w,e,r,t; mixed foo() { return 10; }]])

test_program(inherit test; mixed a() { return foo()==10; })
test_program(inherit test; mixed a() { return test::foo()==10; })
test_program(inherit test : bar; mixed a() { return bar::foo()==10; })

test_define_program(test2,[[int z,x,c,v,b; mixed bar() { return 11; }]])
test_program(inherit test; inherit test2; mixed a() { return foo()==10 && bar()==11; })
test_program(inherit test2; inherit test; mixed a() { return foo()==10 && bar()==11; })

test_define_program(test,[[int q,w,e,r; mixed t; mixed getw() { return w; } void setw(int _) { w=_; }]])
test_define_program(test2,[[int z,x,c,v,b; mixed getb() { return b; } void setb(int _) { b=_; }]])

test_program(inherit test; inherit test2; mixed a() { w=20; b=22; return getw()==20 && getb()==22; })
test_program(inherit test; inherit test2; mixed a() { setw(20); setb(22); return w==20 && b==22; })
test_program(inherit test2; inherit test; mixed a() { w=20; b=22; return getw()==20 && getb()==22; })
test_program(inherit test2; inherit test; mixed a() { setw(20); setb(22); return w==20 && b==22; })

test_eval_error(return clone(class c{int i;void foo(){ destruct(this_object());i=0;return i;}})->foo())

// Pike modules

// - this failed in Calendar.Timezone

test_compile( 
[[
   array tz_ux(int ux)
   {
      if (ux<-0x80000000 || ux>0x7fffffff)
	 error("bah\n");
      return ({}); 
   };
]]);

// - Calendar
test_true(Calendar.Day())

// the more elaborate tests
test_eq([[
// note: *every* time the Calendar tests have failed, it's not the 
//       Calendar module that had any errors. Please don't commit 
//       your Pike until you've got Calendar to compile again. /Mirar
Calendar.Gregorian.Day(2500000)->month_day()]],31)
test_eq([[
// note: *every* time the Calendar tests have failed, it's not the 
//       Calendar module that had any errors. Please don't commit 
//       your Pike until you've got Calendar to compile again. /Mirar
Calendar.ISO.Day(2500000)->month_day()]],31)
test_eq([[
// note: *every* time the Calendar tests have failed, it's not the 
//       Calendar module that had any errors. Please don't commit 
//       your Pike until you've got Calendar to compile again. /Mirar
Calendar.Julian.Day(2500000)->month_day()]],17)
test_eq([[
// note: *every* time the Calendar tests have failed, it's not the 
//       Calendar module that had any errors. Please don't commit 
//       your Pike until you've got Calendar to compile again. /Mirar
(int)(Calendar.Stardate.Tick("julian",2500000)->tic())]],-190335)

// - Filesystem

test_true([[
  object fs=Filesystem.System();
  return 1;
]])

// - LR
test_program([[ object(LR.parser) p=LR.Grammar_parser.make_parser("foo : bar;foo : foo bar;bar : \"a\";"); int pos; array(string) data="aaaaaaaaa"/""; string scan() { if (pos < sizeof(data)) return(data[pos++]); else return ""; } int a() { return(p->parse(scan) == "a"); }]])

// - ADT
test_true(ADT.Table.table( ({ ({ "a", "b", 42 }), ({ "c", "b", 41 }), ({ "a", "a", 76 }) }), ({ "X", "Y", "z" }))->select("x", 2)->sum("Z")->distinct(0)->rsort("X")->rename(0, "fOo")->sort("foO")->cast("array"), ({ ({ "a", 118 }), ({ "c", 41 }) }))

// - Process
test_equal([[Process.split_quoted_string("test ")]],[[({"test"})]])
test_equal([[Process.split_quoted_string("'test'")]],[[({"test"})]])
test_equal([[Process.split_quoted_string("foo 'test' bar")]],[[({"foo","test","bar"})]])
test_equal([[Process.split_quoted_string("pike -m master.pike 'write(\"test\");'")]],[[({"pike","-m","master.pike","write(\"test\");"})]])
test_false([[Process.system(RUNPIKE +" -e 'exit(0)'")]])
test_true([[Process.system(RUNPIKE+" -e 'exit(1)'")]])
test_any([[object p=Process.create_process(Process.split_quoted_string(RUNPIKE)+({"-e","exit(2)"})); sleep(10); return p->wait()]],2)
test_eq([[Process.popen(RUNPIKE+" -e 'write(\"test\");'")]],"test")
test_any([[object o=Stdio.File(); object o2=o->pipe(Stdio.PROP_IPC); object p=Process.create_process(Process.split_quoted_string(RUNPIKE)+({"-e","exit(Stdio.stdin->read(5)==\"hello\")"}),(["stdin":o])); o2->write("hello"); destruct(o); destruct(o2); return p->wait()]],1)
test_any([[object o=Stdio.File(); object o2=o->pipe(Stdio.PROP_IPC); object p=Process.create_process(Process.split_quoted_string(RUNPIKE)+({"-e","exit(Stdio.stdin->read(1000)==\"hello\")"}),(["stdin":o])); o2->write("hello"); destruct(o); destruct(o2); return p->wait()]],1)
test_any([[object o=Stdio.Fd();   object o2=o->pipe(Stdio.PROP_IPC); object p=Process.create_process(Process.split_quoted_string(RUNPIKE)+({"-e","exit(Stdio.stdin->read(1000)==\"hello\")"}),(["stdin":o])); o2->write("hello"); destruct(o); destruct(o2); return p->wait()]],1)
test_any([[object o=Stdio.Fd();   object o2=o->pipe(Stdio.PROP_IPC); object p=Process.create_process(Process.split_quoted_string(RUNPIKE)+({"-e","exit(Stdio.stdin->read(1000)==\"hello\")"}),(["stdin":o])); o2->write("hello"); destruct(o2); return p->wait()]],1)
test_any([[object o=Stdio.Fd();   object o2=o->pipe(Stdio.PROP_IPC); object p=Process.create_process(Process.split_quoted_string(RUNPIKE)+({"-e","exit(Stdio.stdin->read(1000)==\"hello\")"}),(["stdin":o])); o2->write("hello"); o2=0; return p->wait()]],1)

test_any([[object o=Stdio.Fd();   object o2=o->pipe(); object p=Process.create_process(Process.split_quoted_string(RUNPIKE)+({"-e","exit(Stdio.stdin->read(5)==\"hello\")"}),(["stdin":o])); o2->write("hello"); destruct(o); destruct(o2); return p->wait()]],1)
test_any([[object o=Stdio.Fd();   object o2=o->pipe(); object p=Process.create_process(Process.split_quoted_string(RUNPIKE)+({"-e","exit(Stdio.stdin->read(1000)==\"hello\")"}),(["stdin":o])); o2->write("hello"); destruct(o); destruct(o2); return p->wait()]],1)
test_any([[object o=Stdio.Fd();   object o2=o->pipe(); object p=Process.create_process(Process.split_quoted_string(RUNPIKE)+({"-e","exit(Stdio.File(\"stdin\")->read(1000)==\"hello\")"}),(["stdin":o])); o2->write("hello"); destruct(o); destruct(o2); return p->wait()]],1)
test_any([[object o=Stdio.File(); object o2=o->pipe(); object p=Process.create_process(Process.split_quoted_string(RUNPIKE)+({"-e","exit(Stdio.File(\"stdin\")->read(1000)==\"hello\")"}),(["stdin":o])); o2->write("hello"); destruct(o); destruct(o2); return p->wait()]],1)
test_any([[object o=Stdio.File(); object o2=o->pipe(Stdio.PROP_IPC); object p=Process.create_process(Process.split_quoted_string(RUNPIKE)+({"-e","exit(Stdio.stdin->read(1000)==\"hello\")"}),(["stdin":o])); o2->write("hello"); destruct(o); destruct(o2); return p->wait()]],1)
test_any([[object o=Stdio.File(); object o2=o->pipe(Stdio.PROP_BIDIRECTIONAL); object p=Process.create_process(Process.split_quoted_string(RUNPIKE)+({"-e","exit(Stdio.stdin->read(1000)==\"hello\")"}),(["stdin":o2])); o->write("hello"); destruct(o); destruct(o2); return p->wait()]],1)

cond([[ file_stat("/bin/cat") && file_stat("/dev/null") && (cpp("__NT__")/"\n")[1]=="__NT__" ]],
[[
  test_false(Process.create_process(({"/bin/cat","/dev/null"}))->wait());
  test_false(Process.create_process(({"/bin/cat","/dev/null"}))->wait());
  test_false(Process.create_process(({"/bin/cat","/dev/null"}))->wait());
  
  test_any([[
    object o=Process.create_process(({"/bin/cat","/dev/null"}));
    if(Process.create_process(({"/bin/cat","/dev/null"}))->wait()) return 99;
    sleep(1);
    return kill(o->pid(), 9);
  ]],0);

  dnl Some OSs have a delay before PIDs are reused.
  dnl Be nice, and let them reuse some.
  test_do([[ sleep(2); ]]);
  test_any([[ for(int x=0;x<10;x++) { for(int e=0;e<100;e++) if(Process.create_process(({"/bin/cat","/dev/null"}))->wait()) return e; __signal_watchdog(); } return -1;]],-1)
]])

cond([[ file_stat("/bin/cat") && file_stat("/dev/null") && all_constants()->thread_create &&  (cpp("__NT__")/"\n")[1]=="__NT__" ]],
[[
  test_any([[return allocate(10,thread_create)(lambda() { for(int x=0;x<10;x++) { for(int e=0;e<50;e++) if(Process.create_process(({"/bin/cat","/dev/null"}))->wait()) return e; __signal_watchdog(); } return -1;})->wait() - ({-1})]],({}))
]])

cond([[ file_stat("/bin/cat") && file_stat("/dev/null") && all_constants()->thread_create &&  (cpp("__NT__")/"\n")[1]=="__NT__" ]],
[[
  test_do([[
  for(int q=0;q<100;q++)
  {
    array fnord=({});
    Thread.Fifo fifo=Thread.Fifo();

    for(int e=0;e<10;e++)
    {
      fnord+=({ thread_create(lambda() {
        	  Process.create_process(({"/bin/cat","/dev/null"}));
        	  fifo->read();
	        })
	      });
    }
    for(int e=0;e<50;e++)  Stdio.Port()->bind(0);
    for(int e=0;e<10;e++) fifo->write(1);
    fnord->wait();
    __signal_watchdog();
  }
  ]])
]])

cond([[ file_stat("/bin/sleep")  && all_constants()->thread_create &&  (cpp("__NT__")/"\n")[1]=="__NT__" ]],
[[
test_any([[
  class Fnord
  {
int gnapp(int t)
{
  int e;
  for(e=0;e<7;e++)
  {
    for(int d=0;d<150;d++)
    {
      object o=Process.create_process(({"/bin/sleep","99999"}));
      kill( o->pid(), 9 );
      o->wait();
    }
    __signal_watchdog();
//    werror("%d",t);
  }
  return -1;
}

array start()
{
  array a=({});
  for(int e=0;e<10;e++)
    a+=({thread_create(gnapp,e)});
  return a;
}
};

return Fnord()->start()->wait()-({ -1 });
]],[[ ({}) ]])
]])

// - Array
test_equal(Array.splice(({7,8,99}),({"h","h",99})),
	({7,"h",8,"h",99,99}))
test_equal(Array.splice(({7,8}),({"h","h",99})),
	({7,"h",8,"h"}))
test_equal(Array.splice(({7,8,99}),({"h","h",99}),({"g",({"fg"}),97})),
	({7,"h","g",8,"h",({"fg"}),99,99,97}))
test_equal(Array.splice(({7,"foo"})),
	({7,"foo"}))
test_equal(Array.splice(),
	({}))
test_equal(Array.splice(({})),
	({}))

test_equal(Array.everynth("0123456789"/""),
  ({ "0", "2", "4", "6", "8"}))
test_equal(Array.everynth("0123456789"/"",3),
  ({ "0", "3", "6", "9"}))
test_equal(Array.everynth("0123456789"/"",3,4),
  ({ "4", "7"}))


test_equal(Array.transpose( ({ ({ 1,2,3}), ({4,5,6}) }) ),
	({ ({1,4}), ({2,5}), ({3,6}) }))

test_equal([[Array.transpose(({catch{throw(({""}));},({1,2})[1..]}))]],
	   [[ ({ ({ "", 2 }) }) ]])

// - Graphics
test_true(!Graphics.Graph.test()->main(1,({"test"})))

// - Yabu
test_true(!Yabu.test()->main(1,({"test"})))

// - Protocols.XMLRPC
test_true(!Protocols.XMLRPC.test()->main(1,({"test"})))

// - Standards.ISO639_2
test_equal(Standards.ISO639_2.get_language("swe"),"Swedish")
test_equal(Standards.ISO639_2.get_language("xxx"),0)
test_true(sizeof(Standards.ISO639_2.list_languages())>400)
test_egual(Standards.ISO639_2.map_639_1("sv"),"swe")
test_egual(Standards.ISO639_2.map_639_1("xx"),0)
test_true(sizeof(Standards.ISO639_2.list_639_1())==158)

// - Standards.URI
test_equal((string)Standards.URI("g:h",           "http://a/b/c/d;p?q"), "g:h")
test_equal((string)Standards.URI("g",             "http://a/b/c/d;p?q"), "http://a/b/c/g")
test_equal((string)Standards.URI("./g",           "http://a/b/c/d;p?q"), "http://a/b/c/g")
test_equal((string)Standards.URI("g/",            "http://a/b/c/d;p?q"), "http://a/b/c/g/")
test_equal((string)Standards.URI("/g",            "http://a/b/c/d;p?q"), "http://a/g")
test_equal((string)Standards.URI("//g",           "http://a/b/c/d;p?q"), "http://g")
test_equal((string)Standards.URI("?y",            "http://a/b/c/d;p?q"), "http://a/b/c/?y")
test_equal((string)Standards.URI("g?y",           "http://a/b/c/d;p?q"), "http://a/b/c/g?y")
test_equal((string)Standards.URI("#s",            "http://a/b/c/d;p?q"), "http://a/b/c/d;p?q#s")
test_equal((string)Standards.URI("g#s",           "http://a/b/c/d;p?q"), "http://a/b/c/g#s")
test_equal((string)Standards.URI("g?y#s",         "http://a/b/c/d;p?q"), "http://a/b/c/g?y#s")
test_equal((string)Standards.URI(";x",            "http://a/b/c/d;p?q"), "http://a/b/c/;x")
test_equal((string)Standards.URI("g;x",           "http://a/b/c/d;p?q"), "http://a/b/c/g;x")
test_equal((string)Standards.URI("g;x?y#s",       "http://a/b/c/d;p?q"), "http://a/b/c/g;x?y#s")
test_equal((string)Standards.URI(".",             "http://a/b/c/d;p?q"), "http://a/b/c/")
test_equal((string)Standards.URI("./",            "http://a/b/c/d;p?q"), "http://a/b/c/")
test_equal((string)Standards.URI("..",            "http://a/b/c/d;p?q"), "http://a/b/")
test_equal((string)Standards.URI("../",           "http://a/b/c/d;p?q"), "http://a/b/")
test_equal((string)Standards.URI("../g",          "http://a/b/c/d;p?q"), "http://a/b/g")
test_equal((string)Standards.URI("../..",         "http://a/b/c/d;p?q"), "http://a/")
test_equal((string)Standards.URI("../../",        "http://a/b/c/d;p?q"), "http://a/")
test_equal((string)Standards.URI("../../g",       "http://a/b/c/d;p?q"), "http://a/g")
test_equal((string)Standards.URI("../../../g",    "http://a/b/c/d;p?q"), "http://a/../g")
test_equal((string)Standards.URI("../../../../g", "http://a/b/c/d;p?q"), "http://a/../../g")
test_equal((string)Standards.URI("/./g",          "http://a/b/c/d;p?q"), "http://a/./g")
test_equal((string)Standards.URI("/../g",         "http://a/b/c/d;p?q"), "http://a/../g")
test_equal((string)Standards.URI("g.",            "http://a/b/c/d;p?q"), "http://a/b/c/g.")
test_equal((string)Standards.URI(".g",            "http://a/b/c/d;p?q"), "http://a/b/c/.g")
test_equal((string)Standards.URI("g..",           "http://a/b/c/d;p?q"), "http://a/b/c/g..")
test_equal((string)Standards.URI("..g",           "http://a/b/c/d;p?q"), "http://a/b/c/..g")
test_equal((string)Standards.URI("./../g",        "http://a/b/c/d;p?q"), "http://a/b/g")
test_equal((string)Standards.URI("./g/.",         "http://a/b/c/d;p?q"), "http://a/b/c/g/")
test_equal((string)Standards.URI("g/./h",         "http://a/b/c/d;p?q"), "http://a/b/c/g/h")
test_equal((string)Standards.URI("g/../h",        "http://a/b/c/d;p?q"), "http://a/b/c/h")
test_equal((string)Standards.URI("g;x=1/./y",     "http://a/b/c/d;p?q"), "http://a/b/c/g;x=1/y")
test_equal((string)Standards.URI("g;x=1/../y",    "http://a/b/c/d;p?q"), "http://a/b/c/y")
test_equal((string)Standards.URI("g?y/./x",       "http://a/b/c/d;p?q"), "http://a/b/c/g?y/./x")
test_equal((string)Standards.URI("g?y/../x",      "http://a/b/c/d;p?q"), "http://a/b/c/g?y/../x")
test_equal((string)Standards.URI("g#s/./x",       "http://a/b/c/d;p?q"), "http://a/b/c/g#s/./x")
test_equal((string)Standards.URI("g#s/../x",      "http://a/b/c/d;p?q"), "http://a/b/c/g#s/../x")
test_equal((string)Standards.URI("http:g",        "http://a/b/c/d;p?q"), "http:g")


// - Colors
test_equal(Colors.parse_color("red"),({255,0,0}))
test_equal(Colors.parse_color("RED"),({255,0,0}))
test_equal(Colors.parse_color("lightred"),({255,61,61}))
test_equal(Colors.parse_color("LIGHT RED"),({255,61,61}))
test_equal(Colors.parse_color("#ff0000"),({255,0,0}))
test_equal(Colors.parse_color("ff0000"),({255,0,0}))
test_equal(Colors.parse_color("@0,255,255"),({255,0,0}))
test_equal(Colors.parse_color("%0,100,100,0"),({255,0,0}))
test_equal(Colors.rgb_to_hsv(255,0,0),({0,255,255}))
test_equal(Colors.hsv_to_rgb(0,255,255),({255,0,0}))
test_equal(Colors.rgb_to_cmyk(255,0,0),({0,100,100,0}))
test_equal(Colors.cmyk_to_rgb(0,100,100,0),({255,0,0}))

test_do([[
  string s;
  for(s="foobar";strlen(s)<78;s+=s)
  {
    for(int e=0;e<strlen(s);e++)
    {
      s[e]++;
    }
  }
]])

test_any([[string s="foo"; s[2]='t'; s[0]--; return s;]],"eot")
test_any([[string s="foo"; s[2]=0777; s[1]--; return s;]],"fn\777")
test_any([[string s="foo"; s[2]=07777777; s[1]--; return s;]],"fn\7777777")

cond([[all_constants()->_verify_internals]],
[[
  test_do(_verify_internals())
]])

test_program([[
int ok=1;

void test_resolv(string file, int base_size)
{
  string prg = replace( file[base_size+1..sizeof(file)-6],
			([ "/":".", ".pmod":""]) );
  if(prg[sizeof(prg)-7..]==".module")
    prg = prg[..sizeof(prg)-8];
  // werror("Resolving %O...\n", prg);
  if( catch( master()->resolv(prg) ) ) {
    werror("test: failed to peek at %O\n", prg);
    ok=0;
  }
}

void test_dir(string dir, int|void base_size)
{
  // werror("Testing directory %O...\n", dir);
  if(!base_size) base_size=sizeof(dir);
  foreach(get_dir(dir), string s)
  {
    switch(s)
    {
      case "db":	// Protocols.pmod/X.pmod/db
      case "frontbase.pike":
      case "msql.pike":
      case "mysql.pike":
      case "odbc.pike":
      case "oracle.pike":
      case "postgres.pike":
      case "sybase.pike":
#if !constant(GTK.Window)
      case "GTKSupport.pmod":
      case "PV.pike":
#endif
        continue; // These modules cannot be tested properly by this test
    }
    string file=combine_path(dir,s);
    mixed stat=file_stat(file);
    if(!stat) continue;
    if(stat[1]==-2)
    {
      if (glob("*.pmod", file)) {
        test_resolv(file, base_size);
      }
      test_dir(file, base_size);
    }else if(stat[1]>=0){
      // werror("Testing file %O\n", file);
      if(!glob("*/my_struct.pmod",file))
      {
        if(glob("*.pike",file) || glob("*.pmod",file))
        {
	   mixed err=catch { (program)file; };
	   if (err) 
           {
	      werror("test: failed to compile %O\n",file);
              ok=0;
              continue;
           }
	   test_resolv(file, base_size);
        }
      }
    }
  }
}
int a()
{
  Array.map(master()->pike_module_path,test_dir);
  return ok;
}
]])

// - modifiers, compile time type checks

test_compile_any(class A {int v;} class B {inherit A; int v;})
test_compile_error_low(class A {int v;} class B {inherit A; float v;})
dnl test_compile_error_low(class A {int v;} class B {inherit A; mixed v;})
dnl test_compile_error_low(class A {mixed v;} class B {inherit A; int v;})
dnl test_compile_error_low(class A {public int v;} class B {inherit A; mixed v;})
dnl test_compile_error_low(class A { public { int v; } } class B {inherit A; mixed v;})
dnl test_compile_error_low(class A {public mixed v;} class B {inherit A; int v;})
test_compile_error_low(class A {static int v;} class B {inherit A; float v;})
dnl test_compile_error_low(class A {static int v;} class B {inherit A; mixed v;})
dnl test_compile_error_low(class A {static mixed v;} class B {inherit A; int v;})
test_compile_any(class A {private int v;} class B {inherit A; float v;})
dnl test_compile_any(class A {private int v;} class B {inherit A; mixed v;})
dnl test_compile_any(class A {private mixed v;} class B {inherit A; int v;})
test_compile_error_low(class A {final int v;} class B {inherit A; int v;})
test_compile_error_low(class A {final int v;} class B {inherit A; final int v;})
test_compile_error_low(class A {nomask int v;} class B {inherit A; int v;})
test_compile_error_low(class A {nomask int v;} class B {inherit A; nomask int v;})
test_compile_any(class A {local int v;} class B {inherit A; float v;})
test_compile_any(class A {local int v;} class B {inherit A; mixed v;})
test_compile_any(class A {local mixed v;} class B {inherit A; int v;})
test_compile_any(class A {inline int v;} class B {inherit A; float v;})
test_compile_any(class A {inline int v;} class B {inherit A; mixed v;})
test_compile_any(class A {inline mixed v;} class B {inherit A; int v;})

test_compile_any(class A {int f(){}} class B {inherit A; int f(){}})
test_compile_any(class A {int f(){}} class B {inherit A; float f(){}})
test_compile_any(class A {int f(){}} class B {inherit A; mixed f(){}})
test_compile_any(class A {mixed f(){}} class B {inherit A; int f(){}})
test_compile_any(class A {void f(){}} class B {inherit A; void f(int a){}})
test_compile_any(class A {void f(int a){}} class B {inherit A; void f(float a){}})
test_compile_any(class A {void f(int a){}} class B {inherit A; void f(mixed a){}})
test_compile_any(class A {void f(mixed a){}} class B {inherit A; void f(int a){}})
test_compile_error_low(class A {final int f(){}} class B {inherit A; int f(){}})
test_compile_error_low(class A {final int f(){}} class B {inherit A; final int f(){}})
test_compile_error_low(class A {nomask int f(){}} class B {inherit A; int f(){}})
test_compile_error_low(class A {nomask int f(){}} class B {inherit A; nomask int f(){}})

test_compile(class A {int v;}; class B {inherit A; int v(){}})
test_compile(class A {public int v;}; class B {inherit A; int v(){}})
test_compile(class A {static int v;}; class B {inherit A; int v(){}})
test_compile_any(class A {private int v;} class B {inherit A; int v(){}})
test_compile_error_low(class A {final int v;} class B {inherit A; int v(){}})
test_compile_error_low(class A {nomask int v;} class B {inherit A; int v(){}})
test_compile_any(class A {local int v;} class B {inherit A; int v(){}})
test_compile_any(class A {inline int v;} class B {inherit A; int v(){}})

test_compile_error_low(class A {int f(){}} class B {inherit A; int f;})
test_compile_error_low(class A {public int f(){}} class B {inherit A; int f;})
test_compile_error_low(class A {static int f(){}} class B {inherit A; int f;})
test_compile_any(class A {private int f(){}} class B {inherit A; int f;})
test_compile_error_low(class A {final int f(){}} class B {inherit A; int f;})
test_compile_error_low(class A {nomask int f(){}} class B {inherit A; int f;})
test_compile_any(class A {local int f(){}} class B {inherit A; int f;})
test_compile_any(class A {inline int f(){}} class B {inherit A; int f;})

// - modifiers, compile time access properties

test_compile_error_low(class A {} class B {inherit A; int q; void g(){q=v;}})
test_compile_any(class A {int v;} class B {inherit A; int q; void g(){q=v;}})
test_compile_any(class A {public int v;} class B {inherit A; int q; void g(){q=v;}})
test_compile_any(class A {static int v;} class B {inherit A; int q; void g(){q=v;}})
test_compile_error_low(class A {private int v;} class B {inherit A; int q; void g(){q=v;}})
test_compile_any(class A {final int v;} class B {inherit A; int q; void g(){q=v;}})
test_compile_any(class A {nomask int v;} class B {inherit A; int q; void g(){q=v;}})
test_compile_any(class A {local int v;} class B {inherit A; int q; void g(){q=v;}})
test_compile_any(class A {inline int v;} class B {inherit A; int q; void g(){q=v;}})
test_compile_any(class A {int f(){}} class B {inherit A; void g(){f();}})
test_compile_any(class A {public int f(){}} class B {inherit A; void g(){f();}})
test_compile_any(class A {static int f(){}} class B {inherit A; void g(){f();}})
test_compile_error_low(class A {private int f(){}} class B {inherit A; void g(){f();}})
test_compile_any(class A {final int f(){}} class B {inherit A; void g(){f();}})
test_compile_any(class A {nomask int f(){}} class B {inherit A; void g(){f();}})
test_compile_any(class A {local int f(){}} class B {inherit A; void g(){f();}})
test_compile_any(class A {inline int f(){}} class B {inherit A; void g(){f();}})

test_compile_any(class A {int v;} class B {public inherit A; int q; void g(){q=v;}})
test_compile_any(class A {int v;} class B {static inherit A; int q; void g(){q=v;}})
test_compile_any(class A {int v;} class B {private inherit A; int q; void g(){q=v;}})
test_compile_any(class A {int v;} class B {final inherit A; int q; void g(){q=v;}})
test_compile_any(class A {int v;} class B {nomask inherit A; int q; void g(){q=v;}})
test_compile_any(class A {int v;} class B {local inherit A; int q; void g(){q=v;}})
test_compile_any(class A {int v;} class B {inline inherit A; int q; void g(){q=v;}})
test_compile_any(class A {int f(){}} class B {public inherit A; void g(){f();}})
test_compile_any(class A {int f(){}} class B {static inherit A; void g(){f();}})
test_compile_any(class A {int f(){}} class B {private inherit A; void g(){f();}})
test_compile_any(class A {int f(){}} class B {final inherit A; void g(){f();}})
test_compile_any(class A {int f(){}} class B {nomask inherit A; void g(){f();}})
test_compile_any(class A {int f(){}} class B {local inherit A; void g(){f();}})
test_compile_any(class A {int f(){}} class B {inline inherit A; void g(){f();}})

test_compile_error_low(class A {} class B {inherit A; int q; void g(){q=A::v;}})
test_compile_any(class A {int v;} class B {inherit A; int q; void g(){q=A::v;}})
test_compile_any(class A {public int v;} class B {inherit A; int q; void g(){q=A::v;}})
test_compile_any(class A {static int v;} class B {inherit A; int q; void g(){q=A::v;}})
test_compile_error_low(class A {private int v;} class B {inherit A; int q; void g(){q=A::v;}})
test_compile_any(class A {final int v;} class B {inherit A; int q; void g(){q=A::v;}})
test_compile_any(class A {nomask int v;} class B {inherit A; int q; void g(){q=A::v;}})
test_compile_any(class A {local int v;} class B {inherit A; int q; void g(){q=A::v;}})
test_compile_any(class A {inline int v;} class B {inherit A; int q; void g(){q=A::v;}})
test_compile_any(class A {int f(){}} class B {inherit A; void g(){A::f();}})
test_compile_any(class A {public int f(){}} class B {inherit A; void g(){A::f();}})
test_compile_any(class A {static int f(){}} class B {inherit A; void g(){A::f();}})
test_compile_error_low(class A {private int f(){}} class B {inherit A; void g(){A::f();}})
test_compile_any(class A {final int f(){}} class B {inherit A; void g(){A::f();}})
test_compile_any(class A {nomask int f(){}} class B {inherit A; void g(){A::f();}})
test_compile_any(class A {local int f(){}} class B {inherit A; void g(){A::f();}})
test_compile_any(class A {inline int f(){}} class B {inherit A; void g(){A::f();}})

test_compile_any(class A {int v;} class B {public inherit A; int q; void g(){q=A::v;}})
test_compile_any(class A {int v;} class B {static inherit A; int q; void g(){q=A::v;}})
test_compile_any(class A {int v;} class B {private inherit A; int q; void g(){q=A::v;}})
test_compile_any(class A {int v;} class B {final inherit A; int q; void g(){q=A::v;}})
test_compile_any(class A {int v;} class B {nomask inherit A; int q; void g(){q=A::v;}})
test_compile_any(class A {int v;} class B {local inherit A; int q; void g(){q=A::v;}})
test_compile_any(class A {int v;} class B {inline inherit A; int q; void g(){q=A::v;}})
test_compile_any(class A {int f(){}} class B {public inherit A; void g(){A::f();}})
test_compile_any(class A {int f(){}} class B {static inherit A; void g(){A::f();}})
test_compile_any(class A {int f(){}} class B {private inherit A; void g(){A::f();}})
test_compile_any(class A {int f(){}} class B {final inherit A; void g(){A::f();}})
test_compile_any(class A {int f(){}} class B {nomask inherit A; void g(){A::f();}})
test_compile_any(class A {int f(){}} class B {local inherit A; void g(){A::f();}})
test_compile_any(class A {int f(){}} class B {inline inherit A; void g(){A::f();}})

test_compile_error_low(class A {} class B {inherit A;} class C {inherit B; int q; void g(){q=B::v;}})
test_compile_any(class A {int v;} class B {inherit A;} class C {inherit B; int q; void g(){q=B::v;}})
test_compile_any(class A {int v;} class B {public inherit A;} class C {inherit B; int q; void g(){q=B::v;}})
test_compile_any(class A {int v;} class B {static inherit A;} class C {inherit B; int q; void g(){q=B::v;}})
test_compile_error_low(class A {int v;} class B {private inherit A;} class C {inherit B; int q; void g(){q=B::v;}})
test_compile_any(class A {int v;} class B {final inherit A;} class C {inherit B; int q; void g(){q=B::v;}})
test_compile_any(class A {int v;} class B {nomask inherit A;} class C {inherit B; int q; void g(){q=B::v;}})
test_compile_any(class A {int v;} class B {local inherit A;} class C {inherit B; int q; void g(){q=B::v;}})
test_compile_any(class A {int v;} class B {inline inherit A;} class C {inherit B; int q; void g(){q=B::v;}})
test_compile_any(class A {int f(){}} class B {inherit A;} class C {inherit B; void g(){B::f();}})
test_compile_any(class A {int f(){}} class B {public inherit A;} class C {inherit B; void g(){B::f();}})
test_compile_any(class A {int f(){}} class B {static inherit A;} class C {inherit B; void g(){B::f();}})
test_compile_error_low(class A {int f(){}} class B {private inherit A;} class C {inherit B; void g(){B::f();}})
test_compile_any(class A {int f(){}} class B {final inherit A;} class C {inherit B; void g(){B::f();}})
test_compile_any(class A {int f(){}} class B {nomask inherit A;} class C {inherit B; void g(){B::f();}})
test_compile_any(class A {int f(){}} class B {local inherit A;} class C {inherit B; void g(){B::f();}})
test_compile_any(class A {int f(){}} class B {inline inherit A;} class C {inherit B; void g(){B::f();}})

// - modifiers, run time access properties

test_eval_error(return class {}()->f())
test_do(class {int f(){}}()->f())
test_do(class {public int f(){}}()->f())
test_eval_error(return class {static int f(){}}()->f())
test_eval_error(return class {private int f(){}}()->f())
test_do(class {final int f(){}}()->f())
test_do(class {nomask int f(){}}()->f())
test_do(class {local int f(){}}()->f())
test_do(class {inline int f(){}}()->f())
test_do(class {class A {}}()->A())
test_do(class {public class A {}}()->A())
test_eval_error(return class {static class A {}}()->A())
test_eval_error(return class {private class A {}}()->A())
test_do(class {final class A {}}()->A())
test_do(class {nomask class A {}}()->A())
test_do(class {local class A {}}()->A())
test_do(class {inline class A {}}()->A())

test_equal(indices(class {}()), ({}))
test_equal(indices(class {int v;}()), ({"v"}))
test_equal(indices(class {public int v;}()), ({"v"}))
test_equal(indices(class {static int v;}()), ({}))
test_equal(indices(class {private int v;}()), ({}))
test_equal(indices(class {final int v;}()), ({"v"}))
test_equal(indices(class {nomask int v;}()), ({"v"}))
test_equal(indices(class {local int v;}()), ({"v"}))
test_equal(indices(class {inline int v;}()), ({"v"}))
test_equal(indices(class {int f(){}}()), ({"f"}))
test_equal(indices(class {public int f(){}}()), ({"f"}))
test_equal(indices(class {static int f(){}}()), ({}))
test_equal(indices(class {private int f(){}}()), ({}))
test_equal(indices(class {final int f(){}}()), ({"f"}))
test_equal(indices(class {nomask int f(){}}()), ({"f"}))
test_equal(indices(class {local int f(){}}()), ({"f"}))
test_equal(indices(class {inline int f(){}}()), ({"f"}))

test_equal(indices(class {class A {} class B {inherit A;}}()->B()), ({}))
test_equal(indices(class {class A {int v;} class B {inherit A;}}()->B()), ({"v"}))
test_equal(indices(class {class A {public int v;} class B {inherit A;}}()->B()), ({"v"}))
test_equal(indices(class {class A {static int v;} class B {inherit A;}}()->B()), ({}))
test_equal(indices(class {class A {private int v;} class B {inherit A;}}()->B()), ({}))
test_equal(indices(class {class A {final int v;} class B {inherit A;}}()->B()), ({"v"}))
test_equal(indices(class {class A {nomask int v;} class B {inherit A;}}()->B()), ({"v"}))
test_equal(indices(class {class A {local int v;} class B {inherit A;}}()->B()), ({"v"}))
test_equal(indices(class {class A {inline int v;} class B {inherit A;}}()->B()), ({"v"}))
test_equal(indices(class {class A {int f(){}} class B {inherit A;}}()->B()), ({"f"}))
test_equal(indices(class {class A {public int f(){}} class B {inherit A;}}()->B()), ({"f"}))
test_equal(indices(class {class A {static int f(){}} class B {inherit A;}}()->B()), ({}))
test_equal(indices(class {class A {private int f(){}} class B {inherit A;}}()->B()), ({}))
test_equal(indices(class {class A {final int f(){}} class B {inherit A;}}()->B()), ({"f"}))
test_equal(indices(class {class A {nomask int f(){}} class B {inherit A;}}()->B()), ({"f"}))
test_equal(indices(class {class A {local int f(){}} class B {inherit A;}}()->B()), ({"f"}))
test_equal(indices(class {class A {inline int f(){}} class B {inherit A;}}()->B()), ({"f"}))

test_equal(indices(class {class A {int v;} class B {public inherit A;}}()->B()), ({"v"}))
test_equal(indices(class {class A {int v;} class B {static inherit A;}}()->B()), ({}))
test_equal(indices(class {class A {int v;} class B {private inherit A;}}()->B()), ({}))
test_equal(indices(class {class A {int v;} class B {final inherit A;}}()->B()), ({"v"}))
test_equal(indices(class {class A {int v;} class B {nomask inherit A;}}()->B()), ({"v"}))
test_equal(indices(class {class A {int v;} class B {local inherit A;}}()->B()), ({"v"}))
test_equal(indices(class {class A {int v;} class B {inline inherit A;}}()->B()), ({"v"}))
test_equal(indices(class {class A {int f(){}} class B {public inherit A;}}()->B()), ({"f"}))
test_equal(indices(class {class A {int f(){}} class B {static inherit A;}}()->B()), ({}))
test_equal(indices(class {class A {int f(){}} class B {private inherit A;}}()->B()), ({}))
test_equal(indices(class {class A {int f(){}} class B {final inherit A;}}()->B()), ({"f"}))
test_equal(indices(class {class A {int f(){}} class B {nomask inherit A;}}()->B()), ({"f"}))
test_equal(indices(class {class A {int f(){}} class B {local inherit A;}}()->B()), ({"f"}))
test_equal(indices(class {class A {int f(){}} class B {inline inherit A;}}()->B()), ({"f"}))

test_equal(indices(class {class A {} class B {inherit A;} class C {inherit B;}}()->C()), ({}))
test_equal(indices(class {class A {int v;} class B {inherit A;} class C {inherit B;}}()->C()), ({"v"}))
test_equal(indices(class {class A {int v;} class B {public inherit A;} class C {inherit B;}}()->C()), ({"v"}))
test_equal(indices(class {class A {int v;} class B {static inherit A;} class C {inherit B;}}()->C()), ({}))
test_equal(indices(class {class A {int v;} class B {private inherit A;} class C {inherit B;}}()->C()), ({}))
test_equal(indices(class {class A {int v;} class B {final inherit A;} class C {inherit B;}}()->C()), ({"v"}))
test_equal(indices(class {class A {int v;} class B {nomask inherit A;} class C {inherit B;}}()->C()), ({"v"}))
test_equal(indices(class {class A {int v;} class B {local inherit A;} class C {inherit B;}}()->C()), ({"v"}))
test_equal(indices(class {class A {int v;} class B {inline inherit A;} class C {inherit B;}}()->C()), ({"v"}))
test_equal(indices(class {class A {int f(){}} class B {inherit A;} class C {inherit B;}}()->C()), ({"f"}))
test_equal(indices(class {class A {int f(){}} class B {public inherit A;} class C {inherit B;}}()->C()), ({"f"}))
test_equal(indices(class {class A {int f(){}} class B {static inherit A;} class C {inherit B;}}()->C()), ({}))
test_equal(indices(class {class A {int f(){}} class B {private inherit A;} class C {inherit B;}}()->C()), ({}))
test_equal(indices(class {class A {int f(){}} class B {final inherit A;} class C {inherit B;}}()->C()), ({"f"}))
test_equal(indices(class {class A {int f(){}} class B {nomask inherit A;} class C {inherit B;}}()->C()), ({"f"}))
test_equal(indices(class {class A {int f(){}} class B {local inherit A;} class C {inherit B;}}()->C()), ({"f"}))
test_equal(indices(class {class A {int f(){}} class B {inline inherit A;} class C {inherit B;}}()->C()), ({"f"}))

// - modifiers, binding and redefinition properties with compile time access

test_any(class A {int v=1;}; class B {inherit A; int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {public int v=1;}; class B {inherit A; int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {static int v=1;}; class B {inherit A; int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {private int v=1;}; class B {inherit A; int v=2; int t(){return v;}}; return B()->t(), 2)
test_compile_error_low(class A {final int v=1;}; class B {inherit A; int v=2;};)
test_compile_error_low(class A {nomask int v=1;}; class B {inherit A; int v=2;};)
test_any(class A {local int v=1;}; class B {inherit A; int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {inline int v=1;}; class B {inherit A; int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {int f(){return 1;}}; class B {inherit A; int f(){return 2;} int t(){return f();}}; return B()->t(), 2)
test_any(class A {public int f(){return 1;}}; class B {inherit A; int f(){return 2;} int t(){return f();}}; return B()->t(), 2)
test_any(class A {static int f(){return 1;}}; class B {inherit A; int f(){return 2;} int t(){return f();}}; return B()->t(), 2)
test_any(class A {private int f(){return 1;}}; class B {inherit A; int f(){return 2;} int t(){return f();}}; return B()->t(), 2)
test_compile_error_low(class A {final int f(){return 1;}}; class B {inherit A; int f(){return 2;}};)
test_compile_error_low(class A {nomask int f(){return 1;}}; class B {inherit A; int f(){return 2;}};)
test_any(class A {local int f(){return 1;}}; class B {inherit A; int f(){return 2;} int t(){return f();}}; return B()->t(), 2)
test_any(class A {inline int f(){return 1;}}; class B {inherit A; int f(){return 2;} int t(){return f();}}; return B()->t(), 2)

test_any(class A {int v=1;}; class B {public inherit A; int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {int v=1;}; class B {static inherit A; int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {int v=1;}; class B {private inherit A; int v=2; int t(){return v;}}; return B()->t(), 2)
test_compile_error_low(class A {int v=1;}; class B {final inherit A; int v=2;};)
test_compile_error_low(class A {int v=1;}; class B {nomask inherit A; int v=2;};)
test_any(class A {int v=1;}; class B {local inherit A; int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {int v=1;}; class B {inline inherit A; int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {int f(){return 1;}}; class B {public inherit A; int f(){return 2;} int t(){return f();}}; return B()->t(), 2)
test_any(class A {int f(){return 1;}}; class B {static inherit A; int f(){return 2;} int t(){return f();}}; return B()->t(), 2)
test_any(class A {int f(){return 1;}}; class B {private inherit A; int f(){return 2;} int t(){return f();}}; return B()->t(), 2)
test_compile_error_low(class A {int f(){return 1;}}; class B {final inherit A; int f(){return 2;}};)
test_compile_error_low(class A {int f(){return 1;}}; class B {nomask inherit A; int f(){return 2;}};)
test_any(class A {int f(){return 1;}}; class B {local inherit A; int f(){return 2;} int t(){return f();}}; return B()->t(), 2)
test_any(class A {int f(){return 1;}}; class B {inline inherit A; int f(){return 2;} int t(){return f();}}; return B()->t(), 2)

test_any(class A {int v=1;}; class B {inherit A; int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {int v=1;}; class B {inherit A; public int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {int v=1;}; class B {inherit A; static int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {int v=1;}; class B {inherit A; private int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {int v=1;}; class B {inherit A; final int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {int v=1;}; class B {inherit A; nomask int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {int v=1;}; class B {inherit A; local int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {int v=1;}; class B {inherit A; inline int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {int f(){return 1;}}; class B {inherit A; int f(){return 2;} int t(){return f();}}; return B()->t(), 2)
test_any(class A {int f(){return 1;}}; class B {inherit A; public int f(){return 2;} int t(){return f();}}; return B()->t(), 2)
test_any(class A {int f(){return 1;}}; class B {inherit A; static int f(){return 2;} int t(){return f();}}; return B()->t(), 2)
test_any(class A {int f(){return 1;}}; class B {inherit A; private int f(){return 2;} int t(){return f();}}; return B()->t(), 2)
test_any(class A {int f(){return 1;}}; class B {inherit A; final int f(){return 2;} int t(){return f();}}; return B()->t(), 2)
test_any(class A {int f(){return 1;}}; class B {inherit A; nomask int f(){return 2;} int t(){return f();}}; return B()->t(), 2)
test_any(class A {int f(){return 1;}}; class B {inherit A; local int f(){return 2;} int t(){return f();}}; return B()->t(), 2)
test_any(class A {int f(){return 1;}}; class B {inherit A; int f(){return 2;} int t(){return local::f();}}; return B()->t(), 2)
test_any(class A {int f(){return 1;}}; class B {inherit A; inline int f(){return 2;} int t(){return f();}}; return B()->t(), 2)

test_any(class A {int v=1; int t(){return v;}}; class B {inherit A; int v=2;}; return B()->t(), 2)
test_any(class A {public int v=1; int t(){return v;}}; class B {inherit A; int v=2;}; return B()->t(), 2)
test_any(class A {static int v=1; int t(){return v;}}; class B {inherit A; int v=2;}; return B()->t(), 2)
test_any(class A {private int v=1; int t(){return v;}}; class B {inherit A; int v=2;}; return B()->t(), 1)
test_any(class A {local int v=1; int t(){return v;}}; class B {inherit A; int v=2;}; return B()->t(), 1)
test_any(class A {inline int v=1; int t(){return v;}}; class B {inherit A; int v=2;}; return B()->t(), 1)
test_any(class A {int f(){return 1;} int t(){return f();}}; class B {inherit A; int f(){return 2;}}; return B()->t(), 2)
test_any(class A {public int f(){return 1;} int t(){return f();}}; class B {inherit A; int f(){return 2;}}; return B()->t(), 2)
test_any(class A {static int f(){return 1;} int t(){return f();}}; class B {inherit A; int f(){return 2;}}; return B()->t(), 2)
test_any(class A {private int f(){return 1;} int t(){return f();}}; class B {inherit A; int f(){return 2;}}; return B()->t(), 1)
test_any(class A {local int f(){return 1;} int t(){return f();}}; class B {inherit A; int f(){return 2;}}; return B()->t(), 1)
test_any(class A {int f(){return 1;} int t(){return local::f();}}; class B {inherit A; int f(){return 2;}}; return B()->t(), 1)
test_any(class A {inline int f(){return 1;} int t(){return f();}}; class B {inherit A; int f(){return 2;}}; return B()->t(), 1)

test_any(class A {int v=1; int t(){return v;}}; class B {inherit A; int v=2; int t(){return A::t();}}; return B()->t(), 2)
test_any(class A {int v=1; int t(){return v;}}; class B {public inherit A; int v=2; int t(){return A::t();}}; return B()->t(), 2)
test_any(class A {int v=1; int t(){return v;}}; class B {static inherit A; int v=2; int t(){return A::t();}}; return B()->t(), 2)
test_any(class A {int v=1; int t(){return v;}}; class B {private inherit A; int v=2; int t(){return A::t();}}; return B()->t(), 2)
test_any(class A {int v=1; int t(){return v;}}; class B {local inherit A; int v=2; int t(){return A::t();}}; return B()->t(), 1)
test_any(class A {int v=1; int t(){return v;}}; class B {inline inherit A; int v=2; int t(){return A::t();}}; return B()->t(), 1)
test_any(class A {int f(){return 1;} int t(){return f();}}; class B {inherit A; int f(){return 2;} int t(){return A::t();}}; return B()->t(), 2)
test_any(class A {int f(){return 1;} int t(){return f();}}; class B {public inherit A; int f(){return 2;} int t(){return A::t();}}; return B()->t(), 2)
test_any(class A {int f(){return 1;} int t(){return f();}}; class B {static inherit A; int f(){return 2;} int t(){return A::t();}}; return B()->t(), 2)
test_any(class A {int f(){return 1;} int t(){return f();}}; class B {private inherit A; int f(){return 2;} int t(){return A::t();}}; return B()->t(), 2)
test_any(class A {int f(){return 1;} int t(){return f();}}; class B {local inherit A; int f(){return 2;} int t(){return A::t();}}; return B()->t(), 1)
test_any(class A {int f(){return 1;} int t(){return f();}}; class B {inline inherit A; int f(){return 2;} int t(){return A::t();}}; return B()->t(), 1)

test_any([[
  class A {int v=0x100; int a(){return v;}}; class B {inherit A; int v=0x010; int b(){return v;}}; class C {inherit B; int v=0x001; int c(){return v;}};
  object c=C(); return c->a()+c->b()+c->c();
]], 0x003)
test_any([[
  class A {int v=0x100; int a(){return v;}}; class B {inherit A; public int v=0x010; int b(){return v;}}; class C {inherit B; int v=0x001; int c(){return v;}};
  object c=C(); return c->a()+c->b()+c->c();
]], 0x003)
test_any([[
  class A {int v=0x100; int a(){return v;}}; class B {inherit A; private int v=0x010; int b(){return v;}}; class C {inherit B; int v=0x001; int c(){return v;}};
  object c=C(); return c->a()+c->b()+c->c();
]], 0x021)
test_any([[
  class A {int v=0x100; int a(){return v;}}; class B {inherit A; static int v=0x010; int b(){return v;}}; class C {inherit B; int v=0x001; int c(){return v;}};
  object c=C(); return c->a()+c->b()+c->c();
]], 0x003)
test_any([[
  class A {int v=0x100; int a(){return v;}}; class B {inherit A; local int v=0x010; int b(){return v;}}; class C {inherit B; int v=0x001; int c(){return v;}};
  object c=C(); return c->a()+c->b()+c->c();
]], 0x021)
test_any([[
  class A {int v=0x100; int a(){return v;}}; class B {inherit A; inline int v=0x010; int b(){return v;}}; class C {inherit B; int v=0x001; int c(){return v;}};
  object c=C(); return c->a()+c->b()+c->c();
]], 0x021)

// - modifiers, binding and redefinition properties with run time access

test_any(class A {int v=1;}; class B {inherit A; int v=2;}; return B()->v, 2)
test_any(class A {public int v=1;}; class B {inherit A; int v=2;}; return B()->v, 2)
test_any(class A {static int v=1;}; class B {inherit A; int v=2;}; return B()->v, 2)
test_any(class A {private int v=1;}; class B {inherit A; int v=2;}; return B()->v, 2)
test_any(class A {local int v=1;}; class B {inherit A; int v=2;}; return B()->v, 2)
test_any(class A {inline int v=1;}; class B {inherit A; int v=2;}; return B()->v, 2)
test_any(class A {int f(){return 1;}}; class B {inherit A; int f(){return 2;}}; return B()->f(), 2)
test_any(class A {public int f(){return 1;}}; class B {inherit A; int f(){return 2;}}; return B()->f(), 2)
test_any(class A {static int f(){return 1;}}; class B {inherit A; int f(){return 2;}}; return B()->f(), 2)
test_any(class A {private int f(){return 1;}}; class B {inherit A; int f(){return 2;}}; return B()->f(), 2)
test_any(class A {local int f(){return 1;}}; class B {inherit A; int f(){return 2;}}; return B()->f(), 2)
test_any(class A {inline int f(){return 1;}}; class B {inherit A; int f(){return 2;}}; return B()->f(), 2)

test_any(class A {int v=1;}; class B {public inherit A; int v=2;}; return B()->v, 2)
test_any(class A {int v=1;}; class B {static inherit A; int v=2;}; return B()->v, 2)
test_any(class A {int v=1;}; class B {private inherit A; int v=2;}; return B()->v, 2)
test_any(class A {int v=1;}; class B {local inherit A; int v=2;}; return B()->v, 2)
test_any(class A {int v=1;}; class B {inline inherit A; int v=2;}; return B()->v, 2)
test_any(class A {int f(){return 1;}}; class B {public inherit A; int f(){return 2;}}; return B()->f(), 2)
test_any(class A {int f(){return 1;}}; class B {static inherit A; int f(){return 2;}}; return B()->f(), 2)
test_any(class A {int f(){return 1;}}; class B {private inherit A; int f(){return 2;}}; return B()->f(), 2)
test_any(class A {int f(){return 1;}}; class B {local inherit A; int f(){return 2;}}; return B()->f(), 2)
test_any(class A {int f(){return 1;}}; class B {inline inherit A; int f(){return 2;}}; return B()->f(), 2)

test_any(class A {int v=1;}; class B {inherit A; public int v=2;}; return B()->v, 2)
test_any(class A {int v=1;}; class B {inherit A; static int v=2;}; return B()->v, 0)
test_any(class A {int v=1;}; class B {inherit A; private int v=2;}; return B()->v, 0)
test_any(class A {int v=1;}; class B {inherit A; final int v=2;}; return B()->v, 2)
test_any(class A {int v=1;}; class B {inherit A; nomask int v=2;}; return B()->v, 2)
test_any(class A {int v=1;}; class B {inherit A; local int v=2;}; return B()->v, 2)
test_any(class A {int v=1;}; class B {inherit A; inline int v=2;}; return B()->v, 2)
test_any(class A {int f(){return 1;}}; class B {inherit A; public int f(){return 2;}}; return B()->f(), 2)
test_any(class A {int f(){return 1;}}; class B {inherit A; static int f(){return 2;}}; return B()->f, 0)
test_any(class A {int f(){return 1;}}; class B {inherit A; private int f(){return 2;}}; return B()->f, 0)
test_any(class A {int f(){return 1;}}; class B {inherit A; final int f(){return 2;}}; return B()->f(), 2)
test_any(class A {int f(){return 1;}}; class B {inherit A; nomask int f(){return 2;}}; return B()->f(), 2)
test_any(class A {int f(){return 1;}}; class B {inherit A; local int f(){return 2;}}; return B()->f(), 2)
test_any(class A {int f(){return 1;}}; class B {inherit A; inline int f(){return 2;}}; return B()->f(), 2)

test_any([[
class Fnord
{
  array gnzpp() { }
  constant fNord = 4711;

  class Bzonk
  {
    int xxxxx=17;
    int yyyyy=17;
    int zzzzz=17;

  }

  class Zboink
  {
    int pphfiztzz=1;
    inherit Bzonk;
    constant floingngg=fNord;
    array Zpfoooinginoooo() {}
    
    int t()
      {
	return fNord + fNord;
      }
    int z()
      {
	return floingngg + floingngg;
      }
  }
};
return Fnord()->Zboink()->t() + Fnord()->Zboink()->z();
]],4711 * 4)

test_any([[
  class Foo
  {
    string s = "a";

    int|string foo()
    {
      int i;
      for (; i < strlen(s); i++) {
        if (!strlen(s) && i) {
          return "Optimizer error!";
        }
        s = "";
        i = 0;
      }
      return 0;
    }
  };
  return Foo()->foo();
]], 0)

// - call_out, call_out_info, remove_call_out, find_call_out
test_do(add_constant("call_out_cb", a))
test_do(call_out(call_out_cb,100000))
test_true(call_out(lambda() {},1000.0))
test_true(remove_call_out(call_out(lambda() {},1000.0)) != -1)
test_true(find_call_out(call_out(lambda() {},1000.0)) > 990)
test_false(zero_type(remove_call_out(call_out(lambda() {},1000.0))))
test_true(arrayp(call_out_info()))
test_true(sizeof(call_out_info()) > 0)
test_true(call_out_info()[-1][0] > 1)
test_eq(find_call_out(call_out_info()[-1][2]), call_out_info()[-1][0])
test_eq(find_call_out(a),-1)
test_true(zero_type(find_call_out(a)))
test_true(!sizeof(call_out_info()) || function_name(call_out_info()[-1][2])!="call_out_cb")
test_do(remove_call_out(call_out_info()[-1][2]))
test_do(add_constant("call_out_cb"))
test_do(_do_call_outs())
test_false(Process.system(RUNPIKE+" SRCDIR/test_co.pike"))
test_do_([[ catch { _do_call_outs(); }]])

