Changes since Pike 7.4:
----------------------------------------------------------------------

New/improved functionality:
---------------------------

o rsif
    rsif can now work recursively in a file structure if given the
    flag -r or --recursive. Example:
      pike -x rsif -r 7.4 7.6

o The automatic garbage collection strategy is configurable
    The garbage collector can be configured to take both the amount of
    garbage and the cpu time spent in the gc into account. Automatic
    gc runs can also be disabled in critical regions. See the function
    Pike.gc_parameters.

o sort() is stable
    Unlike previous releases, sort() will keep the original order
    between elements that are equal. This was not implemented as a
    separate function since it could be done with virtually no extra
    overhead.

o sort() is portable
    Sort is now locale and platform independent. In other words,
    strings are now compared only according to the unicode value of
    every character.

o Reworked codec
    The codec for serialization of Pike data types has been updated
    and has a significally improved successrate at encoding modules.

o Less magic hacks
    Several Pike modules have been cleaned up from old hacks and
    workarounds for problems which now have proper solutions. This
    should improve size, performance, dumpability and readability
    of the affected code. In addition lots of internal types in Pike
    have been tightened up and several more files now use the pragma
    strict_types, which has resulted in some additional bugfixes.

o INT64
    On 64 bit architechtures Pike will now use full 64 bits integer
    before resorting to Gmp.mpz objects for large numbers.

o IPv6


Build baluns:
-------------
bundles


Language additions:
-------------------


New modules / classes / methods added:
--------------------------------------

o trace() can trace all threads
    The configure option --without-thread-trace has been removed, but
    instead the trace() function has been extended to make it possible
    to set the trace level in all threads simultaneously.

o Regexp.PCRE added to give libpcre support.
    Are you a closet-perlet? For those who missed the richer flora of
    regexp syntax that Perl supports, the Perl Compatible Regular
    Expression module is the answer. If you compile libpcre with UTF-8
    support you will also get transparent wide string support. Several
    convenience functions are also added to the Regexp module to
    enable easier access to regular expressions.

o Crypto/Nettle
    The crypto module has been almost completely rewritten and now
    uses libnettle as backend instead of the built in crypto
    algorithms that Pike had before. This way Pike will benefit from
    the more active development and optimization work in the Nettle
    project. The most common hash and cipher methods are already
    written in assembler for several platforms. As an example SHA1 is
    about 40% faster than before on Intel platforms.

    With the new nettle support comes support for two new cipher
    algorithms, Blowfish and Serpent, and the new NIST hash algorithm
    SHA256. Note that the new Crypto module has renamed its
    identifiers to be consistent with the rest of Pike, and in some
    cases to clarify or correct bad names. The old names still work,
    but produce a warning unless Pike is run in compatibility mode.
    Compatibility outside compatibility mode will be removed in the
    future.

    The interfaces for the hash and cipher algorithms has been
    improved and they no longer only conform to predefined interfaces,
    but actually inherits Hash/HashState and Cipher/CipherState. Every
    algorithm is in itself a module in the Crypto module, and inherits
    the Hash/Cipher class. This module contains instance non-specific
    methods such as digest_size or key_size. By calling the `() method
    in the module a HashState/CipherState object is returned, which is
    a hash/cipher instance which can be used for streaming operations.

    Examples:

      Crypto.MD5.hash("Hash this string");

      Crypto.MD5()->update("Hash this ")->update("string")->digest();

    The confusing and hard to use Crypto.randomness has been obsoleted
    by the Nettle implementation of the Yarrow random generator. The
    Nettle implementation of Yarrow uses AES and SHA256. The
    Crypto.Random module acts as a frontend before system crypto
    sources and ensure that no matter how bad your OS is, you will
    still get cryptographically strong random data.


o Crypto.PGP
    The start of a PGP/GPG toolkit. It still cannot handle all types
    of signatures nor generate any, but it is useful to verify
    selfsigned code and data.


o ADT.Struct
    This module makes it possible to work with binary formats of the
    packed-struct-type. Simply create a class and specify the members
    in order, create an object with a file object as argument and then
    read the decoded values from the object as ordinary variables.

      class ID3 {
        inherit ADT.Struct;
        Item head = Chars(3);
        Item title = Chars(30);
        Item artist = Chars(30);
        Item album = Chars(30);
        Item year = Chars(4);
        Item comment = Chars(30);
        Item genre = Byte();
      }

      Stdio.File f = Stdio.File("foo.mp3");
      f->seek(-128);
      ADT.Struct tag = ID3(f);
      if(tag->head=="TAG") {
        write("Title: %s\n", tag->title);
        tag->title = "A new title" + "\0"*19;
        f->seek(-128);
        f->write( (string)tag );
      }


o ADT.BitBuffer
    When operating on data formats that are defined on bit level, the
    ADT.BitBuffer presents a convenient interface. It operates as a
    FIFO buffer on bit level, which allows you to read and write bits
    and bytes.

      > ADT.BitBuffer b=ADT.BitBuffer();
      > b->put1(2);
      (1) Result: ADT.BitBuffer(11)
      > b->put0(15);
      (2) Result: ADT.BitBuffer("À\0"0)
      > b->drain();
      (3) Result: "À\0"
      > sizeof(b);
      (4) Result: 1


o Debug.Wrapper
    A simple litte wrapper that can be placed around another object to
    get printouts about what is happening to it. Only a few LFUNs are
    currently supported.

      > object x=Debug.Wrapper(Crypto.MD5());
      Debug.Wrapper is proxying ___Nettle.MD5_State()
      > x->name();
      ___Nettle.MD5_State()->name
      (1) Result: "md5"
      > !x;
      !___Nettle.MD5_State()
      (2) Result: 0


o Image.NEO
    Support for one of the major image formats on Atari ST/STE,
    including decoding of color cycling. The C bitmap and palette
    handler can be used to implement other atari image formats.



o _ADT
o Geography RT38
o Int
o Pike.Security
o Protocols.HTTP.Session
o Tools.Shoot/Standalone.benchmark
o Standalone.cgrep
o Standalone.dump
o Standalone.extract_locale
o Image.NEO
o Bz2
o Process.Process
o Error
o Float
o GLUE
o Protocols.Bittorrent
o Protocols.LMTP
o Web.RDF/RDFS/OWL/RSS
o Parser.RCS

Optimizations:
--------------

o Instantiation and destruction of pike-classes is now significantly faster.

o Handling of bignums has been optimized, especially conversion
  to/from normal integers.

o String case conversion is now five times faster than before on
  average.


Compatibility changes:
----------------------

Compatibility changes without backward compatibility:
-----------------------------------------------------

o Module ABI changed
  The pike_frame struct has a new member, which makes modules compiled
  with earlier versions of Pike incompatible.


C level/development changes:
----------------------------

o The security.h include file is renamed to pike_security.h

Bugs fixed:
-----------


Uncategorized misc changes:
---------------------------
