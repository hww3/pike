Changes since Pike 7.2:
----------------------------------------------------------------------

New/improved functionality:
---------------------------

o New Hilfe
    The interactive pike environment you get when running pike without
    giving a program name, has been thoroughly rewritten. Most notably
    it now supports more of the common pike constructs, and is more
    extendable and configurable. Start it and type help for more info.

o AutoDoc
    The major parts of Pike now has some sort of documentation on
    class and function level thanks to the AutoDoc system which has
    been deployed during the last year. Manual dumps are published on
    http://pike.ida.liu.se/docs/reference/

o pike -x
    When starting pike with the -x parameter, the pike process will
    run the named script in Tools.Standalone, giving the rest of the
    arguments as command-line switches. This is a convenient way of
    running rsif (replace string in file) and pv (the image viewer
    you may be familiar with from Tools.PV).

o unbug

o Unicode 3.2.0
    All charts have been updated to Unicode 3.2.0. This applies both to
    the Unicode module as well as to Pike-global functionality such as
    upper_case/lower_case. unicode_to_string() also has support for
    surrogate and byteorder make handling.

o Extended random()
    random() now works on floats, arrays, multisets, mappings and
    objects in addition to integers.

o delay()/sleep()
    sleep() no longer busywaits, which it previously did for small
    values. The old behaviour is available from the delay() function.

o search(string, int) / has_value(string, int)
    Both of these methods now handle both looking for strings and
    integers (the unicode number for a single character).
    Examples: search("hi, ho!", '!'), has_value("Nope.", ' ')

o Expanded Charset module
    The character set module now has support for the character sets
    Shift_JS, UTF-7.5, EUC, Big5, CP950, UTF-16, UTF-16BE, UTF-16LE.
    It is now also easier to get the right charset codec since the
    names are normalized internally.


Language additions:
-------------------

o foreach(X; Y; Z)
    The foreach statement has been extended to allow iterations over
    mappings, multisets and any object that implements the iterator
    interface (see below). To make it possible to use this
    conveniently, a new syntax has been added to get both the index
    and the value in each iteration:

    	foreach (something; index-expr; value-expr) ...

    This iterates over something, assigning in turn each index to
    index-expr and each value to value-expr. The index and value
    expressions can be declarations or lvalues, and they can also be
    left out if the index and/or value part isn't interesting.

    Note that it depends on the data type whether the iteration order
    is well defined or not; arrays and multisets are iterated over
    starting with the first element while mappings are visited in some
    arbitrary order (each element is still visited only once, though).

o Iterators
    As noted above, an iterator interface has been added that is now
    used in various places to iterate over different data structures.
    Not only the built-in data types are supported, but actually any
    object that fulfills the interface for iterators:

    When iterating over an object o, o->_get_iterator() is called to
    get an iterator object. An iterator object should at least have
    two functions, index() and value(), to get the index and value
    at the current position, a function `+=(int steps) to advance the
    current position the specified number of steps, and a `!() that
    returns zero if the position hasn't reached the end of the data set.

    Also, if the object o lacks a _get_iterator function, it's assumed
    to be an iterator itself. This makes it possible to pass an
    iterator explicitly to e.g. the foreach statement.

    The built-in data types also have iterator classes with this
    interface. They are found as Array.Iterator, Mapping.Iterator, etc
    and can be used to iterate over these data types in some custom
    fashion. This is especially useful for mappings and multisets,
    which cannot be iterated over directly in any other way. For
    example, to get some arbitrary index in a mapping m:

	mixed any_index = Mapping.Iterator(m)->index();

o Automap
    To perform per-element operations on arrays, there is now a convenience
    syntax for map(), that can make code more readable in some situations.
    Summing up two arrays element by element using automap looks like this:

	a[*] + b[*]; // the result has as many elements as the shortest array

    Multiplying all elements in a by a constant:

	a[*] * 4711;

    Make an array of what sprintf("%O", a[n]) returns for all elements in a:

	sprintf("%O", a[*]);

o Implicit lambda.

o Access to hidden variables in surrounding scopes.
    Include the names of the surrounding classes themselves in the lookup for
    Foo::, to make it possible to adress hidden variables in the scopes of
    surrounding classes, e.g:

       class Foo {
         int i;
	 void create (int i) {Foo::i = i;}
       }

o global::
    Added new keyword global to be able to access identifiers on the
    top level of the compilation unit using global::foo.

o global.
    All top level modules (and other identifiers in that scope) can now
    be accessed with a "global." prefix. This is useful in cases where
    local identifiers overshadow the top level, for instance in the Image
    module, where the Image.Image class would occasionally block your view.

o this
    Added a magic identifier "this" that can be used instead of
    this_object(). Like this_program, it only exists when there's no
    other identifier with that name. The primary reason for adding
    this magic identifier is to make it possible to address the object
    of a surrounding class with Foo::this.

o The Local module
    All Pike modules and classes found in the directory hierarchies
    /usr/local/pike_modules, /opt/pike_modules, /opt/share/pike_modules,
    /usr/local/share/pike_modules, $HOME/pike_modules, and
    $PIKE_LOCAL_PATH (a :-separated list of directories) are available
    with the prefix "Local.". Local.add_path() and Local.remove_path()
    respectively adds and removes entries from the list of paths to
    inspect when resolving Local.* symbols.

o enum reserved

o enum and typedef have implicit local binding

o ::_indices(), ::_values().
   There are now two "magic" functions ::_indices() and ::_values()
   that can be used by an object to list all identifiers and their
   values in itself. They are primarily intended when the _indices()
   and _values() lfuns have been defined, to get the default
   implementations. This is to complement the "magic" ::`->() and
   ::`->=() functions that exist in earlier releases.

o UNDEFINED
   To generate a 0 (zero) with a zero_type(var) == 1, you previously
   had to use constructs like ([])[0]. This is now available as the
   globally available symbol UNDEFINED.

o _m_delete
   There is now an LFUN mixed _m_delete(mixed index) to overload in
   your classes to imitate mappings. It gets invoked when m_delete
   is performed on your object.

o :: includes current class
   class X {
     int i;
     void create (int i) {X::i = i;}
   }


New modules / classes / methods added:
--------------------------------------

o ADT.History
    ADT implementation of a "leaking stack". Hilfe example:
      > object h=ADT.History(3);
      > for(int i=17; i<22; i++) h->push(i);
      Ok.
      > h->get_first_entry_num();
      (1) Result: 3
      > h[3];
      (2) Result: 19


o ADT.Relation.Binary
    Handles binary relations. Hilfe example:
      > object r=ADT.Relation.Binary("test");               
      > r->add(1,2)->add(2,3)->add(3,5)->add(1,4)->add(4,5);
      (1) Result: ADT.Relation.Binary("test")
      > r->find_shortest_path(1,5);                         
      (2) Result: ({ /* 3 elements */
      		      1,
      		      4,
      		      5
      		  })
      > r->remove(1,4);                                     
      (3) Result: ADT.Relation.Binary("test")
      > r->add(5,1);
      (4) Result: ADT.Relation.Binary("test")
      > r->find_shortest_path(1,5);                         
      (5) Result: ({ /* 4 elements */
      		      1,
      		      2,
      		      3,
      		      5
      		  })


o Audio.Codec and Audio.Codec
    Contains decoders and encoders for audio. Currently WAV and MP3.
    Note: The API remains marked "unstable".

o Calendar.verify

o Crypto.MD4

o Crypto.crypt_md5

o Debug.Tracer

o Debug.Subject

o Locale.Language

o Parser.Python
    Splits Python source code into text tokens.

o Parser.RCS
    Extracts data from RCS or CVS repositories.

o XML.NSTree

o HTTP.Server

o Protocols.X.KeySyms

o Standards.CIFF

o Standards.FIPS10_4

o Standards.ID3
    ID3 tags decoder/encoder. Supports versions: 1.0, 1.1,
    2.2-2.4. Frequently used in MP3 files for encapsulating metadata.

o Standards.RDF

o System.Time

o System.Timer

o Stdio.FakeFile

o Stdio.GZipFile

o Stdio.expand_symlinks(string path)
  Expands all symlinks along a path (returns 0 for broken links).
  (Only available on systems with readlink.)

o Tools.PV
    Convenience tool that sets up a canvas with GTK, presents a
    picture on it and delivers a number of image inspection and
    manipulation options. This is a great tool for image work in
    Hilfe.

      > object i=Image.Image(32,32)->random();
      > Tools.PV(i);

    The Pike Viewer tool is also accessable via "pike -x pv"

o Image.Dims
    Can extract the dimensions of an image with a minimal amount of
    data loading. Currently handles JPEG, GIF and PNG images. Hilfe
    example:
      > Image.Dims.get(Stdio.File("test.gif"));
      (1) Result: ({ /* 2 elements */
      		      1412,
      		      1120
      		  })


o Image.Fonts
    High level API for font handling. Should be used instead of
    accessing the Freetype, TTF and *FIXME* modules directly.

o Image.DWG
    Decodes AutoCAD thumbnail images.

o Image.SVG

o Gmp.mpq and Gmp.mpf
    Multi precision fractions.

o String.SplitIterator

o Stdio.File.line_iterator

o String.Replace, String.SingleReplace


Optimizations:
--------------

o Machine code used on some architectures.

o Computed goto

o Better module dumping

o Overall speed improvements.
    Function calls (new opcodes)
    sprintf
    arrays
    replace

o Deferred backtraces.

o Improvement and bug tickets closed: 1499


Compatibility changes:
----------------------

The following changes are known to break compatibility. The old
behaviour is emulated in the compatibility layer that is activated by
adding the preprocessor directive "#pike 7.2" to your program or by
giving the argument "-V7.2" to the pike executable.

o "global" has become a reserved keyword.

o Changed lookup rule for ::.
    Previously the identifier in front of :: was only looked up among
    the preceding inherits. Now the lookup additionally includes the
    names of the surrounding classes. The inherits inside a class
    still take precedence over the name of the class, though.

o Using local:: on variables is an error.
    Previously the construct local::foo could be used to access the
    identifier "foo" in the class scope if it had been overridden by
    an argument or function variable. That is however only a
    side-effect of the real use for local::, namely to bind the
    identifier statically at that point only, to avoid getting an
    overridden version. In the case of variables this leads to
    questionable semantics, which is the reason it's been made an
    error in this version. Pike 7.2 didn't implement it correctly;
    there local:: on variables had only the effect to access the class
    scope. Now a proper way to access hidden identifiers has been
    added, so all such uses of local:: should be replaced with
    this_program::.

o Identifier lookup
    The search algorithm for finding identifiers from inherited classes
    has been changed to look for the most recent definition in the most
    recent inherit. In Pike 7.2 and prior, it looked up the last
    definition regardless of inherit depth, unless there was a
    definition in the current program. (This actually changed more than
    once during 7.3 - between 7.3.23 and 7.3.32, it looked up the most
    recent definition with the least inherit depth.) This example shows
    what the lookup strategies would find:

    class A {
      int foo() {}
    }

    class B {
      int foo() {}
      inherit A;
    }

    class C {
      inherit B;
    }

    class D {
      inherit B;
      inherit C;
    }

    Lookup of identifier "foo" in D():

    D-+-B-+-foo          Pike 7.3.23 --- Pike 7.3.32
      |   |
      |   +-A---foo
      |
      +-C---B-+-foo      Pike 7.3.33 --- (present day)
              |
              +-A---foo              --- Pike 7.3.22

    Lookup of identifier "foo" in C():

    C---B-+-foo          Pike 7.3.23 --- (present day)
          |
          +-A---foo                  --- Pike 7.3.22

    Lookup of identifier "foo" in B():

    B-+-foo              All versions of Pike
      |
      +-A---foo

o Image.Layer modes modified

    Alpha channel handling for modes add, subtract, multiply, divide,
    modulo, invsubtract, invdivide, invmodulo, difference, max, min,
    bitwise_and, bitwise_or, bitwise_xor, screen and overlay modified so
    that the source layer alpha channel copied to the destination layer
    alpha channel rather then mixed with the current layer alpha channel:

    aD=aS

    rather then the behavior before:

    aD=(aL+(1-aL)*aS)

    (which is the behavior of the 'normal' mode.)

    Bug fixes in the above modes so that alpha r,g,b channels
    are handled properly (separately).

    Bug fixes in equal, not_equal, less, more, less_or_equal,
    more_or_equal modes so that the alpha channel is handled as
    documented (which is, in fact, as above; aD=aS).

    Bug fix in divide, invdivide to actually do what the modes
    are supposed to do (rather then just black the layer).

    And while on it, adding some modes:

    'imultiply'  - D=(1-L)*S
    'idivide'    - D=S/(1-L)
    'invidivide' - D=L/(1-S)

    'value_mul' - multiplying the source layer value
    (as in h,s,v) with the current layer value to the destination
    layer ("true burn").

    NOTE: There is no backward compatibility functions added for use
    with #pike.

o Thread.Condition()->wait

o Protocols.HTTP
    All methods in Protocols.HTTP that take a header mapping can now
    handle array values (signifying multiple headers of that type).

o Protocols.LDAP.client
    The return code from all methods was changed to follow Pike's
    logic better. 0 is now a failure. The old behaviour is emulated in
    a compatibility layer.

o dirname
    Now correctly returns a directory instead of just stripping the
    part after the nearest directory separator.

o LR
    LR has been moved to Parser.LR and the API has been chnged.
    FIXME: More about this?

o wmml documentation removed
    Use the documentation in the refdoc directory instead.

o .build_lobotomize_crypto removed
    Use the Makefile target lobotomize_crypto to lobotomize Pike.
    Should preferably be executed in an unused tree straight from CVS.

C level/development changes:
----------------------------

o Some global symbols have been renamed to avoid name clashes.
    sp -> Pike_sp
    fp -> Pike_fp
    fatal -> Pike_fatal
    empty_string -> empty_pike_string

o --with-internal-profiling

o Module symbols not available from other modules.


Bugs fixed:
-----------

o Reworked trampolines to cause less circular references. (solves 1937)


(To browse bug tickets, either visit
http://community.roxen.com/crunch/ - or append the ticket id to
"http://bugs.roxen.com/" for an address directly to the ticket
itself.)


Uncategorized:
--------------

o --with-new-multisets
o PIKE_RUN_UNLOCKED
o Works with Autoconf 2.50
o Saved 8 bytes per object for objects not using their parent scope
o constant objects (Gmp.Bignum, Math.Matrix, Image.Color)
o basetype()
o it is possible to change predefines without forking a new pike
o dynamic loading
o #pragma save_parent
o #pragma dont_save_parent (overrides constant __pragma_save_parent__)
o dont_dump_module
o modules can no longer call functions in other modules directly
o it is possible to inherit pike programs from C programs.
o separate weak flags for indices and values in mappings

Math.inf
Math.nan
Gz._file
Image.Image()->blur
Image.Image()->grey_blur
Image.PVR: VQ compression/decompression added
MIME.Message: guess mode added
Math.Transforms (FFT iFFT)
Math.Matrix()->sum,max,min
Math.Matrix.convolve
Math.Matrix.dot_product
Oracle: CLOB and BLOB support
_Ffmpeg
Image.JPEG: transforms
Stdio.File->sync
Stdio.get_all_active_fd (from spider)
system.normalize_path
system.gettimeofday
system.get_netinfo_property (Max OS X)
system.usleep/nanosleep
system.Memory (a class to read/write from mmap'ed or allocated memory)
SDL
Shuffler
