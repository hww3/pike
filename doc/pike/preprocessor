NAME
	preprocessor - textually process code before compiling

DESCRIPTION
	Pike has a builtin C-style preprocessor. It works similar to old
	C preprocessors but has a few extra features. This file describes
	the different preprocessor directives.

PREPROCESSOR DIRECTIVES
	  #!
	  #define
	  #elif
	  #else
	  #elseif
	  #endif
	  #error
	  #if
	  #ifdef
	  #ifndef
	  #include
	  #line
	  #pragma
	  #undef

KEYWORDS
	pike

============================================================================
DIRECTIVE
	#!

DESCRIPTION
	This directive is in effect a comment statement, since the
	preprocessor will ignore everything to the end of the line.
	This is used to write unix type scripts in Pike by starting
	the script with

	#!/usr/local/bin/pike
============================================================================
DIRECTIVE
	#define

DESCRIPTION
	The simplest way to use define is to write

	  #define <identifier> <replacement string>

	which will cause all subsequent occurances of 'identifier' to be
	replaced with the replacement string.

	Define also has the capability to use arguments, thus a line like

	  #define <identifier>(arg1, arg2) <replacement string>

	would cause identifer to be a macro. All occurances of
	'identifier(something1,something2d)' would be replaced with
	the replacement string. And in the replacement string, arg1 and arg2
	will be replaced with something1 and something2.

BUGS
	Note that it is not a good idea to do something like this:

	#define foo bar // a comment

	The comment will be included in the define, and thus inserted in the
	code. This will have the effect that the rest of the line will be
	ignored when the word foo is used. Not exactly what you might expect.

============================================================================
DIRECTIVE
	#undef

DESCRIPTION
	This removes the effect of a #define, all subsequent occurances of
	the undefined identifier will not be replaced by anything. Note that
	when undefining a macro, you just give the identifer, not the
	arguments.

EXAMPLES
	#define foo bar
	#undef foo
	#define foo(bar) gazonk bar
	#undef foo
============================================================================
DIRECTIVE
	#if
	#elif
	#elseif
	#else
	#endif

DESCRIPTION
	The #if directive causes conditional compiling of code depending on
	the expression after the #if directive. That is, if the expression
	is true, the code up to the next #else, #elif, #elseif or #endif is
	compiled. If the expression is false, that code will be skipped.
	If the skip leads up to a #else, the code after the else will be
	compiled. #elif and #elseif are equivialent and causes the code that
	follow them to be compiled if the previous #if or #elif evaluated
	false and the expression after the #elif evaluates true.

	Expressions given to #if, #elif or #endif are special, all identifiers
	evaluate to zero unless they are defined to something else. Integers,
	strings and floats are the only types that can be used, but all pike
	operators can be used on these types.

	Also, two special functions can be used, defined() and constant().
	defined(<identifer>) expands to '1' if the identifier is defined,
	'0' otherwise. constant(<identifier>) expands to '1' if identifer is
	an predefined constant (with add_constant), '0' otherwise.

EXAMPLES
	#if 1
	  write("foo");
	#else
	  write("bar");
	#endif

	#if defined(FOO)
	  write(FOO);
	#elif defined(BAR)
	  write(BAR);
	#else
	  write("default");
	#endif

	#if !constant(write_file)
	inherit "simulate.pike"
	#endif
============================================================================
DIRECTIVE
	#error

DESCRIPTION
	This directive causes a compiler error, it can be used to notify
	the user that certain functions are missing and similar things.

EXAMPLES
	#if !constant(write_file)
	#error write_file efun is missing
	#endif
============================================================================
DIRECTIVE
	#include

DESCRIPTION
	This directive should be given a file as argument, it will then be
	compiled as if all those lines were written at the #include line.
	The compiler then continues to compile this file.

EXAMPLES
	#include "foo.h"
============================================================================
DIRECTIVE
	#line

DESCRIPTION
	This directive tells the compiler what line and file we are compiling.
	This is for instance used by the #include directive to tell the
	compiler that we are compiling another file. The directive takes
	the line number first, and optionally, the file afterwards.

	This can also be used when generating pike from something else, to
	tell teh compiler where the code originally originated from.

EXAMPLES
	#line 4 "foo.cf" /* The next line was generated from 4 in foo.cf */
============================================================================
DIRECTIVE
	#pragma

DESCRIPTION
	This is a generic directive for flags to the compiler. Currently, the
	only flag available is 'all_inline' which is the same as adding the
	modifier 'inline' to all functions that follows.
============================================================================
