1. Let's write a small uLPC program:

	int main()
	{
	  write("hello world\n");
	  return 0;
	}

  Let's call this file hello_world.ulpc, and then we try to run it:

	$ ulpc hello_world.lpc
	hello world
	$ 

1.1 Pretty simple, Let's see what everything means:

	int main()

  This begins the function main. Before the function name the type of value
  it returns is declared, in this case 'int'. The empty space between the
  parethesis indicates that this function takes no arguments. The function
  main is special in the sense that it is the first function called when
  your program starts. Everything your program does should start in main.

	{
	  write("hello world\n");
	  return 0;
	}

  This is the body of the function. The brackets group together a series of
  statements into a block which will be executed when this function is called.
  The statements aer separated by semi-colons.

	write("hello world\n");

  The first statement is a call to the builtin function write. This will
  execute the code in the function write with the arguments as input data.
  In this case, the constant string "hello world\n" is sent. write() then of
  course writes this string to stdout when executed.

	return 0;

  This statement aborts the function and returns the value zero. Any statements
  following the return statements (not that there are any in this example)
  will not be executed.

1.2 Improving hello_world.lpc
  Typing 'ulpc hello_world.lpc' to run our program may seem a bit unpractical,
  fortunately, UNIX provides us with a way of automating this somewhat.
  If we modify hello_world.lpc to look like this:

	#!/usr/local/bin/ulpc

	int main()
	{
	  write("hello world\n");
	}

  And then we tell UNIX that hello_world.lpc is executable:

	$ chmod +x hello_world.lpc

  Now we can run hello_world.lpc without having to bother with running ulpc:

	$ ./hello_wold.lpc
	hello world
	$ 

  NB. The hash bang (#!) must be absolutely first in the file, no empty
      lines or whitespaces can precede it for this to work. The file after
      the hash bang must also be the complete filename to the ulpc binary,
      and it may not exceed 30 characters.

1.3 A better hello_world.lpc
  Now, wouldn't it be nice if it said "Hello world!" instead of "hello world" ?
  But of course we don't want to make our program incompatible with the old
  version. Someone might NEED the program to work the same as before. 
  Therefore we'll add a command line option that will make it type the old
  "hello world". This is what it could look like:

	#!/usr/local/bin/ulpc

	int main(int argc, string *argv)
	{
	  if(argc > 1 && argv[1]=="--traditional")
	  {
	    write("hello world\n"); // old stype
	  }else{
	    write("Hello world!\n"); // new style
	  }
	  return 0;
	}

  Let's run it:

	$ chmod +x hello_world.lpc
	$ ./hello_world.lpc
	Hello world!
	$ ./hello_world.lpc --traditional
	hello world
	$ 

  What's been added?

	int main(int argc, string *argv)

  Here the space between the parentesis has been filled. What it means
  is that main now takes two arguments. One is called argc, and is of the
  type 'int'. The other is called 'argv' and is a 'string *'. The star
  means that the argument is an array, in this case an array of strings.

  The arguments to main are taken from the command line when the uLPC program
  is executed. The first argument, argc, is how many words were written on
  the command line (including the command itself) and argv is an array formed
  by these words.

	  if(argc > 1 && argv[1] == "--traditional")
	  {
	    write("hello world\n"); // old stype
	  }else{
	    write("Hello world!\n"); // new style
	  }

  This is an if-else statement, it will execute what's between the first set
  of brackets if the expression between the parenthesis evaluate to something
  other than zero. Otherwise what's between the second set of brackets will
  be executed. Let's look at that expression:

	argc > 1 && argv[1] == "--traditional"

  Loosely translated, this means: argc is greater than one and the second
  element in the array argv is equal to the string "--traditional".

  Also note the comments:
  
	    write("hello world\n"); // old stype

  The // begins a comment which continues to the end of the line.
  Comments lets you type in text in the program which will be ignored by the
  computer. This is to inform whoever might read your code (like yourself) of
  what the program does to make it easier to understand.
