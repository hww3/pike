<hr newpage>
<anchor name=Image>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image</tt><br>
<p>
<dt><encaps>DESCRIPTION</encaps><dd>
This module adds image-drawing and -manipulating
     capabilities to pike. 

<p>     <table border=0>
     <tr>
     <td align=left valign=top><link to=Image.image>Image.image</link></td>
     <td align=left valign=top>Basic image manipulation</td>
     </tr>
     <tr>
     <td align=left valign=top><link to=Image.font>Image.font</link></td>
     <td align=left valign=top>Creating images from text</td>
     </tr>
     <tr>
     <td align=left valign=top><link to=Image.colortable>Image.colortable</link></td>
     <td align=left valign=top>Color reduction, quantisation and dither</td>
     </tr>
     <tr>
     <td align=left valign=top><link to=Image.GIF>Image.GIF</link></td>
     <td align=left valign=top>GIF encoding/decoding capabilities</td>
     </tr>
     <tr>
     <td align=left valign=top><link to=Image.PNM>Image.PNM</link></td>
     <td align=left valign=top>PNM (PBM/PGM/PPM) encoding/decoding capabilities</td>
     </tr>
     </table>
<p>

<dt><encaps>NOTA BENE</encaps><dd>
<font size=-1><pre>Image module documentation is based on these file versions:
     $Id: Image.wmml,v 1.4 1997/11/10 14:19:41 mirar Exp $
     $Id: Image.wmml,v 1.4 1997/11/10 14:19:41 mirar Exp $
     $Id: Image.wmml,v 1.4 1997/11/10 14:19:41 mirar Exp $
     $Id: Image.wmml,v 1.4 1997/11/10 14:19:41 mirar Exp $
     $Id: Image.wmml,v 1.4 1997/11/10 14:19:41 mirar Exp $
     $Id: Image.wmml,v 1.4 1997/11/10 14:19:41 mirar Exp $
     $Id: Image.wmml,v 1.4 1997/11/10 14:19:41 mirar Exp $
     $Id: Image.wmml,v 1.4 1997/11/10 14:19:41 mirar Exp $
     $Id: Image.wmml,v 1.4 1997/11/10 14:19:41 mirar Exp $
     $Id: Image.wmml,v 1.4 1997/11/10 14:19:41 mirar Exp $
     $Id: Image.wmml,v 1.4 1997/11/10 14:19:41 mirar Exp $
     $Id: Image.wmml,v 1.4 1997/11/10 14:19:41 mirar Exp $
     $Id: Image.wmml,v 1.4 1997/11/10 14:19:41 mirar Exp $
     $Id: Image.wmml,v 1.4 1997/11/10 14:19:41 mirar Exp $
     $Id: Image.wmml,v 1.4 1997/11/10 14:19:41 mirar Exp $
     $Id: Image.wmml,v 1.4 1997/11/10 14:19:41 mirar Exp $
     $Id: Image.wmml,v 1.4 1997/11/10 14:19:41 mirar Exp $
     $Id: Image.wmml,v 1.4 1997/11/10 14:19:41 mirar Exp $
     </pre></font>
<p>

</dl>




<section title="Image.colortable">
<hr newpage>
<anchor name=Image.colortable>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.colortable</tt><br>
<p>
<dt><encaps>DESCRIPTION</encaps><dd>
This object keeps colortable information,
     mostly for image re-coloring (quantization).

<p>     The object has color reduction, quantisation,
     mapping and dithering capabilities.
<p>

<dt><encaps>SEE ALSO</encaps><dd>
<link to=Image>Image</link>,
     <link to=Image.image>Image.image</link>,
     <link to=Image.font>Image.font</link>,
     <link to=Image.GIF>Image.GIF</link>
<p>

</dl>

<hr newpage>
<anchor name=Image.colortable.create>
<anchor name=Image.colortable.add>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.colortable->add</tt><br>
	<tt>Image.colortable->create</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
void <b>create</b>()<br>
	void <b>create</b>(array(array(int))&nbsp;colors)<br>
	void <b>create</b>(object(Image.image)&nbsp;image, int&nbsp;number)<br>
	void <b>create</b>(object(Image.image)&nbsp;image, int&nbsp;number, array(array(int))&nbsp;needed)<br>
	void <b>create</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
	void <b>create</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b, &nbsp;array(int)&nbsp;from1, array(int)&nbsp;to1, int&nbsp;steps1, &nbsp;..., &nbsp;array(int)&nbsp;fromn, array(int)&nbsp;ton, int&nbsp;stepsn)<br>
	object <b>add</b>(array(array(int))&nbsp;colors)<br>
	object <b>add</b>(object(Image.image)&nbsp;image, int&nbsp;number)<br>
	object <b>add</b>(object(Image.image)&nbsp;image, int&nbsp;number, array(array(int))&nbsp;needed)<br>
	object <b>add</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
	object <b>add</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b, &nbsp;array(int)&nbsp;from1, array(int)&nbsp;to1, int&nbsp;steps1, &nbsp;..., &nbsp;array(int)&nbsp;fromn, array(int)&nbsp;ton, int&nbsp;stepsn)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
<link to=Image.colortable.create>create</link> initiates a colortable object. 
     Default is that no colors are in the colortable. 

<p>     <link to=Image.colortable.add>add</link> takes the same argument(s) as
     <link to=Image.colortable.create>create</link>, thus adding colors to the colortable.

<p>     The colortable is mostly a list of colors,
     or more advanced, colors and weight.

<p>     The colortable could also be a colorcube, with or 
     without additional scales. A colorcube is the by-far 
     fastest way to find colors. 

<p>     Example:
     <pre>
     ct=colortable(my_image,256); // the best 256 colors
     ct=colortable(my_image,256,({0,0,0})); // black and the best other 255

<p>     ct=colortable(({({0,0,0}),({255,255,255})})); // black and white

<p>     ct=colortable(6,7,6); // a colortable of 252 colors
     ct=colortable(7,7,5, ({0,0,0}),({255,255,255}),11); 
             // a colorcube of 245 colors, and a greyscale of the rest -&gt; 256
     </pre>
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>array(array(int)) colors</tt></td>	<td valign=bottom>list of colors</td></tr>

	<tr align=left><td valign=top>
<tt>object(Image.image) image</tt></td>	<td valign=bottom>source image 

<p>     note: you may not get all colors from image,
     max hash size is (probably, set by a <tt>#define</tt>) 
     32768 entries, giving
     maybe half that number of colors as maximum.</td></tr>

	<tr align=left><td valign=top>
<tt>int number</tt></td>	<td valign=bottom>number of colors to get from the image
     
     0 (zero) gives all colors in the image.

<p>     Default value is 256.</td></tr>

	<tr align=left><td valign=top>
<tt>array(array(int)) needed</tt></td>	<td valign=bottom>needed colors (to optimize selection of others to these given)
     
     this will add to the total number of colors (see argument 'number')</td></tr>

	<tr align=left><td valign=top>
<tt>int r</tt><br>
		<tt>int g</tt><br>
		<tt>int b</tt></td>	<td valign=bottom>size of sides in the colorcube, must (of course) be equal
     or larger than 2 - if smaller, the cube is ignored (no colors).
     This could be used to have only scales (like a greyscale)
     in the output.</td></tr>

	<tr align=left><td valign=top>
<tt>array(int) fromi</tt><br>
		<tt>array(int) toi</tt><br>
		<tt>int stepi</tt></td>	<td valign=bottom>This is to add the possibility of adding a scale
     of colors to the colorcube; for instance a grayscale
     using the arguments <tt>({0,0,0}),({255,255,255}),17</tt>,
     adding a scale from black to white in 17 or more steps.

<p>     Colors already in the cube is used again to add the number
     of steps, if possible. 

<p>     The total number of colors in the table is therefore
     <tt>r*b*g+step1+...+stepn</tt>.</td></tr>

</table><p>

</dl>

</anchor name=Image.colortable.add>
</anchor name=Image.colortable.create>



<hr newpage>
<anchor name=Image.colortable.cast>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.colortable->cast</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>cast</b>(string&nbsp;to)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
cast the colortable to an array

<p>     example: <tt>(array)Image.colortable(img)</tt>
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>string to</tt></td>	<td valign=bottom>must be "array".</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
the resulting array
<p>

</dl>

</anchor name=Image.colortable.cast>



<hr newpage>
<anchor name=Image.colortable.cubicles>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.colortable->cubicles</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>cubicles</b>()<br>
	object <b>cubicles</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
	object <b>cubicles</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b, int&nbsp;accuracy)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
Set the colortable to use the cubicles algorithm to lookup
     the closest color. This is a mostly very fast and very
     accurate way to find the correct color, and the default
     algorithm.

<p>
     The colorspace is divided in small cubes, each cube
     containing the colors in that cube. Each cube then gets
     a list of the colors in the cube, and the closest from
     the corners and midpoints between corners.  

<p>     When a color is needed, the algorithm first finds the
     correct cube and then compares with all the colors in
     the list for that cube.

<p>     example: <tt>colors=Image.colortable(img)-&gt;cubicles();</tt>

<p>     algorithm time: between O[m] and O[m * n], 
     where n is numbers of colors and m is number of pixels

<p>     The arguments can be heavy trimmed for the usage
     of your colortable; a large number (10×10×10 or bigger)
     of cubicles is recommended when you use the colortable
     repeatedly, since the calculation takes much
     more time then usage.

<p>     recommended values:

<p>     <pre>   
     image size  setup
     100×100     cubicles(4,5,4) (default)
     1000×1000   cubicles(12,12,12) (factor 2 faster than default)
     </pre>  

<p>     In some cases, the <link to=Image.colortable.full>full</link> method is faster.

<p>     <table><tr valign=center>
     <td><illustration __from__='colortable.c line 2340' src=lena.gif>
 return src; </illustration></td>
     <td><illustration __from__='colortable.c line 2340' src=lena.gif>
 object c=Image.colortable(src,16); return c*src; </illustration></td>
     <td><illustration __from__='colortable.c line 2340' src=lena.gif>
 object c=Image.colortable(src,16)->cubicles(4,5,4,200); return c*src; </illustration></td>
     </tr><tr valign=center>
     <td>original</td>
     <td>default cubicles,<br>16 colors</td>
     <td>accuracy=200</td>
     </tr></table>
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>int r</tt><br>
		<tt>int g</tt><br>
		<tt>int b</tt></td>	<td valign=bottom>Size, ie how much the colorspace is divided.
     Note that the size of each cubicle is at least about 8b,
     and that it takes time to calculate them. The number of
     cubicles are <tt>r*g*b</tt>, and default is 4,5,4,
     ie 80 cubicles. This works good for 200±100 colors.</td></tr>

	<tr align=left><td valign=top>
<tt>int accuracy</tt></td>	<td valign=bottom>Accuracy when checking sides of cubicles.
     Default is 16. A value of 1 gives complete accuracy,
     ie cubicle() method gives exactly the same result
     as full(), but takes (in worst case) 16× the time
     to calculate.</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
the called object
<p>

<dt><encaps>NOTA BENE</encaps><dd>
this method doesn't figure out the cubicles, this is 
     done on the first use of the colortable

<p>     Not applicable to colorcube types of colortable.
<p>

</dl>

</anchor name=Image.colortable.cubicles>



<hr newpage>
<anchor name=Image.colortable.floyd_steinberg>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.colortable->floyd_steinberg</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>floyd_steinberg</b>()<br>
	object <b>floyd_steinberg</b>(int&nbsp;dir, int|float&nbsp;forward, int|float&nbsp;downforward, int|float&nbsp;down, int|float&nbsp;downback, int|float&nbsp;factor)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
Set dithering method to floyd_steinberg.
     
     The arguments to this method is for fine-tuning of the 
     algorithm (for computer graphics wizards). 

<p>     <table><tr valign=center>
     <td><illustration __from__='colortable.c line 3074' src=lena.gif>
 return src; </illustration></td>
     <td><illustration __from__='colortable.c line 3074' src=lena.gif>
 object c=Image.colortable(4,4,4)->floyd_steinberg(); return c*src; </illustration></td>
     <td><illustration __from__='colortable.c line 3074' src=lena.gif>
 object c=Image.colortable(src,16)->floyd_steinberg(); return c*src; </illustration></td>
     </tr><tr valign=center>
     <td>original</td>
     <td>floyd_steinberg to a 4×4×4 colorcube</td>
     <td>floyd_steinberg to 16 chosen colors</td>
     </tr></table>
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>int bidir</tt></td>	<td valign=bottom>Set algorithm direction of forward.
     -1 is backward, 1 is forward, 0 for toggle of direction
     each line (default).</td></tr>

	<tr align=left><td valign=top>
<tt>int|float forward</tt><br>
		<tt>int|float downforward</tt><br>
		<tt>int|float down</tt><br>
		<tt>int|float downback</tt></td>	<td valign=bottom>Set error correction directions. Default is 
     forward=7, downforward=1, down=5, downback=3.</td></tr>

	<tr align=left><td valign=top>
<tt>int|float factor</tt></td>	<td valign=bottom>Error keeping factor. 
     Error will increase if more than 1.0 and decrease if less than 1.0.
     A value of 0.0 will cancel any dither effects.
     Default is 0.95.</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
the called object
<p>

</dl>

</anchor name=Image.colortable.floyd_steinberg>



<hr newpage>
<anchor name=Image.colortable.full>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.colortable->full</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>full</b>()
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
Set the colortable to use full scan to lookup the closest color.

<p>     example: <tt>colors=Image.colortable(img)-&gt;full();</tt>

<p>     algorithm time: O[n*m], where n is numbers of colors 
     and m is number of pixels
<p>

<dt><encaps>RETURN VALUE</encaps><dd>
the called object
<p>

<dt><encaps>NOTA BENE</encaps><dd>
Not applicable to colorcube types of colortable.
<p>

<dt><encaps>SEE ALSO</encaps><dd>
<link to=Image.colortable.cubicles>cubicles</link>,
     <link to=Image.colortable.map>map</link>
<p>

</dl>

</anchor name=Image.colortable.full>



<hr newpage>
<anchor name=Image.colortable.`*>
<anchor name=Image.colortable.map>
<anchor name=Image.colortable.``*>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.colortable->map</tt><br>
	<tt>Image.colortable->`*</tt><br>
	<tt>Image.colortable->``*</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>map</b>(object&nbsp;image)<br>
	object <b>`*</b>(object&nbsp;image)<br>
	object <b>``*</b>(object&nbsp;image)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
Map colors in an image object to the colors in 
     the colortable, and creates a new image with the
     closest colors. 

<p>     <table><tr valign=center>
     <td></td>
     <td><illustration __from__='colortable.c line 2774' src=lena.gif>
 object c=Image.colortable(src,2); return c*src; </illustration></td>
     <td><illustration __from__='colortable.c line 2774' src=lena.gif>
 object c=Image.colortable(src,4); return c*src; </illustration></td>
     <td><illustration __from__='colortable.c line 2774' src=lena.gif>
 object c=Image.colortable(src,8); return c*src; </illustration></td>
     <td><illustration __from__='colortable.c line 2774' src=lena.gif>
 object c=Image.colortable(src,16); return c*src; </illustration></td>
     <td><illustration __from__='colortable.c line 2774' src=lena.gif>
 object c=Image.colortable(src,32); return c*src; </illustration></td>
     <td>no dither</td>
     </tr><tr valign=center>
     <td></td>
     <td><illustration __from__='colortable.c line 2774' src=lena.gif>
 object c=Image.colortable(src,2)->floyd_steinberg(); return c*src; </illustration></td>
     <td><illustration __from__='colortable.c line 2774' src=lena.gif>
 object c=Image.colortable(src,4)->floyd_steinberg(); return c*src; </illustration></td>
     <td><illustration __from__='colortable.c line 2774' src=lena.gif>
 object c=Image.colortable(src,8)->floyd_steinberg(); return c*src; </illustration></td>
     <td><illustration __from__='colortable.c line 2774' src=lena.gif>
 object c=Image.colortable(src,16)->floyd_steinberg(); return c*src; </illustration></td>
     <td><illustration __from__='colortable.c line 2774' src=lena.gif>
 object c=Image.colortable(src,32)->floyd_steinberg(); return c*src; </illustration></td>
     <td><link to=Image.colortable.floyd_steinberg>floyd_steinberg</link> dither</td>
     </tr><tr valign=center>
     <td></td>
     <td><illustration __from__='colortable.c line 2774' src=lena.gif>
 object c=Image.colortable(src,2)->ordered(60,60,60); return c*src; </illustration></td>
     <td><illustration __from__='colortable.c line 2774' src=lena.gif>
 object c=Image.colortable(src,4)->ordered(45,45,45); return c*src; </illustration></td>
     <td><illustration __from__='colortable.c line 2774' src=lena.gif>
 object c=Image.colortable(src,8)->ordered(40,40,40); return c*src; </illustration></td>
     <td><illustration __from__='colortable.c line 2774' src=lena.gif>
 object c=Image.colortable(src,16)->ordered(40,40,40); return c*src; </illustration></td>
     <td><illustration __from__='colortable.c line 2774' src=lena.gif>
 object c=Image.colortable(src,32)->ordered(15,15,15); return c*src; </illustration></td>
     <td><link to=Image.colortable.ordered>ordered</link> dither</td>
     </tr><tr valign=center>
     <td><illustration __from__='colortable.c line 2774' src=lena.gif>
 return src; </illustration></td>
     <td><illustration __from__='colortable.c line 2774' src=lena.gif>
 object c=Image.colortable(src,2)->randomcube(60,60,60); return c*src; </illustration></td>
     <td><illustration __from__='colortable.c line 2774' src=lena.gif>
 object c=Image.colortable(src,4)->randomcube(45,45,45); return c*src; </illustration></td>
     <td><illustration __from__='colortable.c line 2774' src=lena.gif>
 object c=Image.colortable(src,8)->randomcube(40,40,40); return c*src; </illustration></td>
     <td><illustration __from__='colortable.c line 2774' src=lena.gif>
 object c=Image.colortable(src,16)->randomcube(40,40,40); return c*src; </illustration></td>
     <td><illustration __from__='colortable.c line 2774' src=lena.gif>
 object c=Image.colortable(src,32)->randomcube(15,15,15); return c*src; </illustration></td>
     <td><link to=Image.colortable.randomcube>randomcube</link> dither</td>
     </tr><tr valign=center>
     <td>original</td>
     <td>2</td>
     <td>4</td>
     <td>8</td>
     <td>16</td>
     <td>32 colors</td>
     </tr></table>
<p>

<dt><encaps>RETURN VALUE</encaps><dd>
a new image object
<p>

<dt><encaps>NOTA BENE</encaps><dd>
Flat (not cube) colortable and not '<link to=Image.colortable.full>full</link>' method: 
     this method does figure out the data needed for
     the lookup method, which may take time the first
     use of the colortable - the second use is quicker.
<p>

<dt><encaps>SEE ALSO</encaps><dd>
<link to=Image.colortable.cubicles>cubicles</link>,
     <link to=Image.colortable.full>full</link>
<p>

</dl>

</anchor name=Image.colortable.map>
</anchor name=Image.colortable.`*>
</anchor name=Image.colortable.``*>



<hr newpage>
<anchor name=Image.colortable.nodither>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.colortable->nodither</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>nodither</b>()
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
Set no dithering (default).
<p>

<dt><encaps>RETURN VALUE</encaps><dd>
the called object
<p>

</dl>

</anchor name=Image.colortable.nodither>



<hr newpage>
<anchor name=Image.colortable.ordered>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.colortable->ordered</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>ordered</b>()<br>
	object <b>ordered</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
	object <b>ordered</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b, int&nbsp;xsize, int&nbsp;ysize)<br>
	object <b>ordered</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b, int&nbsp;xsize, int&nbsp;ysize, int&nbsp;x, int&nbsp;y)<br>
	object <b>ordered</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b, int&nbsp;xsize, int&nbsp;ysize, int&nbsp;rx, int&nbsp;ry, int&nbsp;gx, int&nbsp;gy, int&nbsp;bx, int&nbsp;by)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
Set ordered dithering, which gives a position-dependent error added
     to the pixel values. 

<p>     <table><tr valign=center>
     <td><illustration __from__='colortable.c line 3440' src=lena.gif>
 return src; </illustration></td>
     <td><illustration __from__='colortable.c line 3440' src=lena.gif>
 object c=Image.colortable(6,6,6)->ordered(42,42,42,2,2); return c*src; </illustration></td>
     <td><illustration __from__='colortable.c line 3440' src=lena.gif>
 object c=Image.colortable(6,6,6)->ordered(); return c*src; </illustration></td>
     <td><illustration __from__='colortable.c line 3440' src=lena.gif>
 object c=Image.colortable(6,6,6)->ordered(42,42,42,8,8,0,0,0,1,1,0); return c*src; </illustration></td>
     </tr><tr valign=top>
     <td>original</td>
     <td colspan=2>mapped to <br><tt>Image.colortable(6,6,6)-&gt;</tt></td>
     </tr><tr valign=top>
     <td></td>
     <td><tt>ordered<br> (42,42,42,2,2)</tt></td>
     <td><tt>ordered()</tt></td>
     <td><tt>ordered<br> (42,42,42, 8,8,<br> 0,0, 0,1, 1,0)</tt></td>
     </tr><tr valign=top>
     <td><illustration __from__='colortable.c line 3440' src=lena.gif>
 
             object i=Image.image(src->xsize(),src->ysize()); 
             i->tuned_box(0,0,i->xsize()-1,i->ysize()-1,
                  ({({0,0,0}),({0,0,0}),({255,255,255}),({255,255,255})})); 
             return i; 
     </illustration></td>
     <td><illustration __from__='colortable.c line 3440' src=lena.gif>
 
             object i=Image.image(src->xsize(),src->ysize()); 
             i->tuned_box(0,0,i->xsize()-1,i->ysize()-1,
                  ({({0,0,0}),({0,0,0}),({255,255,255}),({255,255,255})})); 
             object c=Image.colortable(6,6,6)->ordered(42,42,42,2,2); 
             return c*i; 
     </illustration></td>
     <td><illustration __from__='colortable.c line 3440' src=lena.gif>
 
             object i=Image.image(src->xsize(),src->ysize()); 
             i->tuned_box(0,0,i->xsize()-1,i->ysize()-1,
                  ({({0,0,0}),({0,0,0}),({255,255,255}),({255,255,255})})); 
             object c=Image.colortable(6,6,6)->ordered(); 
             return c*i; 
     </illustration></td>
     <td><illustration __from__='colortable.c line 3440' src=lena.gif>
 
             object i=Image.image(src->xsize(),src->ysize()); 
             i->tuned_box(0,0,i->xsize()-1,i->ysize()-1,
                  ({({0,0,0}),({0,0,0}),({255,255,255}),({255,255,255})})); 
             object c=Image.colortable(6,6,6)->ordered(42,42,42,8,8,0,0,0,1,1,0); 
             return c*i; 
     </illustration></td>
     </tr></table>
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>int r</tt><br>
		<tt>int g</tt><br>
		<tt>int b</tt></td>	<td valign=bottom>The maximum error. Default is 32, or colorcube steps (256/size).</td></tr>

	<tr align=left><td valign=top>
<tt>int xsize</tt><br>
		<tt>int ysize</tt></td>	<td valign=bottom>Size of error matrix. Default is 8×8.
     Only values which factors to multiples of 2 and 3 are
     possible to choose (2,3,4,6,8,12,...).</td></tr>

	<tr align=left><td valign=top>
<tt>int x</tt><br>
		<tt>int y</tt><br>
		<tt>int rx</tt><br>
		<tt>int ry</tt><br>
		<tt>int gx</tt><br>
		<tt>int gy</tt><br>
		<tt>int bx</tt><br>
		<tt>int by</tt></td>	<td valign=bottom>Offset for the error matrix. <tt>x</tt> and <tt>y</tt> is for
     both red, green and blue values, the other is individual.</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
the called object
<p>

<dt><encaps>SEE ALSO</encaps><dd>
<link to=Image.colortable.randomcube>randomcube</link>,
     <link to=Image.colortable.nodither>nodither</link>,
     <link to=Image.colortable.floyd_steinberg>floyd_steinberg</link>,
     <link to=Image.colortable.create>create</link>
<p>

</dl>

</anchor name=Image.colortable.ordered>



<hr newpage>
<anchor name=Image.colortable.randomcube>
<anchor name=Image.colortable.randomgrey>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.colortable->randomcube</tt><br>
	<tt>Image.colortable->randomgrey</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>randomcube</b>()<br>
	object <b>randomcube</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
	object <b>randomgrey</b>()<br>
	object <b>randomgrey</b>(int&nbsp;err)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
Set random cube dithering.
     Color choosen is the closest one to color in picture
     plus (flat) random error; <tt>color±random(error)</tt>.

<p>     The randomgrey method uses the same random error on red, green
     and blue and the randomcube method has three random errors.

<p>     <table><tr valign=center>
     <td><illustration __from__='colortable.c line 3200' src=lena.gif>
 return src; </illustration></td>
     <td><illustration __from__='colortable.c line 3200' src=lena.gif>
 object c=Image.colortable(4,4,4)->randomcube(); return c*src; </illustration></td>
     <td><illustration __from__='colortable.c line 3200' src=lena.gif>
 object c=Image.colortable(4,4,4)->randomgrey(); return c*src; </illustration></td>
     </tr><tr valign=top>
     <td>original</td>
     <td colspan=2>mapped to <br><tt>Image.colortable(4,4,4)-&gt;</tt></td>
     </tr><tr valign=top>
     <td></td>
     <td>randomcube()</td>
     <td>randomgrey()</td>
     </tr><tr valign=top>
     <td><illustration __from__='colortable.c line 3200' src=lena.gif>
 
             object i=Image.image(src->xsize(),src->ysize()); 
             i->tuned_box(0,0,i->xsize()-1,i->ysize()-1,
                  ({({0,0,0}),({0,0,0}),({255,255,255}),({255,255,255})})); 
             return i; 
     </illustration></td>
     <td><illustration __from__='colortable.c line 3200' src=lena.gif>
 
             object i=Image.image(src->xsize(),src->ysize()); 
             i->tuned_box(0,0,i->xsize()-1,i->ysize()-1,
                  ({({0,0,0}),({0,0,0}),({255,255,255}),({255,255,255})})); 
             object c=Image.colortable(4,4,4)->randomcube(); 
             return c*i; 
     </illustration></td>
     <td><illustration __from__='colortable.c line 3200' src=lena.gif>
 
             object i=Image.image(src->xsize(),src->ysize()); 
             i->tuned_box(0,0,i->xsize()-1,i->ysize()-1,
                  ({({0,0,0}),({0,0,0}),({255,255,255}),({255,255,255})})); 
             object c=Image.colortable(4,4,4)->randomgrey(); 
             return c*i; 
     </illustration></td>
     </tr></table>
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>int r</tt><br>
		<tt>int g</tt><br>
		<tt>int b</tt><br>
		<tt>int err</tt></td>	<td valign=bottom>The maximum error. Default is 32, or colorcube step.</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
the called object
<p>

<dt><encaps>NOTA BENE</encaps><dd>
<link to=Image.colortable.randomgrey>randomgrey</link> method needs colorcube size to be the same on
     red, green and blue sides to work properly. It uses the
     red colorcube value as default.
<p>

<dt><encaps>SEE ALSO</encaps><dd>
<link to=Image.colortable.ordered>ordered</link>,
     <link to=Image.colortable.nodither>nodither</link>,
     <link to=Image.colortable.floyd_steinberg>floyd_steinberg</link>,
     <link to=Image.colortable.create>create</link>
<p>

</dl>

</anchor name=Image.colortable.randomcube>
</anchor name=Image.colortable.randomgrey>



<hr newpage>
<anchor name=Image.colortable.reduce>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.colortable->reduce</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>reduce</b>(int&nbsp;colors)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
reduces the number of colors

<p>     All needed (see <link to=Image.colortable.create>create</link>) colors are kept.
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>int colors</tt></td>	<td valign=bottom>target number of colors</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
the new <link to=Image.colortable>colortable</link> object
<p>

</dl>

</anchor name=Image.colortable.reduce>



<hr newpage>
<anchor name=Image.colortable.spacefactors>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.colortable->spacefactors</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>spacefactors</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
Colortable tuning option, this sets the color space
     distance factors. This is used when comparing distances
     in the colorspace and comparing grey levels.

<p>     Default factors are 3, 4 and 1; blue is much 
     darker than green. Compare with <link to=Image.image.grey>Image.image-&gt;grey</link>().
<p>

<dt><encaps>RETURN VALUE</encaps><dd>
the called object
<p>

<dt><encaps>NOTA BENE</encaps><dd>
This has no sanity check. Some functions may bug
     if the factors are to high - color reduction functions 
     sums grey levels in the image, this could exceed maxint
     in the case of high factors. Negative values may 
     also cause strange effects. *grin*
<p>

</dl>

</anchor name=Image.colortable.spacefactors>



<hr newpage>
<anchor name=Image.colortable.`+>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.colortable->`+</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>`+</b>(object&nbsp;with, ...)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
sums colortables
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>object(<link to=Image.colortable>colortable</link>) with</tt></td>	<td valign=bottom><link to=Image.colortable>colortable</link> object with colors to add</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
the resulting new <link to=Image.colortable>colortable</link> object
<p>

</dl>

</anchor name=Image.colortable.`+>



<hr newpage>
<anchor name=Image.colortable.`->
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.colortable->`-</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>`-</b>(object&nbsp;with, ...)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
subtracts colortables
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>object(<link to=Image.colortable>colortable</link>) with</tt></td>	<td valign=bottom><link to=Image.colortable>colortable</link> object with colors to subtract</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
the resulting new <link to=Image.colortable>colortable</link> object
<p>

</dl>

</anchor name=Image.colortable.`->



</anchor name=Image.colortable>



</section title="Image.colortable">



<section title="Image.font">
<hr newpage>
<anchor name=Image.font>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.font</tt><br>
<p>
<dt><encaps>DESCRIPTION</encaps><dd>

<p>

<dt><encaps>NOTA BENE</encaps><dd>
Short technical documentation on a font file:
     This object adds the text-drawing and -creation
     capabilities of the <link to=Image>Image</link> module.

<p>     For simple usage, see
     <link to=Image.font.write>write</link> and <link to=Image.font.load>load</link>.

<p>     other methods: <link to=Image.font.baseline>baseline</link>,
     <link to=Image.font.height>height</link>,
     <link to=Image.font.set_xspacing_scale>set_xspacing_scale</link>,
     <link to=Image.font.set_yspacing_scale>set_yspacing_scale</link>,
     <link to=Image.font.text_extents>text_extents</link>
     
     <pre>
            struct file_head 
            {
               unsigned INT32 cookie;   - 0x464f4e54 
               unsigned INT32 version;  - 1 
               unsigned INT32 chars;    - number of chars
               unsigned INT32 height;   - height of font
               unsigned INT32 baseline; - font baseline
               unsigned INT32 o[1];     - position of char_head's
            } *fh;
            struct char_head
            {
               unsigned INT32 width;    - width of this character
               unsigned INT32 spacing;  - spacing to next character
               unsigned char data[1];   - pixmap data (1byte/pixel)
            } *ch;
     </pre>
<p>

<dt><encaps>SEE ALSO</encaps><dd>
<link to=Image>Image</link>,
     <link to=Image.image>Image.image</link>
<p>

</dl>

<hr newpage>
<anchor name=Image.font.baseline>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.font->baseline</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
int <b>baseline</b>()
<p>

<dt><encaps>RETURN VALUE</encaps><dd>
font baseline (pixels from top)
<p>

<dt><encaps>SEE ALSO</encaps><dd>
<link to=Image.font.height>height</link>,
     <link to=Image.font.text_extents>text_extents</link>
<p>

</dl>

</anchor name=Image.font.baseline>



<hr newpage>
<anchor name=Image.font.text_extents>
<anchor name=Image.font.height>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.font->height</tt><br>
	<tt>Image.font->text_extents</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
int <b>height</b>()<br>
	array(int) <b>text_extents</b>(string&nbsp;text, ...)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
Calculate extents of a text-image,
     that would be created by calling <link to=Image.font.write>write</link>
     with the same arguments.
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>string text, ...</tt></td>	<td valign=bottom>One or more lines of text.</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
an array of width and height
<p>

<dt><encaps>SEE ALSO</encaps><dd>
<link to=Image.font.write>write</link>,
     <link to=Image.font.height>height</link>,
     <link to=Image.font.baseline>baseline</link>
<p>

</dl>

</anchor name=Image.font.height>
</anchor name=Image.font.text_extents>



<hr newpage>
<anchor name=Image.font.load>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.font->load</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object|int <b>load</b>(string&nbsp;filename)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
Loads a font file to this font object.
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>string filename</tt></td>	<td valign=bottom>Font file</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
zero upon failure, font object upon success
<p>

<dt><encaps>SEE ALSO</encaps><dd>
<link to=Image.font.write>write</link>
<p>

</dl>

</anchor name=Image.font.load>



<hr newpage>
<anchor name=Image.font.set_xspacing_scale>
<anchor name=Image.font.set_yspacing_scale>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.font->set_xspacing_scale</tt><br>
	<tt>Image.font->set_yspacing_scale</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
void <b>set_xspacing_scale</b>(float&nbsp;scale)<br>
	void <b>set_yspacing_scale</b>(float&nbsp;scale)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
Set spacing scale to write characters closer
     or more far away. This does not change scale
     of character, only the space between them.
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>float scale</tt></td>	<td valign=bottom>what scale to use</td></tr>

</table><p>

</dl>

</anchor name=Image.font.set_xspacing_scale>
</anchor name=Image.font.set_yspacing_scale>



<hr newpage>
<anchor name=Image.font.write>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.font->write</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>write</b>(string&nbsp;text, ...)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
Writes some text; thus creating an image object
     that can be used as mask or as a complete picture.
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>string text, ...</tt></td>	<td valign=bottom>One or more lines of text.</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
an <link to=Image.image>Image.image</link> object
<p>

<dt><encaps>SEE ALSO</encaps><dd>
<link to=Image.font.text_extents>text_extents</link>,
     <link to=Image.font.load>load</link>,
     <link to=Image.image.paste_mask>Image.image->paste_mask</link>,
     <link to=Image.image.paste_alpha_color>Image.image->paste_alpha_color</link>
<p>

</dl>

</anchor name=Image.font.write>



</anchor name=Image.font>



</section title="Image.font">



<section title="Image.image">
<hr newpage>
<anchor name=Image.image>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image</tt><br>
<p>
<dt><encaps>DESCRIPTION</encaps><dd>
The main object of the <link to=Image>Image</link> module, this object
     is used as drawing area, mask or result of operations.

<p>     init: <link to=Image.image.clear>clear</link>,
     <link to=Image.image.clone>clone</link>,
     <link to=Image.image.create>create</link>, 
     <link to=Image.image.xsize>xsize</link>,
     <link to=Image.image.ysize>ysize</link>

<p>     plain drawing: <link to=Image.image.box>box</link>,
     <link to=Image.image.circle>circle</link>,
     <link to=Image.image.getpixel>getpixel</link>, 
     <link to=Image.image.line>line</link>,
     <link to=Image.image.setcolor>setcolor</link>,
     <link to=Image.image.setpixel>setpixel</link>, 
     <link to=Image.image.treshold>treshold</link>,
     <link to=Image.image.tuned_box>tuned_box</link>,
     <link to=Image.image.polygone>polygone</link>

<p>     operators: <link to=Image.image.`&>`&amp;</link>,
     <link to=Image.image.`*>`*</link>,
     <link to=Image.image.`+>`+</link>,
     <link to=Image.image.`->`-</link>,
     <link to=Image.image.`|>`|</link>

<p>     pasting images, layers: <link to=Image.image.add_layers>add_layers</link>, 
     <link to=Image.image.paste>paste</link>,
     <link to=Image.image.paste_alpha>paste_alpha</link>,
     <link to=Image.image.paste_alpha_color>paste_alpha_color</link>,
     <link to=Image.image.paste_mask>paste_mask</link>

<p>     getting subimages, scaling, rotating: <link to=Image.image.autocrop>autocrop</link>, 
     <link to=Image.image.clone>clone</link>,
     <link to=Image.image.copy>copy</link>, 
     <link to=Image.image.dct>dct</link>,
     <link to=Image.image.mirrorx>mirrorx</link>, 
     <link to=Image.image.rotate>rotate</link>,
     <link to=Image.image.rotate_expand>rotate_expand</link>, 
     <link to=Image.image.rotate_ccw>rotate_ccw</link>,
     <link to=Image.image.rotate_cw>rotate_cw</link>,
     <link to=Image.image.scale>scale</link>, 
     <link to=Image.image.skewx>skewx</link>,
     <link to=Image.image.skewx_expand>skewx_expand</link>,
     <link to=Image.image.skewy>skewy</link>,
     <link to=Image.image.skewy_expand>skewy_expand</link>

<p>     calculation by pixels: <link to=Image.image.apply_matrix>apply_matrix</link>, 
     <link to=Image.image.change_color>change_color</link>,
     <link to=Image.image.color>color</link>,
     <link to=Image.image.distancesq>distancesq</link>, 
     <link to=Image.image.grey>grey</link>,
     <link to=Image.image.invert>invert</link>, 
     <link to=Image.image.modify_by_intensity>modify_by_intensity</link>,
     <link to=Image.image.select_from>select_from</link>, 
     <link to=Image.image.rgb_to_hsv>rgb_to_hsv</link>,
     <link to=Image.image.hsv_to_rgb>hsv_to_rgb</link>,
     <link to=Image.colortable>Image.colortable</link>

<p>     converting to other datatypes: 
     <link to=Image.GIF>Image.GIF</link>,
     <link to=Image.PNM>Image.PNM</link>

<p>     special pattern drawing:
     <link to=Image.image.noise>noise</link>,
     <link to=Image.image.turbulence>turbulence</link>
<p>

<dt><encaps>SEE ALSO</encaps><dd>
<link to=Image>Image</link>,
     <link to=Image.font>Image.font</link>
<p>

</dl>

<hr newpage>
<anchor name=Image.image.add_layers>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->add_layers</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>add_layers</b>(array(int|object))&nbsp;layer0, ...)<br>
	object <b>add_layers</b>(int&nbsp;x1, int&nbsp;y1, int&nbsp;x2, int&nbsp;y2, array(int|object))&nbsp;layer0, ...)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
Using the called object as base, adds layers using masks,
     opaque channel values and special methods.

<p>     The destination image can also be cropped, thus
     speeding up the process.

<p>     Each array in the layers array is one of:
     <pre>
     ({object image,object|int mask})
     ({object image,object|int mask,int opaque_value})
     ({object image,object|int mask,int opaque_value,int method})
     </pre>
     Given 0 as mask means the image is totally opaque.

<p>     Default opaque value is 255, only using the mask.

<p>     Methods for now are:
     <pre>
     0  no operation (just paste with mask, default)
     1  maximum  (`|)
     2  minimum  (`&amp;)
     3  multiply (`*)
     4  add      (`+)
     5  diff     (`-)
     </pre>
     The layer image and the current source are calculated
     through the given method and then pasted using the mask
     and the opaque channel value. 

<p>     All given images must be the same size.
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>array(int|object) layer0</tt></td>	<td valign=bottom>image to paste</td></tr>

	<tr align=left><td valign=top>
<tt>int x1</tt><br>
		<tt>int y1</tt><br>
		<tt>int x2</tt><br>
		<tt>int y2</tt></td>	<td valign=bottom>rectangle for cropping</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
a new image object
<p>

<dt><encaps>SEE ALSO</encaps><dd>
<link to=Image.image.paste_mask>paste_mask</link>,
     <link to=Image.image.paste_alpha>paste_alpha</link>,
     <link to=Image.image.paste_alpha_color>paste_alpha_color</link>,
     <link to=Image.image.`|>`|</link>,
     <link to=Image.image.`&>`&</link>,
     <link to=Image.image.`*>`*</link>,
     <link to=Image.image.`+>`+</link>,
     <link to=Image.image.`->`-</link>
<p>

</dl>

</anchor name=Image.image.add_layers>



<hr newpage>
<anchor name=Image.image.apply_matrix>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->apply_matrix</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>apply_matrix</b>(array(array(int|array(int)))&nbsp;matrix)<br>
	object <b>apply_matrix</b>(array(array(int|array(int)))&nbsp;matrix, int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
	object <b>apply_matrix</b>(array(array(int|array(int)))&nbsp;matrix, int&nbsp;r, int&nbsp;g, int&nbsp;b, int|float&nbsp;div)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
Applies a pixel-transform matrix, or filter, to the image.
    
     <pre>
                            2   2
     pixel(x,y)= base+ k ( sum sum pixel(x+k-1,y+l-1)*matrix(k,l) ) 
                           k=0 l=0 
     </pre>
     
     1/k is sum of matrix, or sum of matrix multiplied with div.
     base is given by r,g,b and is normally black.

<p>     <table><tr><td rowspan=2>
     blur (ie a 2d gauss function):
     <pre>
     ({({1,2,1}),
       ({2,5,2}),
       ({1,2,1})})
     </pre>
     </td><td>
     <illustration __from__='image.c line 2049' src=lena.gif>

     return src->apply_matrix(
     ({({1,2,1}),
       ({2,5,2}),
       ({1,2,1})})
     );
     </illustration>
     </td><td>
     <illustration __from__='image.c line 2049' src=lena.gif>

     return src;
     </illustration>
     </td></tr>
     <tr><td></td><td>original</td></tr>
     
     <tr><td>
     sharpen (k>8, preferably 12 or 16):
     <pre>
     ({({-1,-1,-1}),
       ({-1, k,-1}),
       ({-1,-1,-1})})
     </pre>
     </td><td>
     <illustration __from__='image.c line 2049' src=lena.gif>

     return src->apply_matrix(
     ({({-1,-1,-1}),
       ({-1,14,-1}),
       ({-1,-1,-1})})
     );
     </illustration>
     </td></tr>

<p>     <tr><td>
     edge detect:
     <pre>
     ({({1, 1,1}),
       ({1,-8,1}),
       ({1, 1,1})})
     </pre>
     </td><td>
     <illustration __from__='image.c line 2049' src=lena.gif>

     return src->apply_matrix(
     ({({1, 1,1}),
       ({1,-8,1}),
       ({1, 1,1})})
     );
     </illustration>
     </td></tr>

<p>     <tr><td>
     horisontal edge detect (get the idea):
     <pre>
     ({({0, 0,0}),
       ({1,-2,1}),
       ({0, 0,0})})
     </pre>
     </td><td>
     <illustration __from__='image.c line 2049' src=lena.gif>

     return src->apply_matrix(
     ({({0, 0,0}),
       ({1,-2,1}),
       ({0, 0,0})})
     );
     </illustration>
     </td></tr>

<p>     <tr><td rowspan=2>
     emboss (might prefer to begin with a <link to=Image.image.grey>grey</link> image):
     <pre>
     ({({2, 1, 0}),
       ({1, 0,-1}),
       ({0,-1,-2})}), 128,128,128, 3
     </pre>
     </td><td>
     <illustration __from__='image.c line 2049' src=lena.gif>

     return src->apply_matrix(
     ({({2, 1, 0}),
       ({1, 0,-1}),
       ({0,-1,-2})}), 128,128,128, 3
     );
     </illustration>
     </td><td>
     <illustration __from__='image.c line 2049' src=lena.gif>

     return src->grey()->apply_matrix(
     ({({2, 1, 0}),
       ({1, 0,-1}),
       ({0,-1,-2})}), 128,128,128, 3
     );
     </illustration>
     </td></tr>
     <tr><td></td><td>greyed</td></tr></table>

<p>     This function is not very fast.
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>array(array(int|array(int)))</tt></td>	<td valign=bottom>the matrix; innermost is a value or an array with red, green, blue
     values for red, green, blue separation.</td></tr>

	<tr align=left><td valign=top>
<tt>int r</tt><br>
		<tt>int g</tt><br>
		<tt>int b</tt></td>	<td valign=bottom>base level of result, default is zero</td></tr>

	<tr align=left><td valign=top>
<tt>int|float div</tt></td>	<td valign=bottom>division factor, default is 1.0.</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
the new image object
<p>

</dl>

</anchor name=Image.image.apply_matrix>



<hr newpage>
<anchor name=Image.image.autocrop>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->autocrop</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>autocrop</b>()<br>
	object <b>autocrop</b>(int&nbsp;border)<br>
	object <b>autocrop</b>(int&nbsp;border, int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
	object <b>autocrop</b>(int&nbsp;border, int&nbsp;left, int&nbsp;right, int&nbsp;top, int&nbsp;bottom)<br>
	object <b>autocrop</b>(int&nbsp;border, int&nbsp;left, int&nbsp;right, int&nbsp;top, int&nbsp;bottom, int&nbsp;r, int&nbsp;g, int&nbsp;b)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
Removes "unneccesary" borders around the image, adds one of
     its own if wanted to, in selected directions.

<p>     "Unneccesary" is all pixels that are equal -- ie if all the same pixels
     to the left are the same color, that column of pixels are removed.
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>int border</tt></td>	<td valign=bottom>added border size in pixels</td></tr>

	<tr align=left><td valign=top>
<tt>int r</tt><br>
		<tt>int g</tt><br>
		<tt>int b</tt></td>	<td valign=bottom>color of the new border</td></tr>

	<tr align=left><td valign=top>
<tt>int left</tt><br>
		<tt>int right</tt><br>
		<tt>int top</tt><br>
		<tt>int bottom</tt></td>	<td valign=bottom>which borders to scan and cut the image; 
     a typical example is removing the top and bottom unneccesary
     pixels:
     <pre>img=img-&gt;autocrop(0, 0,0,1,1);</pre></td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
the new image object
<p>

<dt><encaps>SEE ALSO</encaps><dd>
<link to=Image.image.copy>copy</link>
<p>

</dl>

</anchor name=Image.image.autocrop>



<hr newpage>
<anchor name=Image.image.box>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->box</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>box</b>(int&nbsp;x1, int&nbsp;y1, int&nbsp;x2, int&nbsp;y2)<br>
	object <b>box</b>(int&nbsp;x1, int&nbsp;y1, int&nbsp;x2, int&nbsp;y2, int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
	object <b>box</b>(int&nbsp;x1, int&nbsp;y1, int&nbsp;x2, int&nbsp;y2, int&nbsp;r, int&nbsp;g, int&nbsp;b, int&nbsp;alpha)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
Draws a filled rectangle on the image.
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>int x1</tt><br>
		<tt>int y1</tt><br>
		<tt>int x2</tt><br>
		<tt>int y2</tt></td>	<td valign=bottom>box corners</td></tr>

	<tr align=left><td valign=top>
<tt>int r</tt><br>
		<tt>int g</tt><br>
		<tt>int b</tt></td>	<td valign=bottom>color of the box</td></tr>

	<tr align=left><td valign=top>
<tt>int alpha</tt></td>	<td valign=bottom>alpha value</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
the object called
<p>

</dl>

</anchor name=Image.image.box>



<hr newpage>
<anchor name=Image.image.cast>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->cast</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
string <b>cast</b>(string&nbsp;type)
<p>

<dt><encaps>RETURN VALUE</encaps><dd>
the image data as a string ("rgbrgbrgb...")
<p>

<dt><encaps>SEE ALSO</encaps><dd>
<link to=Image.colortable>Image.colortable</link>
<p>

</dl>

</anchor name=Image.image.cast>



<hr newpage>
<anchor name=Image.image.change_color>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->change_color</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>change_color</b>(int&nbsp;tor, int&nbsp;tog, int&nbsp;tob)<br>
	object <b>change_color</b>(int&nbsp;fromr, int&nbsp;fromg, int&nbsp;fromb, &nbsp;int&nbsp;tor, int&nbsp;tog, int&nbsp;tob)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
Changes one color (exakt match) to another.
     If non-exakt-match is preferred, check <link to=Image.image.distancesq>distancesq</link>
     and <link to=Image.image.paste_alpha_color>paste_alpha_color</link>.
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>int tor</tt><br>
		<tt>int tog</tt><br>
		<tt>int tob</tt></td>	<td valign=bottom>destination color and next current color</td></tr>

	<tr align=left><td valign=top>
<tt>int fromr</tt><br>
		<tt>int fromg</tt><br>
		<tt>int fromb</tt></td>	<td valign=bottom>source color, default is current color</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
a new (the destination) image object
<p>

</dl>

</anchor name=Image.image.change_color>



<hr newpage>
<anchor name=Image.image.circle>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->circle</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>circle</b>(int&nbsp;x, int&nbsp;y, int&nbsp;rx, int&nbsp;ry)<br>
	object <b>circle</b>(int&nbsp;x, int&nbsp;y, int&nbsp;rx, int&nbsp;ry, int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
	object <b>circle</b>(int&nbsp;x, int&nbsp;y, int&nbsp;rx, int&nbsp;ry, int&nbsp;r, int&nbsp;g, int&nbsp;b, int&nbsp;alpha)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
Draws a line on the image. The line is <i>not</i> antialiased.
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>int x</tt><br>
		<tt>int y</tt></td>	<td valign=bottom>circle center</td></tr>

	<tr align=left><td valign=top>
<tt>int rx</tt><br>
		<tt>int ry</tt></td>	<td valign=bottom>circle radius in pixels</td></tr>

	<tr align=left><td valign=top>
<tt>int r</tt><br>
		<tt>int g</tt><br>
		<tt>int b</tt></td>	<td valign=bottom>color</td></tr>

	<tr align=left><td valign=top>
<tt>int alpha</tt></td>	<td valign=bottom>alpha value</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
the object called
<p>

</dl>

</anchor name=Image.image.circle>



<hr newpage>
<anchor name=Image.image.clear>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->clear</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
void <b>clear</b>()<br>
	void <b>clear</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
	void <b>clear</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b, int&nbsp;alpha)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
gives a new, cleared image with the same size of drawing area
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>int r</tt><br>
		<tt>int g</tt><br>
		<tt>int b</tt></td>	<td valign=bottom>color of the new image</td></tr>

	<tr align=left><td valign=top>
<tt>int alpha</tt></td>	<td valign=bottom>new default alpha channel value</td></tr>

</table><p>

<dt><encaps>SEE ALSO</encaps><dd>
<link to=Image.image.copy>copy</link>,
     <link to=Image.image.clone>clone</link>
<p>

</dl>

</anchor name=Image.image.clear>



<hr newpage>
<anchor name=Image.image.clone>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->clone</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>clone</b>()<br>
	object <b>clone</b>(int&nbsp;xsize, int&nbsp;ysize)<br>
	object <b>clone</b>(int&nbsp;xsize, int&nbsp;ysize, int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
	object <b>clone</b>(int&nbsp;xsize, int&nbsp;ysize, int&nbsp;r, int&nbsp;g, int&nbsp;b, int&nbsp;alpha)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
Copies to or initialize a new image object.
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>int xsize</tt><br>
		<tt>int ysize</tt></td>	<td valign=bottom>size of (new) image in pixels, called image
     is cropped to that size</td></tr>

	<tr align=left><td valign=top>
<tt>int r</tt><br>
		<tt>int g</tt><br>
		<tt>int b</tt></td>	<td valign=bottom>current color of the new image, 
     default is black. 
     Will also be the background color if the cloned image
     is empty (no drawing area made).</td></tr>

	<tr align=left><td valign=top>
<tt>int alpha</tt></td>	<td valign=bottom>new default alpha channel value</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
the new object
<p>

<dt><encaps>SEE ALSO</encaps><dd>
<link to=Image.image.copy>copy</link>,
     <link to=Image.image.create>create</link>
<p>

</dl>

</anchor name=Image.image.clone>



<hr newpage>
<anchor name=Image.image.color>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->color</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>color</b>()<br>
	object <b>color</b>(int&nbsp;value)<br>
	object <b>color</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
Colorize an image. 

<p>    The red, green and blue values of the pixels are multiplied
    with the given value(s). This works best on a grey image...

<p>    The result is divided by 255, giving correct pixel values.

<p>    If no arguments are given, the current color is used as factors.

<p>     <table><tr valign=center>
     <td><illustration __from__='image.c line 1358' src=lena.gif>
 return src; </illustration></td>
     <td><illustration __from__='image.c line 1358' src=lena.gif>
 return src->color(128,128,255); </illustration></td>
     </tr><tr valign=center>
     <td>original</td>
     <td>-&gt;color(128,128,255);</td>
     </tr></table>
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>int r</tt><br>
		<tt>int g</tt><br>
		<tt>int b</tt></td>	<td valign=bottom>red, green, blue factors</td></tr>

	<tr align=left><td valign=top>
<tt>int value</tt></td>	<td valign=bottom>factor</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
the new image object
<p>

<dt><encaps>SEE ALSO</encaps><dd>
<link to=Image.image.grey>grey</link>,
     <link to=Image.image.`*>`*</link>,
     <link to=Image.image.modify_by_intensity>modify_by_intensity</link>
<p>

</dl>

</anchor name=Image.image.color>



<hr newpage>
<anchor name=Image.image.copy>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->copy</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>copy</b>()<br>
	object <b>copy</b>(int&nbsp;x1, int&nbsp;y1, int&nbsp;x2, int&nbsp;y2)<br>
	object <b>copy</b>(int&nbsp;x1, int&nbsp;y1, int&nbsp;x2, int&nbsp;y2, int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
	object <b>copy</b>(int&nbsp;x1, int&nbsp;y1, int&nbsp;x2, int&nbsp;y2, int&nbsp;r, int&nbsp;g, int&nbsp;b, int&nbsp;alpha)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
Copies this part of the image. The requested area can
     be smaller, giving a cropped image, or bigger - 
     the new area will be filled with the given or current color.
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>int x1</tt><br>
		<tt>int y1</tt><br>
		<tt>int x2</tt><br>
		<tt>int y2</tt></td>	<td valign=bottom>The requested new area. Default is the old image size.</td></tr>

	<tr align=left><td valign=top>
<tt>int r</tt><br>
		<tt>int g</tt><br>
		<tt>int b</tt></td>	<td valign=bottom>color of the new image</td></tr>

	<tr align=left><td valign=top>
<tt>int alpha</tt></td>	<td valign=bottom>new default alpha channel value</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
a new image object
<p>

<dt><encaps>NOTA BENE</encaps><dd>
<link to=Image.image.clone>clone</link>(void) and <link to=Image.image.copy>copy</link>(void) does the same 
     operation
<p>

<dt><encaps>SEE ALSO</encaps><dd>
<link to=Image.image.clone>clone</link>,
     <link to=Image.image.autocrop>autocrop</link>
<p>

</dl>

</anchor name=Image.image.copy>



<hr newpage>
<anchor name=Image.image.create>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->create</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
void <b>create</b>()<br>
	void <b>create</b>(int&nbsp;xsize, int&nbsp;ysize)<br>
	void <b>create</b>(int&nbsp;xsize, int&nbsp;ysize, int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
	void <b>create</b>(int&nbsp;xsize, int&nbsp;ysize, int&nbsp;r, int&nbsp;g, int&nbsp;b, int&nbsp;alpha)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
Initializes a new image object.
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>int xsize</tt><br>
		<tt>int ysize</tt></td>	<td valign=bottom>size of (new) image in pixels</td></tr>

	<tr align=left><td valign=top>
<tt>int r</tt><br>
		<tt>int g</tt><br>
		<tt>int b</tt></td>	<td valign=bottom>background color (will also be current color),
     default color is black</td></tr>

	<tr align=left><td valign=top>
<tt>int alpha</tt></td>	<td valign=bottom>default alpha channel value</td></tr>

</table><p>

<dt><encaps>SEE ALSO</encaps><dd>
<link to=Image.image.copy>copy</link>,
     <link to=Image.image.clone>clone</link>,
     <link to=Image.image>Image.image</link>
<p>

</dl>

</anchor name=Image.image.create>



<hr newpage>
<anchor name=Image.image.dct>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->dct</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>dct</b>(int&nbsp;newx, int&nbsp;newy)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
Scales the image to a new size.
     
     Method for scaling is rather complex;
     the image is transformed via a cosine transform,
     and then resampled back.

<p>     This gives a quality-conserving upscale,
     but the algorithm used is n*n+n*m, where n
     and m is pixels in the original and new image.

<p>     Recommended wrapping algorithm is to scale
     overlapping parts of the image-to-be-scaled.

<p>     This functionality is actually added as an
     true experiment, but works...
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>int newx</tt><br>
		<tt>int newy</tt></td>	<td valign=bottom>new image size in pixels</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
the new image object
<p>

<dt><encaps>NOTA BENE</encaps><dd>
Do NOT use this function if you don't know what 
     you're dealing with! Read some signal theory first...
<p>

</dl>

</anchor name=Image.image.dct>



<hr newpage>
<anchor name=Image.image.distancesq>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->distancesq</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>distancesq</b>()<br>
	object <b>distancesq</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
Makes an grey-scale image, for alpha-channel use.
    
    The given value (or current color) are used for coordinates
    in the color cube. Each resulting pixel is the 
    distance from this point to the source pixel color,
    in the color cube, squared, rightshifted 8 steps:

<p>    <pre>
    p = pixel color
    o = given color
    d = destination pixel
    d.red=d.blue=d.green=
        ((o.red-p.red)²+(o.green-p.green)²+(o.blue-p.blue)²)>>8
    </pre>

<p>     <table><tr valign=center>
     <td><illustration __from__='image.c line 1786' src=lena.gif>
 return src; </illustration></td>
     <td><illustration __from__='image.c line 1786' src=lena.gif>
 return src->distancesq(255,0,128); </illustration></td>
     </tr><tr valign=center>
     <td>original</td>
     <td>-&gt;distancesq(255,0,128);</td>
     </tr></table>
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>int r</tt><br>
		<tt>int g</tt><br>
		<tt>int b</tt></td>	<td valign=bottom>red, green, blue coordinates</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
the new image object
<p>

<dt><encaps>SEE ALSO</encaps><dd>
<link to=Image.image.select_from>select_from</link>
<p>

</dl>

</anchor name=Image.image.distancesq>



<hr newpage>
<anchor name=Image.image.frompnm>
<anchor name=Image.image.fromppm>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->frompnm</tt><br>
	<tt>Image.image->fromppm</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object|string <b>frompnm</b>(string&nbsp;pnm)<br>
	object|string <b>fromppm</b>(string&nbsp;pnm)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
<b>compability method</b> - do not use in new programs.
     
     See <link to=Image.PNM.decode>Image.PNM.decode</link>().
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>string pnm</tt></td>	<td valign=bottom>pnm data, as a string</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
the called object or a hint of what wronged.
<p>

</dl>

</anchor name=Image.image.frompnm>
</anchor name=Image.image.fromppm>



<hr newpage>
<anchor name=Image.image.getpixel>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->getpixel</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
array(int) <b>getpixel</b>(int&nbsp;x, int&nbsp;y)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>

<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>int x</tt><br>
		<tt>int y</tt></td>	<td valign=bottom>position of the pixel</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
color of the requested pixel -- ({int red,int green,int blue})
<p>

</dl>

</anchor name=Image.image.getpixel>



<hr newpage>
<anchor name=Image.image.gif_begin>
<anchor name=Image.image.gif_add>
<anchor name=Image.image.gif_end>
<anchor name=Image.image.gif_netscape_loop>
<anchor name=Image.image.gif_add_nomap>
<anchor name=Image.image.gif_add_fs_nomap>
<anchor name=Image.image.togif>
<anchor name=Image.image.togif_fs>
<anchor name=Image.image.gif_add_fs>
<anchor name=Image.image.gif_add*>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->gif_add</tt><br>
	<tt>Image.image->gif_add*</tt><br>
	<tt>Image.image->gif_add_fs</tt><br>
	<tt>Image.image->gif_add_fs_nomap</tt><br>
	<tt>Image.image->gif_add_nomap</tt><br>
	<tt>Image.image->gif_begin</tt><br>
	<tt>Image.image->gif_end</tt><br>
	<tt>Image.image->gif_netscape_loop</tt><br>
	<tt>Image.image->togif</tt><br>
	<tt>Image.image->togif_fs</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
string <b>gif_begin</b>()<br>
	string <b>gif_begin</b>(int&nbsp;num_colors)<br>
	string <b>gif_begin</b>(array(array(int))&nbsp;colors)<br>
	string <b>gif_end</b>()<br>
	string <b>gif_netscape_loop</b>(int&nbsp;loops)<br>
	string <b>togif</b>()<br>
	string <b>togif</b>(int&nbsp;trans_r, int&nbsp;trans_g, int&nbsp;trans_b)<br>
	string <b>togif</b>(int&nbsp;num_colors, int&nbsp;trans_r, int&nbsp;trans_g, int&nbsp;trans_b)<br>
	string <b>togif</b>(array(array(int))&nbsp;colors, int&nbsp;trans_r, int&nbsp;trans_g, int&nbsp;trans_b)<br>
	string <b>togif_fs</b>()<br>
	string <b>togif_fs</b>(int&nbsp;trans_r, int&nbsp;trans_g, int&nbsp;trans_b)<br>
	string <b>togif_fs</b>(int&nbsp;num_colors, int&nbsp;trans_r, int&nbsp;trans_g, int&nbsp;trans_b)<br>
	string <b>togif_fs</b>(array(array(int))&nbsp;colors, int&nbsp;trans_r, int&nbsp;trans_g, int&nbsp;trans_b)<br>
	string <b>gif_add</b>()<br>
	string <b>gif_add_fs</b>()<br>
	string <b>gif_add_nomap</b>()<br>
	string <b>gif_add_fs_nomap</b>()<br>
	string <b>gif_add*</b>(int&nbsp;x, int&nbsp;y)<br>
	string <b>gif_add*</b>(int&nbsp;x, int&nbsp;y, int&nbsp;delay_cs)<br>
	string <b>gif_add*</b>(int&nbsp;x, int&nbsp;y, int&nbsp;num_colors, int&nbsp;delay_cs)<br>
	string <b>gif_add*</b>(int&nbsp;x, int&nbsp;y, array(array(int))&nbsp;colors, int&nbsp;delay_cs)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
old GIF API compatibility function. Don't use 
     in any new code. 

<p>     <table>
     <tr><td></td><td>is replaced by</td></tr>
     <tr><td>gif_begin</td><td><link to=Image.GIF.header_block>Image.GIF.header_block</link></td></tr>
     <tr><td>gif_end</td><td><link to=Image.GIF.end_block>Image.GIF.end_block</link></td></tr>
     <tr><td>gif_netscape_loop</td><td><link to=Image.GIF.netscape_loop_block>Image.GIF.netscape_loop_block</link></td></tr>
     <tr><td>togif</td><td><link to=Image.GIF.encode>Image.GIF.encode</link></td></tr>
     <tr><td>togif_fs</td><td><link to=Image.GIF.encode>Image.GIF.encode</link>¹</td></tr>
     <tr><td>gif_add</td><td><link to=Image.GIF.render_block>Image.GIF.render_block</link>¹²</td></tr>
     <tr><td>gif_add_fs</td><td><link to=Image.GIF.render_block>Image.GIF.render_block</link>¹</td></tr>
     <tr><td>gif_add_nomap</td><td><link to=Image.GIF.render_block>Image.GIF.render_block</link>²</td></tr>
     <tr><td>gif_add_fs_nomap</td><td><link to=Image.GIF.render_block>Image.GIF.render_block</link>¹²</td></tr>
     </table>

<p>     ¹ Use <link to=Image.colortable>Image.colortable</link> to get whatever dithering
     you want.

<p>     ² local map toggle is sent as an argument
<p>

<dt><encaps>RETURN VALUE</encaps><dd>
GIF data.
<p>

</dl>

</anchor name=Image.image.gif_add>
</anchor name=Image.image.gif_add*>
</anchor name=Image.image.gif_add_fs>
</anchor name=Image.image.gif_add_fs_nomap>
</anchor name=Image.image.gif_add_nomap>
</anchor name=Image.image.gif_begin>
</anchor name=Image.image.gif_end>
</anchor name=Image.image.gif_netscape_loop>
</anchor name=Image.image.togif>
</anchor name=Image.image.togif_fs>



<hr newpage>
<anchor name=Image.image.grey>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->grey</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>grey</b>()<br>
	object <b>grey</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
Makes a grey-scale image (with weighted values).

<p>
     <table><tr valign=center>
     <td><illustration __from__='image.c line 1287' src=lena.gif>
 return src; </illustration></td>
     <td><illustration __from__='image.c line 1287' src=lena.gif>
 return src->grey(); </illustration></td>
     <td><illustration __from__='image.c line 1287' src=lena.gif>
 return src->grey(0,0,255); </illustration></td>
     </tr><tr valign=center>
     <td>original</td>
     <td>-&gt;grey();</td>
     <td>-&gt;grey(0,0,255);</td>
     </tr></table>
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>int r</tt><br>
		<tt>int g</tt><br>
		<tt>int b</tt></td>	<td valign=bottom>weight of color, default is r=87,g=127,b=41,
     which should be pretty accurate of what the eyes see...</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
the new image object
<p>

<dt><encaps>SEE ALSO</encaps><dd>
<link to=Image.image.color>color</link>,
     <link to=Image.image.`*>`*</link>,
     <link to=Image.image.modify_by_intensity>modify_by_intensity</link>
<p>

</dl>

</anchor name=Image.image.grey>



<hr newpage>
<anchor name=Image.image.hsv_to_rgb>
<anchor name=Image.image.rgb_to_hsv>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->hsv_to_rgb</tt><br>
	<tt>Image.image->rgb_to_hsv</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>rgb_to_hsv</b>()<br>
	object <b>hsv_to_rgb</b>()
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
Converts RGB data to HSV data, or the other way around.
    When converting to HSV, the resulting data is stored like this:
     pixel.r = h; pixel.g = s; pixel.b = v;

<p>    When converting to RGB, the input data is asumed to be placed in
    the pixels as above.

<p>     <table><tr valign=center>
     <td><illustration __from__='image.c line 1574' src=lena.gif>
 return src; </illustration></td>
     <td><illustration __from__='image.c line 1574' src=lena.gif>
 return src->hsv_to_rgb(); </illustration></td>
     <td><illustration __from__='image.c line 1574' src=lena.gif>
 return src->rgb_to_hsv(); </illustration></td>
     </tr><tr valign=center>
     <td>original</td>
     <td>-&gt;hsv_to_rgb();</td>
     <td>-&gt;rgb_to_hsv();</td>
     </tr><tr valign=center>
     <td><illustration __from__='image.c line 1574' src=lena.gif>

     return image(67,67)->tuned_box(0,0, 67,67,
                      ({ ({ 255,255,128 }), ({ 0,255,128 }),
                         ({ 255,255,255 }), ({ 0,255,255 })}));
     </illustration></td>
     <td><illustration __from__='image.c line 1574' src=lena.gif>

     return image(67,67)->tuned_box(0,0, 67,67,
                      ({ ({ 255,255,128 }), ({ 0,255,128 }),
                         ({ 255,255,255 }), ({ 0,255,255 })}))
          ->hsv_to_rgb();
     </illustration></td>
     <td><illustration __from__='image.c line 1574' src=lena.gif>

     return image(67,67)->tuned_box(0,0, 67,67,
                      ({ ({ 255,255,128 }), ({ 0,255,128 }),
                         ({ 255,255,255 }), ({ 0,255,255 })}))
          ->rgb_to_hsv();
     </illustration></td>
     </tr><tr valign=center>
     <td>tuned box (below)</td>
     <td>the rainbow (below)</td>
     <td>same, but rgb_to_hsv()</td>
     </tr></table>

<p>
    HSV to RGB calculation:
    <pre>
    in = input pixel
    out = destination pixel
    h=-pos*c_angle*3.1415/(float)NUM_SQUARES;
    out.r=(in.b+in.g*cos(in.r));
    out.g=(in.b+in.g*cos(in.r + pi*2/3));
    out.b=(in.b+in.g*cos(in.r + pi*4/3));
    </pre>

<p>    RGB to HSV calculation: Hmm.
    <pre>
    </pre>

<p>     Example: Nice rainbow.
     <pre>
     object i = Image.image(200,200);
     i = i-&gt;tuned_box(0,0, 200,200,
                      ({ ({ 255,255,128 }), ({ 0,255,128 }),
                         ({ 255,255,255 }), ({ 0,255,255 })}))
          -&gt;hsv_to_rgb();
     </pre>
<p>

<dt><encaps>RETURN VALUE</encaps><dd>
the new image object
<p>

</dl>

</anchor name=Image.image.hsv_to_rgb>
</anchor name=Image.image.rgb_to_hsv>



<hr newpage>
<anchor name=Image.image.invert>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->invert</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>invert</b>()
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
Invert an image. Each pixel value gets to be 255-x, where x 
    is the old value.

<p>     <table><tr valign=center>
     <td><illustration __from__='image.c line 1441' src=lena.gif>
 return src; </illustration></td>
     <td><illustration __from__='image.c line 1441' src=lena.gif>
 return src->invert(); </illustration></td>
     <td><illustration __from__='image.c line 1441' src=lena.gif>
 return src->rgb_to_hsv()->invert()->hsv_to_rgb(); </illustration></td>
     </tr><tr valign=center>
     <td>original</td>
     <td>-&gt;invert();</td>
     <td>-&gt;rgb_to_hsv()-&gt;invert()-&gt;hsv_to_rgb();</td>
     </tr></table>
<p>

<dt><encaps>RETURN VALUE</encaps><dd>
the new image object
<p>

</dl>

</anchor name=Image.image.invert>



<hr newpage>
<anchor name=Image.image.line>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->line</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>line</b>(int&nbsp;x1, int&nbsp;y1, int&nbsp;x2, int&nbsp;y2)<br>
	object <b>line</b>(int&nbsp;x1, int&nbsp;y1, int&nbsp;x2, int&nbsp;y2, int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
	object <b>line</b>(int&nbsp;x1, int&nbsp;y1, int&nbsp;x2, int&nbsp;y2, int&nbsp;r, int&nbsp;g, int&nbsp;b, int&nbsp;alpha)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
Draws a line on the image. The line is <i>not</i> antialiased.
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>int x1</tt><br>
		<tt>int y1</tt><br>
		<tt>int x2</tt><br>
		<tt>int y2</tt></td>	<td valign=bottom>line endpoints</td></tr>

	<tr align=left><td valign=top>
<tt>int r</tt><br>
		<tt>int g</tt><br>
		<tt>int b</tt></td>	<td valign=bottom>color</td></tr>

	<tr align=left><td valign=top>
<tt>int alpha</tt></td>	<td valign=bottom>alpha value</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
the object called
<p>

</dl>

</anchor name=Image.image.line>



<hr newpage>
<anchor name=Image.image.map_closest>
<anchor name=Image.image.select_colors>
<anchor name=Image.image.map_fast>
<anchor name=Image.image.map_fs>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->map_closest</tt><br>
	<tt>Image.image->map_fast</tt><br>
	<tt>Image.image->map_fs</tt><br>
	<tt>Image.image->select_colors</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>map_closest</b>(array(array(int))&nbsp;colors)<br>
	object <b>map_fast</b>(array(array(int))&nbsp;colors)<br>
	object <b>map_fs</b>(array(array(int))&nbsp;colors)<br>
	array <b>select_colors</b>(int&nbsp;num)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
Compatibility functions. Do not use!

<p>     Replacement examples:

<p>     Old code:
     <pre>img=map_fs(img-&gt;select_colors(200));</pre>
     New code:
     <pre>img=Image.colortable(img,200)-&gt;floyd_steinberg()-&gt;map(img);</pre>

<p>     Old code:
     <pre>img=map_closest(img-&gt;select_colors(17)+({({255,255,255}),({0,0,0})}));</pre>
     New code:
     <pre>img=Image.colortable(img,19,({({255,255,255}),({0,0,0})}))-&gt;map(img);</pre>
<p>

</dl>

</anchor name=Image.image.map_closest>
</anchor name=Image.image.map_fast>
</anchor name=Image.image.map_fs>
</anchor name=Image.image.select_colors>



<hr newpage>
<anchor name=Image.image.mirrorx>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->mirrorx</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>mirrorx</b>()
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
mirrors an image:
     <table><tr valign=center>
     <td><illustration __from__='matrix.c line 515' src=lena.gif>
 return src; </illustration></td>
     <td><illustration __from__='matrix.c line 515' src=lena.gif>
 return src->mirrorx(); </illustration></td>
     </tr><tr valign=center>
     <td>original</td>
     <td>-&gt;mirrorx();</td>
     </tr></table>
<p>

<dt><encaps>RETURN VALUE</encaps><dd>
the new image object
<p>

</dl>

</anchor name=Image.image.mirrorx>



<hr newpage>
<anchor name=Image.image.mirrory>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->mirrory</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>mirrory</b>()
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
mirrors an image:
     <table><tr valign=center>
     <td><illustration __from__='matrix.c line 566' src=lena.gif>
 return src; </illustration></td>
     <td><illustration __from__='matrix.c line 566' src=lena.gif>
 return src->mirrory(); </illustration></td>
     </tr><tr valign=center>
     <td>original</td>
     <td>-&gt;mirrory();</td>
     </tr></table>
<p>

</dl>

</anchor name=Image.image.mirrory>



<hr newpage>
<anchor name=Image.image.modify_by_intensity>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->modify_by_intensity</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>modify_by_intensity</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b, int|array(int)&nbsp;v1, ..., int|array(int)&nbsp;vn)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
Recolor an image from intensity values.

<p>    For each color an intensity is calculated, from r, g and b factors
    (see <link to=Image.image.grey>grey</link>), this gives a value between 0 and max.

<p>    The color is then calculated from the values given, v1 representing
    the intensity value of 0, vn representing max, and colors between
    representing intensity values between, linear.

<p>     <table><tr valign=center>
     <td><illustration __from__='image.c line 2295' src=lena.gif>
 return src; </illustration></td>
     <td><illustration __from__='image.c line 2295' src=lena.gif>
 return src->grey()->modify_by_intensity(1,0,0,0,({255,0,0}),({0,255,0})); </illustration></td>
     </tr><tr valign=center>
     <td>original</td>
     <td>-&gt;grey()-&gt;modify_by_intensity(1,0,0, 0,({255,0,0}),({0,255,0}));</td>
     </tr></table>
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>int r</tt><br>
		<tt>int g</tt><br>
		<tt>int b</tt></td>	<td valign=bottom>red, green, blue intensity factors</td></tr>

	<tr align=left><td valign=top>
<tt>int|array(int) v1</tt><br>
		<tt>int|array(int) vn</tt></td>	<td valign=bottom>destination color</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
the new image object
<p>

<dt><encaps>SEE ALSO</encaps><dd>
<link to=Image.image.grey>grey</link>,
     <link to=Image.image.`*>`*</link>,
     <link to=Image.image.color>color</link>
<p>

</dl>

</anchor name=Image.image.modify_by_intensity>



<hr newpage>
<anchor name=Image.image.noise>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->noise</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
void <b>noise</b>(array(float|int|array(int))&nbsp;colorrange)<br>
	void <b>noise</b>(array(float|int|array(int))&nbsp;colorrange, float&nbsp;scale, float&nbsp;xdiff, float&nbsp;ydiff, float&nbsp;cscale)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
Gives a new image with the old image's size,
     filled width a 'noise' pattern.

<p>     The random seed may be different with each instance of pike.

<p>     Example: 
     <tt>-&gt;noise( ({0,({255,0,0}), 0.3,({0,255,0}), 0.6,({0,0,255}), 0.8,({255,255,0})}), 0.005,0,0,0.5 );</tt>
     <br><illustration __from__='pattern.c line 192' src=lena.gif>
return image(200,100)->noise( ({0,({255,0,0}), 0.3,({0,255,0}), 0.6,({0,0,255}), 0.8,({255,255,0})}), 0.005,0,0,0.2 );</illustration>
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>array(float|int|array(int)) colorrange</tt></td>	<td valign=bottom>colorrange table</td></tr>

	<tr align=left><td valign=top>
<tt>float scale</tt></td>	<td valign=bottom>default value is 0.1</td></tr>

	<tr align=left><td valign=top>
<tt>float xdiff</tt><br>
		<tt>float ydiff</tt></td>	<td valign=bottom>default value is 0,0</td></tr>

	<tr align=left><td valign=top>
<tt>float cscale</tt></td>	<td valign=bottom>default value is 1</td></tr>

</table><p>

<dt><encaps>SEE ALSO</encaps><dd>
<link to=Image.image.turbulence>turbulence</link>
<p>

</dl>

</anchor name=Image.image.noise>



<hr newpage>
<anchor name=Image.image.paste>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->paste</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>paste</b>(object&nbsp;image)<br>
	object <b>paste</b>(object&nbsp;image, int&nbsp;x, int&nbsp;y)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
Pastes a given image over the current image.
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>object image</tt></td>	<td valign=bottom>image to paste (may be empty, needs to be an image object)</td></tr>

	<tr align=left><td valign=top>
<tt>int x</tt><br>
		<tt>int y</tt></td>	<td valign=bottom>where to paste the image; default is 0,0</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
the object called
<p>

<dt><encaps>SEE ALSO</encaps><dd>
<link to=Image.image.paste_mask>paste_mask</link>,
     <link to=Image.image.paste_alpha>paste_alpha</link>,
     <link to=Image.image.paste_alpha_color>paste_alpha_color</link>
<p>

</dl>

</anchor name=Image.image.paste>



<hr newpage>
<anchor name=Image.image.paste_alpha>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->paste_alpha</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>paste_alpha</b>(object&nbsp;image, int&nbsp;alpha)<br>
	object <b>paste_alpha</b>(object&nbsp;image, int&nbsp;alpha, int&nbsp;x, int&nbsp;y)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
Pastes a given image over the current image, with
     the specified alpha channel value.
     
     An alpha channel value of 0 leaves nothing of the original 
     image in the paste area, 255 is meaningless and makes the
     given image invisible.
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>object image</tt></td>	<td valign=bottom>image to paste</td></tr>

	<tr align=left><td valign=top>
<tt>int alpha</tt></td>	<td valign=bottom>alpha channel value</td></tr>

	<tr align=left><td valign=top>
<tt>int x</tt><br>
		<tt>int y</tt></td>	<td valign=bottom>where to paste the image; default is 0,0</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
the object called
<p>

<dt><encaps>SEE ALSO</encaps><dd>
<link to=Image.image.paste_mask>paste_mask</link>,
     <link to=Image.image.paste>paste</link>,
     <link to=Image.image.paste_alpha_color>paste_alpha_color</link>
<p>

</dl>

</anchor name=Image.image.paste_alpha>



<hr newpage>
<anchor name=Image.image.paste_alpha_color>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->paste_alpha_color</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>paste_alpha_color</b>(object&nbsp;mask)<br>
	object <b>paste_alpha_color</b>(object&nbsp;mask, int&nbsp;x, int&nbsp;y)<br>
	object <b>paste_alpha_color</b>(object&nbsp;mask, int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
	object <b>paste_alpha_color</b>(object&nbsp;mask, int&nbsp;r, int&nbsp;g, int&nbsp;b, int&nbsp;x, int&nbsp;y)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
Pastes a given color over the current image,
    using the given mask as opaque channel.  
    
    A pixel value of 255 makes the result become the color given,
    0 doesn't change anything.
    
    The masks red, green and blue values are used separately.
    If no color are given, the current is used.
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>object mask</tt></td>	<td valign=bottom>mask image</td></tr>

	<tr align=left><td valign=top>
<tt>int r</tt><br>
		<tt>int g</tt><br>
		<tt>int b</tt></td>	<td valign=bottom>what color to paint with; default is current</td></tr>

	<tr align=left><td valign=top>
<tt>int x</tt><br>
		<tt>int y</tt></td>	<td valign=bottom>where to paste the image; default is 0,0</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
the object called
<p>

<dt><encaps>SEE ALSO</encaps><dd>
<link to=Image.image.paste_mask>paste_mask</link>,
     <link to=Image.image.paste_alpha>paste_alpha</link>,
     <link to=Image.image.paste_alpha_color>paste_alpha_color</link>
<p>

</dl>

</anchor name=Image.image.paste_alpha_color>



<hr newpage>
<anchor name=Image.image.paste_mask>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->paste_mask</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>paste_mask</b>(object&nbsp;image, object&nbsp;mask)<br>
	object <b>paste_mask</b>(object&nbsp;image, object&nbsp;mask, int&nbsp;x, int&nbsp;y)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
Pastes a given image over the current image,
    using the given mask as opaque channel.  
    
    A pixel value of 255 makes the result become a pixel
    from the given image, 0 doesn't change anything.

<p>    The masks red, green and blue values are used separately.
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>object image</tt></td>	<td valign=bottom>image to paste</td></tr>

	<tr align=left><td valign=top>
<tt>object mask</tt></td>	<td valign=bottom>mask image</td></tr>

	<tr align=left><td valign=top>
<tt>int x</tt><br>
		<tt>int y</tt></td>	<td valign=bottom>where to paste the image; default is 0,0</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
the object called
<p>

<dt><encaps>SEE ALSO</encaps><dd>
<link to=Image.image.paste>paste</link>,
     <link to=Image.image.paste_alpha>paste_alpha</link>,
     <link to=Image.image.paste_alpha_color>paste_alpha_color</link>
<p>

</dl>

</anchor name=Image.image.paste_mask>



<hr newpage>
<anchor name=Image.image.polygone>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->polygone</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>polygone</b>(array(int|float)&nbsp;...&nbsp;curve)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
fills an area with the current color
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>array(int|float) curve</tt></td>	<td valign=bottom>curve(s), <tt>({x1,y1,x2,y2,...,xn,yn})</tt>,
     automatically closed.

<p>     If any given curve is inside another, it
     will make a hole.</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
the current object
<p>

<dt><encaps>NOTA BENE</encaps><dd>
This function is new (april-97) and rather untested.
<p>

<dt><encaps>SEE ALSO</encaps><dd>
<link to=Image.image.box>box</link>,
     <link to=Image.image.setcolor>setcolor</link>
<p>

</dl>

</anchor name=Image.image.polygone>



<hr newpage>
<anchor name=Image.image.write_lsb_rgb>
<anchor name=Image.image.read_lsb_grey>
<anchor name=Image.image.write_lsb_grey>
<anchor name=Image.image.read_lsb_rgb>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->read_lsb_grey</tt><br>
	<tt>Image.image->read_lsb_rgb</tt><br>
	<tt>Image.image->write_lsb_grey</tt><br>
	<tt>Image.image->write_lsb_rgb</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>write_lsb_rgb</b>(string&nbsp;what)<br>
	object <b>write_lsb_grey</b>(string&nbsp;what)<br>
	string <b>read_lsb_rgb</b>()<br>
	string <b>read_lsb_grey</b>()
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
These functions read/write in the least significant bit
     of the image pixel values. The _rgb() functions
     read/write on each of the red, green and blue values,
     and the grey keeps the same lsb on all three.

<p>     The string is nullpadded or cut to fit.
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>string what</tt></td>	<td valign=bottom>the hidden message</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
the current object or the read string
<p>

</dl>

</anchor name=Image.image.read_lsb_grey>
</anchor name=Image.image.read_lsb_rgb>
</anchor name=Image.image.write_lsb_grey>
</anchor name=Image.image.write_lsb_rgb>



<hr newpage>
<anchor name=Image.image.rotate_expand>
<anchor name=Image.image.rotate>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->rotate</tt><br>
	<tt>Image.image->rotate_expand</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>rotate</b>(int|float&nbsp;angle)<br>
	object <b>rotate</b>(int|float&nbsp;angle, int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
	object <b>rotate_expand</b>(int|float&nbsp;angle)<br>
	object <b>rotate_expand</b>(int|float&nbsp;angle, int&nbsp;r, int&nbsp;g, int&nbsp;b)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
Rotates an image a certain amount of degrees (360° is 
     a complete rotation) counter-clockwise:

<p>     <table><tr valign=center>
     <td><illustration __from__='matrix.c line 1015' src=lena.gif>
 return src; </illustration></td>
     <td><illustration __from__='matrix.c line 1015' src=lena.gif>
 return src->rotate(15,255,0,0); </illustration></td>
     <td><illustration __from__='matrix.c line 1015' src=lena.gif>
 return src->rotate_expand(15); </illustration></td>
     </tr><tr valign=center>
     <td>original</td>
     <td>-&gt;rotate(15,255,0,0);</td>
     <td>-&gt;rotate_expand(15);</td>
     </tr></table>

<p>     The "expand" variant of functions stretches the 
     image border pixels rather then filling with 
     the given or current color.

<p>     This rotate uses the <link to=Image.image.skewx>skewx</link>() and <link to=Image.image.skewy>skewy</link>() functions.
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>int|float angle</tt></td>	<td valign=bottom>the number of degrees to rotate</td></tr>

	<tr align=left><td valign=top>
<tt>int r</tt><br>
		<tt>int g</tt><br>
		<tt>int b</tt></td>	<td valign=bottom>color to fill with; default is current</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
the new image object
<p>

</dl>

</anchor name=Image.image.rotate>
</anchor name=Image.image.rotate_expand>



<hr newpage>
<anchor name=Image.image.rotate_ccw>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->rotate_ccw</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>rotate_ccw</b>()
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
rotates an image counter-clockwise, 90 degrees.

<p>     <table><tr valign=center>
     <td><illustration __from__='matrix.c line 354' src=lena.gif>
 return src; </illustration></td>
     <td><illustration __from__='matrix.c line 354' src=lena.gif>
 return src->rotate_ccw(); </illustration></td>
     </tr><tr valign=center>
     <td>original</td>
     <td>-&gt;rotate_ccw();</td>
     </tr></table>
<p>

<dt><encaps>RETURN VALUE</encaps><dd>
the new image object
<p>

</dl>

</anchor name=Image.image.rotate_ccw>



<hr newpage>
<anchor name=Image.image.rotate_cw>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->rotate_cw</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>rotate_cw</b>()
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
rotates an image clockwise, 90 degrees.

<p>     <table><tr valign=center>
     <td><illustration __from__='matrix.c line 462' src=lena.gif>
 return src; </illustration></td>
     <td><illustration __from__='matrix.c line 462' src=lena.gif>
 return src->rotate_cw(); </illustration></td>
     </tr><tr valign=center>
     <td>original</td>
     <td>-&gt;rotate_cw();</td>
     </tr></table>
<p>

<dt><encaps>RETURN VALUE</encaps><dd>
the new image object
<p>

</dl>

</anchor name=Image.image.rotate_cw>



<hr newpage>
<anchor name=Image.image.scale>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->scale</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>scale</b>(float&nbsp;factor)<br>
	object <b>scale</b>(0.5)<br>
	object <b>scale</b>(float&nbsp;xfactor, float&nbsp;yfactor)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
scales the image with a factor,
     0.5 is an optimized case.
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>float factor</tt></td>	<td valign=bottom>factor to use for both x and y</td></tr>

	<tr align=left><td valign=top>
<tt>float xfactor</tt><br>
		<tt>float yfactor</tt></td>	<td valign=bottom>separate factors for x and y</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
the new image object
<p>

</dl>

</anchor name=Image.image.scale>



<hr newpage>
<anchor name=Image.image.scale>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->scale</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>scale</b>(int&nbsp;newxsize, int&nbsp;newysize)<br>
	object <b>scale</b>(0, int&nbsp;newysize)<br>
	object <b>scale</b>(int&nbsp;newxsize, 0)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
scales the image to a specified new size,
     if one of newxsize or newysize is 0,
     the image aspect ratio is preserved.
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>int newxsize</tt><br>
		<tt>int newysize</tt></td>	<td valign=bottom>new image size in pixels</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
the new image object
<p>

</dl>

</anchor name=Image.image.scale>



<hr newpage>
<anchor name=Image.image.select_from>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->select_from</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>select_from</b>(int&nbsp;x, int&nbsp;y)<br>
	object <b>select_from</b>(int&nbsp;x, int&nbsp;y, int&nbsp;edge_value)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
Makes an grey-scale image, for alpha-channel use.
    
    This is very close to a floodfill.
    
    The image is scanned from the given pixel,
    filled with 255 if the color is the same,
    or 255 minus distance in the colorcube, squared, rightshifted
    8 steps (see <link to=Image.image.distancesq>distancesq</link>).

<p>    When the edge distance is reached, the scan is stopped.
    Default edge value is 30.
    This value is squared and compared with the square of the 
    distance above.
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>int x</tt><br>
		<tt>int y</tt></td>	<td valign=bottom>originating pixel in the image</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
the new image object
<p>

<dt><encaps>SEE ALSO</encaps><dd>
<link to=Image.image.distancesq>distancesq</link>
<p>

</dl>

</anchor name=Image.image.select_from>



<hr newpage>
<anchor name=Image.image.setcolor>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->setcolor</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>setcolor</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
	object <b>setcolor</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b, int&nbsp;alpha)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
set the current color
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>int r</tt><br>
		<tt>int g</tt><br>
		<tt>int b</tt></td>	<td valign=bottom>new color</td></tr>

	<tr align=left><td valign=top>
<tt>int alpha</tt></td>	<td valign=bottom>new alpha value</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
the object called
<p>

</dl>

</anchor name=Image.image.setcolor>



<hr newpage>
<anchor name=Image.image.setpixel>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->setpixel</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>setpixel</b>(int&nbsp;x, int&nbsp;y)<br>
	object <b>setpixel</b>(int&nbsp;x, int&nbsp;y, int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
	object <b>setpixel</b>(int&nbsp;x, int&nbsp;y, int&nbsp;r, int&nbsp;g, int&nbsp;b, int&nbsp;alpha)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>

<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>int x</tt><br>
		<tt>int y</tt></td>	<td valign=bottom>position of the pixel</td></tr>

	<tr align=left><td valign=top>
<tt>int r</tt><br>
		<tt>int g</tt><br>
		<tt>int b</tt></td>	<td valign=bottom>color</td></tr>

	<tr align=left><td valign=top>
<tt>int alpha</tt></td>	<td valign=bottom>alpha value</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
the object called
<p>

</dl>

</anchor name=Image.image.setpixel>



<hr newpage>
<anchor name=Image.image.skewx>
<anchor name=Image.image.skewx_expand>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->skewx</tt><br>
	<tt>Image.image->skewx_expand</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>skewx</b>(int&nbsp;x)<br>
	object <b>skewx</b>(int&nbsp;yfactor)<br>
	object <b>skewx</b>(int&nbsp;x, int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
	object <b>skewx</b>(int&nbsp;yfactor, int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
	object <b>skewx_expand</b>(int&nbsp;x)<br>
	object <b>skewx_expand</b>(int&nbsp;yfactor)<br>
	object <b>skewx_expand</b>(int&nbsp;x, int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
	object <b>skewx_expand</b>(int&nbsp;yfactor, int&nbsp;r, int&nbsp;g, int&nbsp;b)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
Skews an image an amount of pixels or a factor;
     a skew-x is a transformation:

<p>     <table><tr valign=center>
     <td><illustration __from__='matrix.c line 774' src=lena.gif>
 return src; </illustration></td>
     <td><illustration __from__='matrix.c line 774' src=lena.gif>
 return src->skewx(15,255,0,0); </illustration></td>
     <td><illustration __from__='matrix.c line 774' src=lena.gif>
 return src->skewx_expand(15); </illustration></td>
     </tr><tr valign=center>
     <td>original</td>
     <td>-&gt;skewx(15,255,0,0);</td>
     <td>-&gt;skewx_expand(15);</td>
     </tr></table>
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>int x</tt></td>	<td valign=bottom>the number of pixels
     The "expand" variant of functions stretches the 
     image border pixels rather then filling with 
     the given or current color.</td></tr>

	<tr align=left><td valign=top>
<tt>float yfactor</tt></td>	<td valign=bottom>best described as: x=yfactor*this-&gt;ysize()</td></tr>

	<tr align=left><td valign=top>
<tt>int r</tt><br>
		<tt>int g</tt><br>
		<tt>int b</tt></td>	<td valign=bottom>color to fill with; default is current</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
the new image object
<p>

</dl>

</anchor name=Image.image.skewx>
</anchor name=Image.image.skewx_expand>



<hr newpage>
<anchor name=Image.image.skewy>
<anchor name=Image.image.skewy_expand>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->skewy</tt><br>
	<tt>Image.image->skewy_expand</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>skewy</b>(int&nbsp;y)<br>
	object <b>skewy</b>(int&nbsp;xfactor)<br>
	object <b>skewy</b>(int&nbsp;y, int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
	object <b>skewy</b>(int&nbsp;xfactor, int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
	object <b>skewy_expand</b>(int&nbsp;y)<br>
	object <b>skewy_expand</b>(int&nbsp;xfactor)<br>
	object <b>skewy_expand</b>(int&nbsp;y, int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
	object <b>skewy_expand</b>(int&nbsp;xfactor, int&nbsp;r, int&nbsp;g, int&nbsp;b)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
Skews an image an amount of pixels or a factor;
     a skew-y is a transformation:

<p>     <table><tr valign=center>
     <td><illustration __from__='matrix.c line 837' src=lena.gif>
 return src; </illustration></td>
     <td><illustration __from__='matrix.c line 837' src=lena.gif>
 return src->skewy(15,255,0,0); </illustration></td>
     <td><illustration __from__='matrix.c line 837' src=lena.gif>
 return src->skewy_expand(15); </illustration></td>
     </tr><tr valign=center>
     <td>original</td>
     <td>-&gt;skewy(15,255,0,0);</td>
     <td>-&gt;skewy_expand(15);</td>
     </tr></table>

<p>     The "expand" variant of functions stretches the 
     image border pixels rather then filling with 
     the given or current color.
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>int y</tt></td>	<td valign=bottom>the number of pixels</td></tr>

	<tr align=left><td valign=top>
<tt>float xfactor</tt></td>	<td valign=bottom>best described as: t=xfactor*this-&gt;xsize()</td></tr>

	<tr align=left><td valign=top>
<tt>int r</tt><br>
		<tt>int g</tt><br>
		<tt>int b</tt></td>	<td valign=bottom>color to fill with; default is current</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
the new image object
<p>

</dl>

</anchor name=Image.image.skewy>
</anchor name=Image.image.skewy_expand>



<hr newpage>
<anchor name=Image.image.threshold>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->threshold</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>threshold</b>()<br>
	object <b>threshold</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
Makes a black-white image. 

<p>     If all red, green, blue parts of a pixel
     is larger or equal then the given value, the pixel will become
     white, else black.

<p>     This method works fine with the grey method.

<p>     If no arguments are given, the current color is used 
     for threshold values.

<p>     <table><tr valign=center>
     <td><illustration __from__='image.c line 1496' src=lena.gif>
 return src; </illustration></td>
     <td><illustration __from__='image.c line 1496' src=lena.gif>
 return src->threshold(90,100,110); </illustration></td>
     </tr><tr valign=center>
     <td>original</td>
     <td>-&gt;threshold(90,100,110);</td>
     </tr></table>
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>int r</tt><br>
		<tt>int g</tt><br>
		<tt>int b</tt></td>	<td valign=bottom>red, green, blue threshold values</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
the new image object
<p>

<dt><encaps>SEE ALSO</encaps><dd>
<link to=Image.image.grey>grey</link>
<p>

</dl>

</anchor name=Image.image.threshold>



<hr newpage>
<anchor name=Image.image.toppm>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->toppm</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
string <b>toppm</b>()
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
<b>compability method</b> - do not use in new programs.
     
     See <link to=Image.PNM.encode>Image.PNM.encode</link>().
<p>

<dt><encaps>RETURN VALUE</encaps><dd>
PPM data
<p>

</dl>

</anchor name=Image.image.toppm>



<hr newpage>
<anchor name=Image.image.tuned_box>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->tuned_box</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>tuned_box</b>(int&nbsp;x1, int&nbsp;y1, int&nbsp;x2, int&nbsp;y2, array(array(int))&nbsp;corner_color)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
Draws a filled rectangle with colors (and alpha values) tuned
     between the corners.

<p>     Tuning function is (1.0-x/xw)*(1.0-y/yw) where x and y is
     the distance to the corner and xw and yw are the sides of the
     rectangle.

<p>     <table><tr valign=center>
     <td><illustration __from__='image.c line 1134' src=lena.gif>
 return src; </illustration></td>
     <td><illustration __from__='image.c line 1134' src=lena.gif>
 return src->copy()->tuned_box(0,0,src->xsize(),src->ysize(),({({255,0,0}),({0,255,0}),({0,0,255}),({255,255,0})})); </illustration></td>
     <td><illustration __from__='image.c line 1134' src=lena.gif>
 return src->copy()->tuned_box(0,0,src->xsize(),src->ysize(),({({255,0,0,255}),({0,255,0,128}),({0,0,255,128}),({255,255,0})})); </illustration></td>
     </tr><tr valign=center>
     <td>original</td>
     <td>solid tuning<br>(blue,red,green,yellow)</td>
     <td>tuning transparency<br>(as left + 255,128,128,0)</td>
     </tr></table>
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>int x1</tt><br>
		<tt>int y1</tt><br>
		<tt>int x2</tt><br>
		<tt>int y2</tt></td>	<td valign=bottom>rectangle corners</td></tr>

	<tr align=left><td valign=top>
<tt>array(array(int)) corner_color</tt></td>	<td valign=bottom>colors of the corners:
     <pre>
     ({x1y1,x2y1,x1y2,x2y2})
     </pre>
     each of these is an array of integeres:
     <pre>
     ({r,g,b}) or ({r,g,b,alpha})
     </pre>
     Default alpha channel value is 0 (opaque).</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
the object called
<p>

</dl>

</anchor name=Image.image.tuned_box>



<hr newpage>
<anchor name=Image.image.turbulence>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->turbulence</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
void <b>turbulence</b>(array(float|int|array(int))&nbsp;colorrange)<br>
	void <b>turbulence</b>(array(float|int|array(int))&nbsp;colorrange, int&nbsp;octaves, float&nbsp;scale, float&nbsp;xdiff, float&nbsp;ydiff, float&nbsp;cscale)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
gives a new image with the old image's size,
     filled width a 'turbulence' pattern

<p>     The random seed may be different with each instance of pike.

<p>     Example: <br>
     <tt>-&gt;turbulence( ({0,({229,204,204}), 0.9,({229,20,20}), 0.9,0}) );</tt>
     <br><illustration __from__='pattern.c line 263' src=lena.gif>
return image(200,100)->
     turbulence( ({0,({229,204,204}), 0.9,({229,20,20}), 0.9,0}));</illustration>
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>array(float|int|array(int)) colorrange</tt></td>	<td valign=bottom>colorrange table</td></tr>

	<tr align=left><td valign=top>
<tt>int octaves</tt></td>	<td valign=bottom>default value is 3</td></tr>

	<tr align=left><td valign=top>
<tt>float scale</tt></td>	<td valign=bottom>default value is 0.1</td></tr>

	<tr align=left><td valign=top>
<tt>float xdiff</tt><br>
		<tt>float ydiff</tt></td>	<td valign=bottom>default value is 0,0</td></tr>

	<tr align=left><td valign=top>
<tt>float cscale</tt></td>	<td valign=bottom>default value is 1</td></tr>

</table><p>

<dt><encaps>SEE ALSO</encaps><dd>
<link to=Image.image.noise>noise</link>
<p>

</dl>

</anchor name=Image.image.turbulence>



<hr newpage>
<anchor name=Image.image.xsize>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->xsize</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
int <b>xsize</b>()
<p>

<dt><encaps>RETURN VALUE</encaps><dd>
the width of the image
<p>

</dl>

</anchor name=Image.image.xsize>



<hr newpage>
<anchor name=Image.image.ysize>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->ysize</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
int <b>ysize</b>()
<p>

<dt><encaps>RETURN VALUE</encaps><dd>
the height of the image
<p>

</dl>

</anchor name=Image.image.ysize>



<hr newpage>
<anchor name=Image.image.`&>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->`&</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>`&amp;</b>(object&nbsp;operand)<br>
	object <b>`&amp;</b>(array(int)&nbsp;color)<br>
	object <b>`&amp;</b>(int&nbsp;value)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
makes a new image out of the minimum pixels values
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>object operand</tt></td>	<td valign=bottom>the other image to compare with;
     the images must have the same size.</td></tr>

	<tr align=left><td valign=top>
<tt>array(int) color</tt></td>	<td valign=bottom>an array in format ({r,g,b}), this is equal
     to using an uniform-colored image.</td></tr>

	<tr align=left><td valign=top>
<tt>int value</tt></td>	<td valign=bottom>equal to ({value,value,value}).</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
the new image object
<p>

<dt><encaps>SEE ALSO</encaps><dd>
<link to=Image.image.`->`-</link>,
     <link to=Image.image.`+>`+</link>,
     <link to=Image.image.`|>`|</link>,
     <link to=Image.image.`*>`*</link>,
     <link to=Image.image.add_layers>add_layers</link>
<p>

</dl>

</anchor name=Image.image.`&>



<hr newpage>
<anchor name=Image.image.`*>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->`*</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>`*</b>(object&nbsp;operand)<br>
	object <b>`*</b>(array(int)&nbsp;color)<br>
	object <b>`*</b>(int&nbsp;value)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
Multiplies pixel values and creates a new image.

<p>     This can be useful to lower the values of an image,
     making it greyer, for instance:

<p>     <pre>image=image*128+64;</pre>
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>object operand</tt></td>	<td valign=bottom>the other image to multiply with;
     the images must have the same size.</td></tr>

	<tr align=left><td valign=top>
<tt>array(int) color</tt></td>	<td valign=bottom>an array in format ({r,g,b}), this is equal
     to using an uniform-colored image.</td></tr>

	<tr align=left><td valign=top>
<tt>int value</tt></td>	<td valign=bottom>equal to ({value,value,value}).</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
the new image object
<p>

<dt><encaps>SEE ALSO</encaps><dd>
<link to=Image.image.`->`-</link>,
     <link to=Image.image.`+>`+</link>,
     <link to=Image.image.`|>`|</link>,
     <link to=Image.image.`&>`&</link>,
     <link to=Image.image.add_layers>add_layers</link>
<p>

</dl>

</anchor name=Image.image.`*>



<hr newpage>
<anchor name=Image.image.`+>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->`+</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>`+</b>(object&nbsp;operand)<br>
	object <b>`+</b>(array(int)&nbsp;color)<br>
	object <b>`+</b>(int&nbsp;value)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
adds two images; values are truncated at 255.
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>object operand</tt></td>	<td valign=bottom>the image which to add.</td></tr>

	<tr align=left><td valign=top>
<tt>array(int) color</tt></td>	<td valign=bottom>an array in format ({r,g,b}), this is equal
     to using an uniform-colored image.</td></tr>

	<tr align=left><td valign=top>
<tt>int value</tt></td>	<td valign=bottom>equal to ({value,value,value}).</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
the new image object
<p>

<dt><encaps>SEE ALSO</encaps><dd>
<link to=Image.image.`->`-</link>,
     <link to=Image.image.`|>`|</link>,
     <link to=Image.image.`&>`&</link>,
     <link to=Image.image.`*>`*</link>,
     <link to=Image.image.add_layers>add_layers</link>
<p>

</dl>

</anchor name=Image.image.`+>



<hr newpage>
<anchor name=Image.image.`->
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->`-</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>`-</b>(object&nbsp;operand)<br>
	object <b>`-</b>(array(int)&nbsp;color)<br>
	object <b>`-</b>(int&nbsp;value)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
makes a new image out of the difference
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>object operand</tt></td>	<td valign=bottom>the other image to compare with;
     the images must have the same size.</td></tr>

	<tr align=left><td valign=top>
<tt>array(int) color</tt></td>	<td valign=bottom>an array in format ({r,g,b}), this is equal
     to using an uniform-colored image.</td></tr>

	<tr align=left><td valign=top>
<tt>int value</tt></td>	<td valign=bottom>equal to ({value,value,value}).</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
the new image object
<p>

<dt><encaps>SEE ALSO</encaps><dd>
<link to=Image.image.`+>`+</link>,
     <link to=Image.image.`|>`|</link>,
     <link to=Image.image.`&>`&</link>,
     <link to=Image.image.`*>`*</link>,
     <link to=Image.image.add_layers>add_layers</link>
<p>

</dl>

</anchor name=Image.image.`->



<hr newpage>
<anchor name=Image.image.`|>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.image->`|</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>`|</b>(object&nbsp;operand)<br>
	object <b>`|</b>(array(int)&nbsp;color)<br>
	object <b>`|</b>(int&nbsp;value)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
makes a new image out of the maximum pixels values
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>object operand</tt></td>	<td valign=bottom>the other image to compare with;
     the images must have the same size.</td></tr>

	<tr align=left><td valign=top>
<tt>array(int) color</tt></td>	<td valign=bottom>an array in format ({r,g,b}), this is equal
     to using an uniform-colored image.</td></tr>

	<tr align=left><td valign=top>
<tt>int value</tt></td>	<td valign=bottom>equal to ({value,value,value}).</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
the new image object
<p>

<dt><encaps>SEE ALSO</encaps><dd>
<link to=Image.image.`->`-</link>,
     <link to=Image.image.`+>`+</link>,
     <link to=Image.image.`&>`&</link>,
     <link to=Image.image.`*>`*</link>,
     <link to=Image.image.add_layers>add_layers</link>
<p>

</dl>

</anchor name=Image.image.`|>



</anchor name=Image.image>



</section title="Image.image">



<section title="Image.GIF">
<hr newpage>
<anchor name=Image.GIF>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.GIF</tt><br>
<p>
<dt><encaps>DESCRIPTION</encaps><dd>
This submodule keep the GIF encode/decode capabilities
     of the <link to=Image>Image</link> module.

<p>     GIF is a common image storage format,
     usable for a limited color palette - a GIF image can 
     only contain as most 256 colors - and animations.

<p>     Simple encoding:
     <link to=Image.GIF.encode>encode</link>, <link to=Image.GIF.encode_trans>encode_trans</link>

<p>     Advanced stuff:
     <link to=Image.GIF.render_block>render_block</link>, <link to=Image.GIF.header_block>header_block</link>,
     <link to=Image.GIF.end_block>end_block</link>, <link to=Image.GIF.netscape_loop_block>netscape_loop_block</link>

<p>     Very advanced stuff:
     <link to=Image.GIF._render_block>_render_block</link>, <link to=Image.GIF._gce_block>_gce_block</link>
<p>

<dt><encaps>SEE ALSO</encaps><dd>
<link to=Image>Image</link>,
     <link to=Image.image>Image.image</link>,
     <link to=Image.colortable>Image.colortable</link>
<p>

</dl>

<hr newpage>
<anchor name=Image.GIF.encode>
<anchor name=Image.GIF.encode_trans>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.GIF.encode</tt><br>
	<tt>Image.GIF.encode_trans</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
string <b>encode</b>(object&nbsp;img);<br>
	string <b>encode</b>(object&nbsp;img, int&nbsp;colors);<br>
	string <b>encode</b>(object&nbsp;img, object&nbsp;colortable);<br>
	string <b>encode_trans</b>(object&nbsp;img, object&nbsp;alpha);<br>
	string <b>encode_trans</b>(object&nbsp;img, int&nbsp;tr_r, int&nbsp;tr_g, int&nbsp;tr_b);<br>
	string <b>encode_trans</b>(object&nbsp;img, int&nbsp;colors, object&nbsp;alpha);<br>
	string <b>encode_trans</b>(object&nbsp;img, int&nbsp;colors, int&nbsp;tr_r, int&nbsp;tr_g, int&nbsp;tr_b);<br>
	string <b>encode_trans</b>(object&nbsp;img, int&nbsp;colors, object&nbsp;alpha, int&nbsp;tr_r, int&nbsp;tr_g, int&nbsp;tr_b);<br>
	string <b>encode_trans</b>(object&nbsp;img, object&nbsp;colortable, object&nbsp;alpha);<br>
	string <b>encode_trans</b>(object&nbsp;img, object&nbsp;colortable, int&nbsp;tr_r, int&nbsp;tr_g, int&nbsp;tr_b);<br>
	string <b>encode_trans</b>(object&nbsp;img, object&nbsp;colortable, object&nbsp;alpha, int&nbsp;a_r, int&nbsp;a_g, int&nbsp;a_b);<br>
	string <b>encode_trans</b>(object&nbsp;img, object&nbsp;colortable, int&nbsp;transp_index);
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
Create a complete GIF file.

<p>     The latter (<link to=Image.GIF.encode_trans>encode_trans</link>) functions 
     add transparency capabilities.

<p>     Example:
     <pre>
     img=<link to=Image.image>Image.image</link>([...]);
     [...] // make your very-nice image
     write(<link to=Image.GIF.encode>Image.GIF.encode</link>(img)); // write it as GIF on stdout 
     </pre>
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>object img</tt></td>	<td valign=bottom>The image which to encode.</td></tr>

	<tr align=left><td valign=top>
<tt>int colors</tt><br>
		<tt>object colortable</tt></td>	<td valign=bottom>These arguments decides what colors the image should
     be encoded with. If a number is given, a colortable
     with be created with (at most) that amount of colors.
     Default is '256' (GIF maximum amount of colors).</td></tr>

	<tr align=left><td valign=top>
<tt>object alpha</tt></td>	<td valign=bottom>Alpha channel image (defining what is transparent); black
     color indicates transparency. GIF has only transparent
     or nontransparent (no real alpha channel).
     You can always dither a transparency channel:
     <tt>Image.colortable(my_alpha, ({({0,0,0}),({255,255,255})}))<wbr>
         -&gt;full()<wbr>-&gt;floyd_steinberg()<wbr>-&gt;map(my_alpha)</tt></td></tr>

	<tr align=left><td valign=top>
<tt>int tr_r</tt><br>
		<tt>int tr_g</tt><br>
		<tt>int tr_b</tt></td>	<td valign=bottom>Use this (or the color closest to this) color as transparent
     pixels.</td></tr>

	<tr align=left><td valign=top>
<tt>int a_r</tt><br>
		<tt>int a_g</tt><br>
		<tt>int a_b</tt></td>	<td valign=bottom>Encode transparent pixels (given by alpha channel image) 
     to have this color. This option is for making GIFs for 
     the decoders that doesn't support transparency.</td></tr>

	<tr align=left><td valign=top>
<tt>int transp_index</tt></td>	<td valign=bottom>Use this color no in the colortable as transparent color.</td></tr>

</table><p>

<dt><encaps>NOTA BENE</encaps><dd>
For advanced users:
     <pre>Image.GIF.encode_trans(img,colortable,alpha);</pre>
     is equivalent of using
     <pre>Image.GIF.header_block(img-&gt;xsize(),img-&gt;ysize(),colortable)+
     Image.GIF.render_block(img,colortable,0,0,0,alpha)+
     Image.GIF.end_block();</pre>
     and is actually implemented that way.
<p>

</dl>

</anchor name=Image.GIF.encode>
</anchor name=Image.GIF.encode_trans>



<hr newpage>
<anchor name=Image.GIF.end_block>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.GIF.end_block</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
string <b>end_block</b>();
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
This function gives back a GIF end (trailer) block.
<p>

<dt><encaps>RETURN VALUE</encaps><dd>
the end block as a string.
<p>

<dt><encaps>NOTA BENE</encaps><dd>
This is in the advanced sector of the GIF support;
     please read some about how GIFs are packed.

<p>     The result of this function is always ";" or "\x3b",
     but I recommend using this function anyway for code clearity.
<p>

<dt><encaps>SEE ALSO</encaps><dd>
<link to=Image.GIF.header_block>header_block</link>,
     <link to=Image.GIF.end_block>end_block</link>
<p>

</dl>

</anchor name=Image.GIF.end_block>



<hr newpage>
<anchor name=Image.GIF.header_block>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.GIF.header_block</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
string <b>header_block</b>(int&nbsp;xsize, int&nbsp;ysize, int&nbsp;numcolors);<br>
	string <b>header_block</b>(int&nbsp;xsize, int&nbsp;ysize, object&nbsp;colortable);<br>
	string <b>header_block</b>(int&nbsp;xsize, int&nbsp;ysize, object&nbsp;colortable, int&nbsp;background_color_index, int&nbsp;gif87a, int&nbsp;aspectx, int&nbsp;aspecty);<br>
	string <b>header_block</b>(int&nbsp;xsize, int&nbsp;ysize, object&nbsp;colortable, int&nbsp;background_color_index, int&nbsp;gif87a, int&nbsp;aspectx, int&nbsp;aspecty, int&nbsp;r, int&nbsp;g, int&nbsp;b);
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
This function gives back a GIF header block.

<p>     Giving a colortable to this function includes a 
     global palette in the header block.
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>int xsize</tt><br>
		<tt>int ysize</tt></td>	<td valign=bottom>Size of drawing area. Usually same size as in
     the first (or only) render block(s).</td></tr>

	<tr align=left><td valign=top>
<tt>int background_color_index</tt></td>	<td valign=bottom>This color in the palette is the background color.
     Background is visible if the following render block(s)
     doesn't fill the drawing area or are transparent.
     Most decoders doesn't use this value, though.</td></tr>

	<tr align=left><td valign=top>
<tt>int gif87a</tt></td>	<td valign=bottom>If set, write 'GIF87a' instead of 'GIF89a' (default 0 == 89a).</td></tr>

	<tr align=left><td valign=top>
<tt>int aspectx</tt><br>
		<tt>int aspecty</tt></td>	<td valign=bottom>Aspect ratio of pixels,
     ranging from 4:1 to 1:4 in increments
     of 1/16th. Ignored by most decoders. 
     If any of <tt>aspectx</tt> or <tt>aspecty</tt> is zero,
     aspectratio information is skipped.</td></tr>

	<tr align=left><td valign=top>
<tt>int r</tt><br>
		<tt>int g</tt><br>
		<tt>int b</tt></td>	<td valign=bottom>Add this color as the transparent color.
     This is the color used as transparency color in
     case of alpha-channel given as image object. 
     This increases (!) the number of colors by one.</td></tr>

</table><p>

<dt><encaps>RETURN VALUE</encaps><dd>
the created header block as a string
<p>

<dt><encaps>NOTA BENE</encaps><dd>
This is in the advanced sector of the GIF support;
     please read some about how GIFs are packed.

<p>     This GIF encoder doesn't support different size
     of colors in global palette and color resolution.
<p>

<dt><encaps>SEE ALSO</encaps><dd>
<link to=Image.GIF.header_block>header_block</link>,
     <link to=Image.GIF.end_block>end_block</link>
<p>

</dl>

</anchor name=Image.GIF.header_block>



<hr newpage>
<anchor name=Image.GIF.netscape_loop_block>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.GIF.netscape_loop_block</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
string <b>netscape_loop_block</b>();<br>
	string <b>netscape_loop_block</b>(int&nbsp;number_of_loops);
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
Creates a application-specific extention block;
     this block makes netscape and compatible browsers
     loop the animation a certain amount of times.
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>int number_of_loops</tt></td>	<td valign=bottom>Number of loops. Max and default is 65535.</td></tr>

</table><p>

</dl>

</anchor name=Image.GIF.netscape_loop_block>



<hr newpage>
<anchor name=Image.GIF.render_block>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.GIF.render_block</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
string <b>render_block</b>(object&nbsp;img, object&nbsp;colortable, int&nbsp;x, int&nbsp;y, int&nbsp;localpalette);<br>
	string <b>render_block</b>(object&nbsp;img, object&nbsp;colortable, int&nbsp;x, int&nbsp;y, int&nbsp;localpalette, object&nbsp;alpha);<br>
	string <b>render_block</b>(object&nbsp;img, object&nbsp;colortable, int&nbsp;x, int&nbsp;y, int&nbsp;localpalette, object&nbsp;alpha, int&nbsp;r, int&nbsp;g, int&nbsp;b);<br>
	string <b>render_block</b>(object&nbsp;img, object&nbsp;colortable, int&nbsp;x, int&nbsp;y, int&nbsp;localpalette, int&nbsp;delay, int&nbsp;transp_index, int&nbsp;interlace, int&nbsp;user_input, int&nbsp;disposal);<br>
	string <b>render_block</b>(object&nbsp;img, object&nbsp;colortable, int&nbsp;x, int&nbsp;y, int&nbsp;localpalette, object&nbsp;alpha, int&nbsp;r, int&nbsp;g, int&nbsp;b, int&nbsp;delay, int&nbsp;interlace, int&nbsp;user_input, int&nbsp;disposal);
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
This function gives a image block for placement in a GIF file,
     with or without transparency.
     The some options actually gives two blocks, 
     the first with graphic control extensions for such things
     as delay or transparency.

<p>     Example:
     <pre>
     img1=<link to=Image.image>Image.image</link>([...]);
     img2=<link to=Image.image>Image.image</link>([...]);
     [...] // make your very-nice images
     nct=<link to=Image.colortable>Image.colortable</link>([...]); // make a nice colortable
     write(<link to=Image.GIF.header_block>Image.GIF.header_block</link>(xsize,ysize,nct)); // write a GIF header
     write(<link to=Image.GIF.render_block>Image.GIF.render_block</link>(img1,nct,0,0,0,10)); // write a render block
     write(<link to=Image.GIF.render_block>Image.GIF.render_block</link>(img2,nct,0,0,0,10)); // write a render block
     [...]
     write(<link to=Image.GIF.end_block>Image.GIF.end_block</link>()); // write end block
     // voila! A GIF animation on stdout.
     </pre>
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>object img</tt></td>	<td valign=bottom>The image.</td></tr>

	<tr align=left><td valign=top>
<tt>object colortable</tt></td>	<td valign=bottom>Colortable with colors to use and to write as palette.</td></tr>

	<tr align=left><td valign=top>
<tt>int x</tt><br>
		<tt>int y</tt></td>	<td valign=bottom>Position of this image.</td></tr>

	<tr align=left><td valign=top>
<tt>int localpalette</tt></td>	<td valign=bottom>If set, writes a local palette.</td></tr>

	<tr align=left><td valign=top>
<tt>object alpha</tt></td>	<td valign=bottom>Alpha channel image; black is transparent.</td></tr>

	<tr align=left><td valign=top>
<tt>int r</tt><br>
		<tt>int g</tt><br>
		<tt>int b</tt></td>	<td valign=bottom>Color of transparent pixels. Not all decoders understands
     transparency. This is ignored if localpalette isn't set.</td></tr>

	<tr align=left><td valign=top>
<tt>int delay</tt></td>	<td valign=bottom>View this image for this many centiseconds. Default is zero.</td></tr>

	<tr align=left><td valign=top>
<tt>int transp_index</tt></td>	<td valign=bottom>Index of the transparent color in the colortable.
     <tt>-1</tt> indicates no transparency.</td></tr>

	<tr align=left><td valign=top>
<tt>int user_input</tt></td>	<td valign=bottom>If set: wait the delay or until user input. If delay is zero,
     wait indefinitely for user input. May sound the bell
     upon decoding. Default is non-set.</td></tr>

	<tr align=left><td valign=top>
<tt>int disposal</tt></td>	<td valign=bottom>Disposal method number;
     <dl compact>
     <dt>0<dd>No disposal specified. The decoder is
              not required to take any action. (default)
     <dt>1<dd>Do not dispose. The graphic is to be left
              in place.
     <dt>2<dd>Restore to background color. The area used by the
              graphic must be restored to the background color.
     <dt>3<dd>Restore to previous. The decoder is required to
              restore the area overwritten by the graphic with
              what was there prior to rendering the graphic.
     <dt compact>4-7<dd>To be defined.
     </dl></td></tr>

</table><p>

<dt><encaps>NOTA BENE</encaps><dd>
This is in the advanced sector of the GIF support;
     please read some about how GIFs are packed.

<p>     The user_input and disposal method are unsupported
     in most decoders.
<p>

<dt><encaps>SEE ALSO</encaps><dd>
<link to=Image.GIF.encode>encode</link>,
     <link to=Image.GIF.header_block>header_block</link>,
     <link to=Image.GIF.end_block>end_block</link>
<p>

</dl>

</anchor name=Image.GIF.render_block>



<hr newpage>
<anchor name=Image.GIF._gce_block>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.GIF._gce_block</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
string <b>_gce_block</b>(int&nbsp;transparency, int&nbsp;transparency_index, int&nbsp;delay, int&nbsp;user_input, int&nbsp;disposal);
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
This function gives back a Graphic Control Extension block.
     A GCE block has the scope of the following render block.
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>int transparency</tt><br>
		<tt>int transparency_index</tt></td>	<td valign=bottom>The following image has transparency, marked with this index.</td></tr>

	<tr align=left><td valign=top>
<tt>int delay</tt></td>	<td valign=bottom>View the following rendering for this many centiseconds (0..65535).</td></tr>

	<tr align=left><td valign=top>
<tt>int user_input</tt></td>	<td valign=bottom>Wait the delay or until user input. If delay is zero,
     wait indefinitely for user input. May sound the bell
     upon decoding.</td></tr>

	<tr align=left><td valign=top>
<tt>int disposal</tt></td>	<td valign=bottom>Disposal method number;
     <dl compact>
     <dt>0<dd>No disposal specified. The decoder is
              not required to take any action.
     <dt>1<dd>Do not dispose. The graphic is to be left
              in place.
     <dt>2<dd>Restore to background color. The area used by the
              graphic must be restored to the background color.
     <dt>3<dd>Restore to previous. The decoder is required to
              restore the area overwritten by the graphic with
              what was there prior to rendering the graphic.
     <dt compact>4-7<dd>To be defined.
     </dl></td></tr>

</table><p>

<dt><encaps>NOTA BENE</encaps><dd>
This is in the very advanced sector of the GIF support;
     please read about how GIFs file works.

<p>     Most decoders just ignore some or all of these parameters.
<p>

<dt><encaps>SEE ALSO</encaps><dd>
<link to=Image.GIF._render_block>_render_block</link>,
     <link to=Image.GIF.render_block>render_block</link>
<p>

</dl>

</anchor name=Image.GIF._gce_block>



<hr newpage>
<anchor name=Image.GIF._render_block>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.GIF._render_block</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
string <b>_render_block</b>(int&nbsp;x, int&nbsp;y, int&nbsp;xsize, int&nbsp;ysize, int&nbsp;bpp, string&nbsp;indices, 0|string&nbsp;colortable, int&nbsp;interlace);
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
Advanced (!) method for writing renderblocks for placement
     in a GIF file. This method only applies LZW encoding on the
     indices and makes the correct headers.
<p>

<dt><encaps>ARGUMENTS</encaps><dd>
	<table border=1 cellspacing=0><tr>
	<td align=left><font size=-2>argument(s)</font></td>	<td align=left><font size=-2>description</font></td></tr>

	<tr align=left><td valign=top>
<tt>int x</tt><br>
		<tt>int y</tt></td>	<td valign=bottom>Position of this image.</td></tr>

	<tr align=left><td valign=top>
<tt>int xsize</tt><br>
		<tt>int ysize</tt></td>	<td valign=bottom>Size of the image. Length if the <tt>indices</tt> string
     must be xsize*ysize.</td></tr>

	<tr align=left><td valign=top>
<tt>int bpp</tt></td>	<td valign=bottom>Bits per pixels in the indices. Valid range 1..8.</td></tr>

	<tr align=left><td valign=top>
<tt>string indices</tt></td>	<td valign=bottom>The image indices as an 8bit indices.</td></tr>

	<tr align=left><td valign=top>
<tt>string colortable</tt></td>	<td valign=bottom>Colortable with colors to write as palette.
     If this argument is zero, no local colortable is written.
     Colortable string len must be 1&amp;lt;&amp;lt;bpp.</td></tr>

	<tr align=left><td valign=top>
<tt>int interlace</tt></td>	<td valign=bottom>Interlace index data and set interlace bit. The given string
     should _not_ be pre-interlaced.</td></tr>

</table><p>

<dt><encaps>NOTA BENE</encaps><dd>
This is in the very advanced sector of the GIF support;
     please read about how GIFs file works.
<p>

<dt><encaps>SEE ALSO</encaps><dd>
<link to=Image.GIF.encode>encode</link>,
     <link to=Image.GIF._encode>_encode</link>,
     <link to=Image.GIF.header_block>header_block</link>,
     <link to=Image.GIF.end_block>end_block</link>
<p>

</dl>

</anchor name=Image.GIF._render_block>



</anchor name=Image.GIF>



</section title="Image.GIF">



<section title="Image.PNM">
<hr newpage>
<anchor name=Image.PNM>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.PNM</tt><br>
<p>
<dt><encaps>DESCRIPTION</encaps><dd>
This submodule keep the PNM encode/decode capabilities
     of the <link to=Image>Image</link> module.

<p>     PNM is a common image storage format on unix systems,
     and is a very simple format.

<p>     This format doesn't use any color palette.

<p>     The format is divided into seven subformats;

<p>     <pre>
     P1(PBM) - ascii bitmap (only two colors)
     P2(PGM) - ascii greymap (only grey levels)
     P3(PPM) - ascii truecolor
     P4(PBM) - binary bitmap 
     P5(PGM) - binary greymap 
     P6(PPM) - binary truecolor
     </pre>

<p>     Simple encoding:<br>
     <link to=Image.PNM.encode>encode</link>,<br> <link to=Image.PNM.encode_binary>encode_binary</link>,<br>
     <link to=Image.PNM.encode_ascii>encode_ascii</link>

<p>     Simple decoding:<br>
     <link to=Image.PNM.decode>decode</link>

<p>     Advanced encoding:<br>
     <link to=Image.PNM.encode_P1>encode_P1</link>, <br>
     <link to=Image.PNM.encode_P2>encode_P2</link>, <br>
     <link to=Image.PNM.encode_P3>encode_P3</link>, <br>
     <link to=Image.PNM.encode_P4>encode_P4</link>, <br>
     <link to=Image.PNM.encode_P5>encode_P5</link>, <br>
     <link to=Image.PNM.encode_P6>encode_P6</link>
<p>

<dt><encaps>SEE ALSO</encaps><dd>
<link to=Image>Image</link>,
     <link to=Image.image>Image.image</link>,
     <link to=Image.GIF>Image.GIF</link>
<p>

</dl>

<hr newpage>
<anchor name=Image.PNM.decode>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.PNM.decode</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
object <b>decode</b>(string&nbsp;data)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
Decodes PNM (PBM/PGM/PPM) data and creates an image object.
<p>

<dt><encaps>RETURN VALUE</encaps><dd>
the decoded image as an image object
<p>

<dt><encaps>NOTA BENE</encaps><dd>
This function may throw errors upon illegal PNM data.
<p>

<dt><encaps>SEE ALSO</encaps><dd>
<link to=Image.PNM.encode>encode</link>
<p>

</dl>

</anchor name=Image.PNM.decode>



<hr newpage>
<anchor name=Image.PNM.encode>
<anchor name=Image.PNM.encode_binary>
<anchor name=Image.PNM.encode_P6>
<dl>
<dt><encaps>NAME</encaps><dd>
	<tt>Image.PNM.encode</tt><br>
	<tt>Image.PNM.encode_binary</tt><br>
	<tt>Image.PNM.encode_P6</tt><br>
<p>
<dt><encaps>SYNTAX</encaps><dd>
string <b>encode</b>(object&nbsp;image)<br>
	string <b>encode_binary</b>(object&nbsp;image)<br>
	string <b>encode_P6</b>(object&nbsp;image)
<p>

<dt><encaps>DESCRIPTION</encaps><dd>
Make a complete PNM file from an image.

<p>     <link to=Image.PNM.encode_binary>encode_binary</link>() and <link to=Image.PNM.encode_ascii>encode_ascii</link>()
     uses the most optimized encoding for this image (bitmap, grey
     or truecolor) - P4, P5 or P6 respective P1, P2 or P3.

<p>     <link to=Image.PNM.encode>encode</link>() maps to <link to=Image.PNM.encode_binary>encode_binary</link>().
<p>

<dt><encaps>RETURN VALUE</encaps><dd>
the encoded image as a string
<p>

<dt><encaps>SEE ALSO</encaps><dd>
<link to=Image.PNM.decode>decode</link>
<p>

</dl>

</anchor name=Image.PNM.encode>
</anchor name=Image.PNM.encode_binary>
</anchor name=Image.PNM.encode_P6>



</anchor name=Image.PNM>



</section title="Image.PNM">
</anchor name=Image>



