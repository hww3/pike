#!/usr/local/bin/pike

import Stdio;
import spider;
import Array;

mapping(int:mapping) links=([]);

string p1(string data);

/* Note: destructive ! */
string *srt(string *foo)
{
  sort(map(foo,lower_case),foo);
  return foo;
}

string code_params(mapping s)
{
  string ret="";
  foreach(indices(s), string data)
    ret+=" "+data+"=\""+s[data]+"\"";
  return ret;
}

/* Index handling */

void _add_to(mapping foo, string bar, string full)
{
  mapping m;
  if(!bar)
  {
    if(foo[0])
    {
      foo[0]|=({full});
    }else{
      foo[0]=({full});
    }
    return;
  }
  sscanf(bar,"%s.%s",bar,string rest);
  if(!(m=foo[bar])) m=foo[bar]=([]);
  _add_to(m, rest,full);
}

void add_to(string bar, string full)
{
  sscanf(lower_case(bar),"%*[_ ]%c",int c);
  mapping m;
  if(!(m=links[c])) m=links[c]=([]);
  _add_to(m, bar, full);
}


string anchor(mixed a, mixed b, mixed c)
{
  if(b->name)
  {
    if(c[strlen(c)-10..]=="<!--END-->")
      werror("Warning: Anchor not ended "+b->name+".\n");

    add_to(b->name, b->name);
    string *foo=b->name/".";
    for(int e=1;e<sizeof(foo);e++)
      add_to(foo[e], foo[..e]*".");
  }

  return 0;
}

string mklink(string lnk) {   return "<a href=#"+lnk+">"+lnk+"</a>"; }

string genindex(mapping m, string prefix)
{
  string ret="<dl>\n";
  if(m[0])
  {
    foreach(srt(m[0]), string lnk)
      ret+="<dt>"+mklink(lnk)+"\n";
  }
  m_delete(m,0);
  foreach(srt(indices(m)), string ind)
    {
      if(m[ind][0] && sizeof(m[ind])==1 && sizeof(m[ind][0])==1 &&
	m[ind][0][0]==prefix+ind)
      {
	foreach(srt(m[ind][0]), string lnk)
	  ret+="<dt>"+mklink(lnk)+"\n";
      }else{
	ret+="<dt>"+prefix+ind+"\n"+
	"<dd>\n"+
	genindex(m[ind], prefix+ind+".");
      }
    }
  ret+="</dl>\n";
  return ret;
}

/* chapter handling */

mixed *tod=({});
string prefix="";

string chapter(string tag, mapping params, string data);
string section(string tag, mapping params, string data);
string appendix(string tag, mapping params, string data);
string appendixes(string tag, mapping params, string data);

#define TAGS \
  (["chapter":chapter,"section":section,\
   "appendix":appendix,"appendixes":appendixes])

mapping aliases=([]);

string rtag(string name,
	    string title,
	    string outtitle,
	    string xlink,
	    string sectionname,
	    mapping params,
	    string data)
{
  if(data[strlen(data)-10..]=="<!--END-->")
    werror("Warning: "+name+" tag not ended "+title+".\n");

  string *save=tod;
  string save_prefix=prefix;
  tod=({});
  prefix+=xlink+".";
  data+="\n<!--END-->";
  data=parse_html(data,([]),TAGS);
  prefix=save_prefix;
  tod=save+({prefix+xlink,sectionname||(prefix+xlink),title,tod});

  if(params->alias)
    {
      aliases[params->alias]=
	({
	  prefix+xlink, 
	  sectionname || ( name + " " + prefix+xlink )
	})
	;
    }


  if(data[strlen(data)-10..]=="<!--END-->")
    data=data[..strlen(data)-11];

  string tmp;
  if(sizeof(prefix/".") <2)
  {
    tmp="h1";
  }else{
    tmp="h2";
  }

  return
    "<a name="+ prefix+xlink +">\n"+
    "<"+tmp+">"+outtitle+"</"+tmp+">"+
    data+"\n"+
    "</a> <!-- "+name+" "+prefix+xlink+" -->\n"+
    "<p>\n";
}
	    

string section(string tag, mapping params, string data)
{
  int c = sizeof(tod)/4 +1;
  return rtag("section",
	      params->title,
	      prefix+c+" "+params->title,
	      (string)c,
	      0,
	      params,
	      data);
}

string chapter(string tag, mapping params, string data)
{
  int c = sizeof(tod)/4+1;
  return rtag("chapter",
	      params->title,
	      "Chapter "+prefix+c+", "+params->title,
	      (string)c,
	      0,
	      params,
	      data);
}

string appendixes(string tag, mapping params, string data)
{
  return rtag("appendixes",
	      "",
	      "Appendixes",
	      "Appendix",
	      "Appendixes",
	      params,
	      data);

}

int appnum = 'A';

string appendix(string tag, mapping params, string data)
{
  string c=sprintf("%c",appnum++);
  return rtag("appendix",
	      params->title,
	      "Appendix "+c+", "+params->title,
	      c,
	      "Appendix "+c,
	      params,
	      data);
}


string gencontents(mixed *tod)
{
  if(!sizeof(tod)) return "";
  string ret="<dl>\n";
  for(int e;e<sizeof(tod);e+=4)
  {
    ret+="<dt><b><a href=#"+tod[e]+">"+tod[e+1]+"</b> "+tod[e+2]+"</a>\n";

    string tmp=gencontents(tod[e+3]);
    if(strlen(tmp)) ret+="<dd>\n"+tmp;

  }
  ret+="</dl>";
  return ret;
}

/* Stage 2 */
mapping replacements=([]);

string do_replace(string what)
{
  return replacements[lower_case(what)];
}

string encaps1(string word)
{
  return "<font size=+1>"+word[0..0]+"</font><font size=-1>"+word[1..]+"</font>";
}

string encaps(string tag, mapping params, string data)
{
  return "<b>"+map((data/" ")-({""}),encaps1)*" "+"</b>";
}

string link(string tag, mapping params, string data)
{
  mixed tmp=aliases[params->to];
  if(!tmp)
    {
      werror("Unlinked <link> :"+params->to+"\n");
      return 0;
    }

  return "<a href=#"+tmp[0]+">"+tmp[1]+"</a>";
}

string box(string tag, mapping params, string data)
{
  return "<center><table border=1>\n"+
    data+
    "</table></center>\n";
}

int main()
{
  string data=stdin->read(0x7fffffff);

  data+="\n<!--END-->";

  /* Pass 1, find links for the index */
  string data=parse_html(data, ([]) , (["a":anchor]));

  /* Pass 2, parse chapters and sections */
  string data=parse_html(data, ([]) , TAGS);

  /* Build index */
  string index="<dl>\n";
  foreach(sort(indices(links)), int letter)
  {
    index+="<dt><font size=+2>"+upper_case(sprintf("%c",letter))+"</font>\n"+
      "<dd>\n"+
      genindex(links[letter],"");
  }
  index+="</dl>\n";
  
  replacements->index=index;

  /* Build table of contents */
  replacements["table-of-contents"]=gencontents(tod);


  /* Pass 3, insert generated data */
  write(parse_html(data,
		   ([
		     "index":do_replace,
		     "table-of-contents":do_replace,
		     "link":link,
		     ]),
		   ([
		     "box":box,
		     "encaps":encaps,
		     ])));
}


