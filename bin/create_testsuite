#!/bin/sh
#
#generates a script that is supposed to test uLPC
#note that not everything is tested yet, you are welcome to
#submit more tests.
#


GNU_M4=`echo "changequote([,])ifdef([__gnu__],yes,no)" | m4`
if [ $GNU_M4 = "no" ]; then
  echo "$0 requires GNU m4" 1>&2
  exit 1
fi






m4 <<\EOTESTS
divert(-1)

changequote([[,]])
changecom

define(TESTNO,0)
define(doquote,[[patsubst(patsubst(patsubst([[[[[[$1]]]]]],\\,\\\\),\",\\"),\
,\\n)]])

define(test_any, [[define([[TESTNO]],incr(TESTNO))dnl
  "=mixed a() { doquote([[$1]]); }\n"+	// test TESTNO
  "mixed b() { return doquote([[$2]]); }",]])
define(test_do, [[define([[TESTNO]],incr(TESTNO))dnl
  "dmixed a() { doquote([[$1]]); }\n",	// test TESTNO]])
define(test_true, [[define([[TESTNO]],incr(TESTNO))dnl
  "tmixed a() { return doquote([[$1]]); }",	// test TESTNO]])
define(test_false, [[define([[TESTNO]],incr(TESTNO))dnl
  "fmixed a() { return doquote([[$1]]); }",	// test TESTNO]])
define(test_eq, [[define([[TESTNO]],incr(TESTNO))dnl
  "=mixed a() { return doquote([[$1]]); }\n"+	// test TESTNO
  "mixed b() { return doquote([[$2]]); }",]])
define(test_equal, [[define([[TESTNO]],incr(TESTNO))dnl
  "emixed a() { return doquote([[$1]]); }\n"+	// test TESTNO
  "mixed b() { return doquote([[$2]]); }",]])
define(test_compile_error, [[define([[TESTNO]],incr(TESTNO))dnl
  "cmixed a() { doquote([[$1]]); }\n",	// test TESTNO]])
define(test_eval_error, [[define([[TESTNO]],incr(TESTNO))dnl
  "Emixed a() { doquote([[$1]]); }\n",	// test TESTNO]])
define(test_define_program, [[define([[TESTNO]],incr(TESTNO))dnl
  "Pstring a() { return \"doquote([[$1]])\"; }\n"+	// test TESTNO
  "string b() { return \"doquote([[$2]])\"; }",]])
define(test_program, [[define([[TESTNO]],incr(TESTNO))dnl
  "t\n"+"doquote([[$1]])\n",	// test TESTNO ]])



divert(0)dnl
#!ulpc
int main(int argc, string *argv)
{

  int e, verbose, successes, errors, t;
  string *tests;
  program testprogram;
  int start, fail;

  for(e=1;e<argc;e++)
  {
    switch(argv[e])
    {
      case "-h":
      case "--help":
        perror("Usage: "+argv[e]+" [-v | --verbose] [-h | --help] [-t <testno>]\n");
        return 0;

      case "-v":
      case "--verbose":
        verbose++;
        break;

      case "-s":
      case "--start-test":
	sscanf(argv[++e],"%d",start);
	start--;
	break;

      case "-f":
      case "--fail":
	fail++;
	break;


      case "-t":
      case "--trace":
	t++;
	break;

      default:
        perror("Unnown argument "+argv[e]+" (try "+argv[0]+" --help for more info).\n");

    }
  }

   tests = ({


// signum, signame
test_eq(signum("SIGKILL"),9)
test_eq(signum("SIGINT"),2)
test_eq(signame(9),"SIGKILL")
test_eq(signame(2),"SIGINT")

// kill, signal, getpid
test_true(intp(getpid()))
test_do(signal(signum("SIGUSR1"),lambda() { add_efun("AFJLLAF",17); }))
test_do(kill(getpid(),signum("SIGUSR1")))
test_eq(AFJLLAF,17)
test_do(add_efun("AFJLLAF"))
test_do(signal(signum("SIGUSR1")))

// class
test_true(programp(class {}))
test_true(functionp(clone(class { int foo() { return 1; }})->foo))
test_true(clone(class { int foo() { return 1; }})->foo())
test_true(clone(class { int i=1; })->i)
test_false(clone(class { int foo() { return 1; }})->bar)
test_eq(clone(clone(class { program foo=class { int i=20; }; })->foo)->i,20)

// Not yet cataloged
test_program(void foo(int a ,int b); function(int,int:void) a() { return foo; })
test_program(void foo(int a, int ... b); function(int,int ...:void) a() { return foo; })
test_program(void foo(); function(:void) a() { return foo; })
test_compile_error([[} void foo(); function(:string) a() { return foo;]])

test_do(int p; foreach(({1,2,3,4,5}),p) random_seed(p))
test_eq([[random_seed(17),random(20000)]],[[random_seed(17),random(20000)]])
test_eq([[random_seed(18),random(20000)]],[[random_seed(18),random(20000)]])
test_eq([[random_seed(19),random(20000)]],[[random_seed(19),random(20000)]])
test_do(lambda(){return;}())
test_do(sleep(1))
test_compile_error([[} int foo() { return]]);
test_compile_error([[} void foo() { return 1]]);
test_equal( ({ lambda() { return 3; } , lambda() { return 7; }, lambda() { return 9; } })(), ({ 3,7,9 }))
test_true(stringp(sprintf("%O",({1,2,"foo"}))))
test_true(stringp(sprintf("%O",([1:2,"foo":"bar"]))))
test_any(int *a=({10}); a[0]++; return a[0], 11)
test_any(mapping a=([10:11]); a[10]++; return a[10], 12)
test_any(int e; object o=clone((program)"/precompiled/file"); if(!o->open("conftest.h","wct")) return -1; e=o->write("return 17;\n"); if(!o->close()) return -1; return e,11)
test_equal(mkmapping( ({3,6,2}), ({"3","6","2"})), ([3:"3", 6:"6", 2:"2"]))
test_equal(sum(([3:"3", 6:"6", 2:"2"])), ([3:"3", 6:"6", 2:"2"]))
test_true(sum(([3:"3", 6:"6", 2:"2"])) != ([3:"3", 6:"6", 2:"2"]))
test_any([[
#include "conftest.h"
]],17)
test_any([[
#include <conftest.h>
]],17)
test_true(intp(__LINE__))
test_true(stringp(__FILE__))
test_true(stringp(__DATE__))
test_true(stringp(__TIME__))
test_true(efun::stringp(""))
test_equal([["a,b,4,7,8s,asfd,a,d,f" / ","]],[["a,b,4,7,8s,asfd,a,d,f" / ","]])
test_any([[string *a="a,b"/","; a[0]="c"; return equal(a,({"c","b"}))]],1)
test_true(0||1)
test_true(1||0)
test_true(!0||!0)
test_true(!0&&!0)
test_any(mixed a=1; a+=1; return a,2)
test_any(mixed a=1; a-=1; return a,0)
test_equal("abcd"/"" - indices("abcd"),({"a","b","c","d"}))
test_equal("abcd"/"" & indices("abcd"),({}))
test_eq(sizeof("abcd"/"" & "de"/""),1)
test_equal( ({0,0,0,0,0}), ({0,0,0,0,0}))
test_equal( ({0,0,0,0,0}), allocate(5,"object"))
test_equal(mkmapping("abcd"/"","jklm"/"") | mkmapping("jclm"/"","alcd"/""),
	mkmapping("abcdjlm"/"","jklmacd"/""))
test_program(int foo() { return 17;} mixed a() { return foo() == 17; })
test_any([[mixed a; a=2; a=a*3; return a]],6)
test_any([[mixed a = ({1}); a=a+({2}); return equal(a,({1,2}))]],1)
test_define_program(/test,[[int foo() { return 17; }]])
test_any(function bar=clone((program)"/test")->foo; return bar(),17)
test_eq(popen("echo foo"),"foo\n")

// sscanf
test_any([[mixed a; return sscanf("11","%d",a)]],1)
test_any([[mixed a; sscanf("11","%d",a); return a]],11)
test_any([[mixed a,b; return sscanf("11foo","%dfoo",a)]],1)
test_any([[mixed a,b; sscanf("11foo","%dfoo",a); return a]],11)
test_any([[mixed a,b; return sscanf("11foo","%d%s",a,b)]],2)
test_any([[mixed a,b; sscanf("11foo","%d%s",a,b); return b]],"foo")
test_any([[mixed a,b; return sscanf("foo","%c%s",b,a)]],2)
test_any([[mixed a,b; sscanf("foo","%c%s",b,a); return b]],'f')
test_any([[mixed a,b; sscanf("foo","%c%s",b,a); return a]],"oo")
test_any([[mixed a,b; return sscanf("1.0","%f",a)]],1)
test_any([[mixed a,b; sscanf("1.0","%f",a); return a]],1.0)
test_any([[mixed a,b; sscanf("abcdeFGji","%[a-z]%s",a,b); return a]],"abcde")
test_any([[mixed a,b; sscanf("abcdeFGji","%[a-z]%s",a,b); return b]],"FGji")

test_any([[mixed a,b; return sscanf("foo-%-bar","%s-%%-%s",a,b);]],2)
test_any([[mixed a,b; sscanf("foo-%-bar","%s-%%-%s",a,b); return a]],"foo")
test_any([[mixed a,b; sscanf("foo-%-bar","%s-%%-%s",a,b); return b]],"bar")

// Basics
test_true(1)
test_true("")
test_true(!0)
test_true(!(!1))
test_true(this_object())
test_true(a) // a is the test function
test_true(0.0)
test_true(([]))
test_true(({}))
test_true((<>))
test_true(object_program(this_object()))

// testing !
test_equal(!"",0)
test_equal(!this_object(),0)
test_equal(!this_function(),0)

// testing ==
test_true(1==1)
test_true(!(1==2))
test_true(""=="")
test_true(!(""=="foo"))
test_true(this_object()==this_object())
// test_true(this_function()==main)
test_true(2.0==2.0)
test_true(({})==({}))

// testing !=
test_true(({1})!=({1}))
test_true(1!=2)
test_true(!(1==2))
test_true(!(""!=""))
test_true(""!="foo")

// testing < > <= >=
define(test_cmp,[[
test_true($1<$2)
test_true(!($1>$2))
test_true($2>$1)
test_true(!($2<$1))
test_true($1<=$2)
test_true(!($1>=$2))
test_true($2>=$1)
test_true(!($2<=$1))
test_true($2<=$2)
test_true($1>=$1) ]])


test_cmp(1,2)
test_cmp(1.0,2.0)
test_cmp("a","b")
test_cmp("","b")

// hex construction
test_eq(0,0x0)
test_eq(1,0x1)
test_eq(10,0xa)
test_eq(16,0x10)
test_eq(65535,0xffff)
test_eq(17*257*65537,0x11111111)

// octal construction
test_eq(0,00)
test_eq(1,01)
test_eq(8,010)
test_eq(64,0100)
test_eq(1073741824,010000000000)
test_eq((8+1)*(8*8+1)*(8*8*8*8+1),011111111)

// string construction tests
test_eq(16,"\20"[0])
test_eq(16,"\020"[0])
test_eq(255,"\377"[0])
test_eq(4,'\4')
test_true("\r"[0]!='r')
test_eq("\r"[0],'\r')
test_eq("\n"[0],'\n')

// testing +
test_eq(1+1,2)
test_eq(1+(-2),-1)
test_eq((-2)+(-2),-4)
test_eq("hi"+"there","hithere")
test_eq("human"+"number"+666,"humannumber666")
test_eq("human"+("number"+666),"humannumber666")
test_eq(("human"+"number")+666,"humannumber666")
test_eq(("human"+"number")+666+111,"humannumber666111")
test_eq("humannumber"+(666+111),"humannumber777")
test_eq("a"+"b"+"c"+"d"+"e"+"f"+"g"+"h"+"i"+"j"+"k"+"l"+"m"+"n"+"o"+"p"+"q"+"r"+"s"+"t"+"u"+"v"+"x"+"y","abcdefghijklmnopqrstuvxy")
test_eq(1.0+1.0,2.0)
test_eq(1.0+(-1.0),0.0)
test_eq((-1.0)+(-1.0),-2.0)
test_equal(({1,2,3})+({4,5,6}),({1,2,3,4,5,6}))
test_equal((<1,2,3,4>)+(<4,5,6>),(<1,2,3,4,4,5,6>))
test_equal(([0:1,3:6])+([5:2,3:6]),([0:1,3:6,3:6,5:2]))
test_eval_error(return this_object() + this_object())

// testing -
test_eq(10-3,7)
test_eq(3-10,-7)
test_eq(10.0-3.0,7.0)
test_eq(3.0-10.0,-7.0)
test_eq("foobargazonk"-"o","fbargaznk")
test_equal(({"foo","bar","gazonk"})-({"foo","gazonk"}),({"bar"}))
test_equal(({"c","foo","bar","gazonk","a","b",})-({"foo","gazonk"}),({"c","bar","a","b"}))
test_equal((<"foo","bar","gazonk">)-(<"foo","gazonk">),(<"bar">))
test_equal((["foo":3,"bar":4,"gazonk":5])-(["foo":3,"gazonk":8]),(["bar":4]))

// testing ~
test_eq(-1-4,~4)
test_eq(-1-627893874,~627893874)

// testing *
test_eq(3*4,12)
test_eq(4*3,12)
test_eq(2*2*2*2*2,32)
test_eq(3.0*4.0,12.0)
test_eq(4.0*3.0,12.0)
test_eq(2.0*2.0*2.0*2.0*2.0,32.0)
test_eq(({"foo","bar","gazonk"})*"-","foo-bar-gazonk")

// testing /
test_eq(12/3,4)
test_eq(13/3,4)
test_eq(14/3,4)
test_eq(15/3,5)
test_eval_error(return 15/0)
test_eq(12.0/3.0,4.0)
test_eq(14.0/4.0,3.5)
test_eq(15.0/3.0,5.0)
test_eval_error(return 15.0/0.0)
test_equal("foo-bar-gazonk"/"-",({"foo","bar","gazonk"}))
test_equal("foobargazonk"/"",({"f","o","o","b","a","r","g","a","z","o","n","k"}))

// testing %
test_eq(12%3,0)
test_eq(13%3,1)
test_eq(14%3,2)
test_eq(15%3,0)
test_eval_error(return 15 % 0)
test_eq(12.0 % 3.0,0.0)
test_eq(13.0 % 3.0,1.0)
test_eq(14.0 % 3.0,2.0)
test_eq(14.5 % 3.0,2.5)
test_eq(15.0 % 3.0,0.0)
test_eval_error(return 15.0 % 0.0)

// testing &&
test_eq(0 && 1,0)
test_eq(1 && 0,0)
test_eq(0 && 0,0)
test_eq(1 && 1,1)
test_eq(78 && 1,1)
test_eq(78 && 99,99)
test_eq(78 && 99,99)

// testing ||
test_eq(0 || 1,1)
test_eq(1 || 0,1)
test_eq(0 || 0,0)
test_eq(1 || 1,1)
test_eq(78 || 1,78)
test_eq(78 || 0,78)

// testing |
test_eq(0 | 0,0)
test_eq(1 | 1,1)
test_eq(4 | 1,5)
test_eq(1 | 9,9)
test_equal( sort_array(({1,2,3,4,4}) | ({3,5,6})), ({1,2,3,4,4,5,6}))
test_equal( (<4,5,6>) | (<5,5,5>), (<4,5,5,5,6>) )
test_equal( ([-4:8,8:7]) | ([3:3,8:3]), ([-4:8,8:3,3:3]) )

// testing &
test_eq(0 & 0,0)
test_eq(1 & 1,1)
test_eq(4 & 1,0)
test_eq(1 & 9,1)
test_equal( ({1,2,3,4,4}) & ({3,5,6}), ({3}))
test_equal( (<4,5,6>) & (<5,5,5>), (<5>) )
test_equal( ([-4:8,8:7]) & ([3:3,8:3]), ([8:3]) )

// testing ^
test_eq(0 ^ 0,0)
test_eq(1 ^ 1,0)
test_eq(4 ^ 1,5)
test_eq(1 ^ 9,8)
test_equal( ({1,2,3,4,4}) ^ ({3,5,6}), ({1,2,4,4,5,6}))
test_equal( (<4,5,6>) ^ (<5,5,5>), (<4,5,5,6>) )
test_equal( ([-4:8,8:7]) ^ ([3:3,8:3]), ([-4:8,3:3]) )

// testing <<
test_eq(1<<0,1)
test_eq(1<<1,2)
test_eq(1<<10,1024)
test_eq(5<<3,40)

// testing >>
test_eq(9>>2,2)
test_eq(1>>1,0)
test_eq(1024>>10,1)
test_eq(47>>3,5)

// testing ? :
test_true(0?0:1)
test_true(1?1:0)
test_true(""?1:0)
test_true(!0?1:0)
test_true(!(!1)?1:0)
test_true(this_object()?1:0)
test_true(a?1:0) // a is the test function
test_true(0.0?1:0)
test_true(([])?1:0)
test_true(({})?1:0)
test_true((<>)?1:0)
test_true(object_program(this_object())?1:0)

// testing indexing
test_eq("foo"[0],'f')
test_eq("foo"[1],'o')
test_eq("foo"[2],'o')
test_eq("foo"[-1],'o')
test_eq("foo"[-2],'o')
test_eq("foo"[-3],'f')
test_eq(({'f','o','o'})[0],'f')
test_eq(({'f','o','o'})[1],'o')
test_eq(({'f','o','o'})[2],'o')
test_eq(({'f','o','o'})[-1],'o')
test_eq(({'f','o','o'})[-2],'o')
test_eq(({'f','o','o'})[-3],'f')
test_eq(([0:'f',1:'o',2:'o'])[0],'f')
test_eq(([0:'f',1:'o',2:'o'])[1],'o')
test_eq(([0:'f',1:'o',2:'o'])[2],'o')
test_eq(([0:'f',1:'o',2:'o'])[3],0)
test_eq(([0:'f',1:'o',2:'o'])[-1],0)
test_eq((<'f','o','o'>)['o'],1)
test_eq((<'f','o','o'>)['f'],1)
test_eq((<'f','o','o'>)['b'],0)
test_eq((<'f','o','o'>)[-1],0)

// index assigning
test_any(mixed a=({1}); a[0]=2; return equal(a,({2})),1)
test_any(mixed a=(<1>); a[1]=2; return equal(a,(<1>)),1)
test_any(mixed a=(<1>); a[0]=2; return equal(a,(<1,0>)),1)
test_any(mixed a=(<1>); a[1]=0; return equal(a,(<>)),1)
test_any(mixed a=(<1>); a[0]=0; return equal(a,(<1>)),1)
test_any(mixed a=([1:1]); a[0]=0; return equal(a,([1:1,0:0])),1)
test_any(mixed a=([1:1]); a[1]=0; return equal(a,([1:0])),1)

test_define_program(/test,[[public int q,w,e,r; mixed t; mixed getw() { return w; } void setw(int _) { w=_; }]])
test_eq(clone((program)"/test")->q,0)
test_eq(clone((program)"/test")->w,0)
test_eq(clone((program)"/test")->e,0)
test_eq(clone((program)"/test")->r,0)
test_eq(clone((program)"/test")->getw(),0)
test_any(object o=clone((program)"/test"); o->setw(17); return o->w,17)
test_any(object o=clone((program)"/test"); o->w=17; return o->getw(),17)

test_eq(clone((program)"/test")["q"],0)
test_eq(clone((program)"/test")["w"],0)
test_eq(clone((program)"/test")["e"],0)
test_eq(clone((program)"/test")["r"],0)
test_eq(clone((program)"/test")["getw"](),0)
test_any(object o=clone((program)"/test"); o["setw"](17); return o["w"],17)
test_any(object o=clone((program)"/test"); o["w"]=17; return o["getw"](),17)

// testing range
test_eq("foObar"[0..0],"f")
test_eq("foobargazonk"[3..5],"bar")
test_eq("foo"[1..10],"oo")
test_eq("foo"[-100..0],"f")
test_eq("foo"[-100..100],"foo")
test_eq("foo"[1..0],"")
test_eq("foo"[0..-100],"")
test_equal(({1,2,3})[0..0],({1}))
test_equal(({1,2,3})[1..2],({2,3}))
test_equal(({1,2,3})[2..10],({3}))
test_equal(({1,2,3})[-100..0],({1}))
test_equal(({1,2,3})[-100..100],({1,2,3}))
test_equal(({1,2,3})[1..0],({}))
test_equal(({1,2,3})[0..-100],({}))

// testing @
test_equal(({1,2,3}),lambda(mixed ... x) { return x; }(@a()))
test_equal(explode("foo",""),lambda(mixed ... x) { return x; }(@a()))
test_any([[mixed *a=({1,2,3}); return lambda(mixed ... x) { return x; }(@a) !=a]],1)

// testing +=
test_any(int a=1; a+=10; return a,11)
// testing -=
test_any(int a=1; a-=10; return a,-9)
// testing &=
test_any(int a=3; a&=10; return a,2)
// testing |=
test_any(int a=3; a|=10; return a,11)
// testing ^=
test_any(int a=3; a^=10; return a,9)
// testing <<=
test_any(int a=3; a<<=2; return a,12)
// testing <<=
test_any(int a=12; a>>=2; return a,3)
// testing *=
test_any(int a=12; a*=2; return a,24)
// testing /=
test_any(int a=12; a/=2; return a,6)
// testing %=
test_any(int a=12; a%=7; return a,5)

// testing control structs
test_any(return 1,1)
test_any(return lambda(){return 1;} (),1 )
test_any(if(0) return 0; else return 1,1)
test_any(if(0) return 0; return 1,1)
test_any(if(1) return 1; else return 0,1)
test_any(if("") return 1; else return 0,1)
test_any(if(!0) return 1; else return 0,1)
test_any(if(!(!1)) return 1; else return 0,1)
test_any(if(this_object()) return 1; else return 0,1)
test_any(if(a) return 1; else return 0,1) dnl a is the test function
test_any(if(0.0) return 1; else return 0,1)
test_any(if(([])) return 1; else return 0,1)
test_any(if(({})) return 1; else return 0,1)
test_any(if((<>)) return 1; else return 0,1)
test_any(if(object_program(this_object())) return 1; else return 0,1)

// break
test_any(while(1) break; return 1,1)
test_any(while(1) if(1) break; return 1,1)

// for
test_any(int e; for(e=0;e<10;e++) break; return e,0)
test_any(int e; for(e=0;e<10;e++) continue; return e,10)
test_any(int e;string t=""; for(e=0;e<10;e++) t+=e; return t,"0123456789")
test_any(int e;string t=""; for(e=0;e>-10;e--) t+=e; return t,"0-1-2-3-4-5-6-7-8-9")

// foreach
test_any([[int e;string t=""; foreach(({7,6,3,8}),e) t+=e; return t]],"7638")
test_any([[string s;if(1) foreach(({}),s); else foreach(({}),s); return 1]],1)

// do-whilte
test_any(int e;string t=""; e=0; do{ t+=e; }while(++e<6); return t,"012345";)

// while
test_any(int e;string t=""; e=8; while(--e) t+=e; return t,"7654321";)
test_any(int e;string t=""; e=8; while(e--) t+=e; return t,"76543210";)
test_any(int e;string t=""; e=0; while(++e<6) t+=e; return t,"12345";)
test_any(int e=1;string t=""; while(e<20){t+=e;e*=2;} return t,"124816";)

// Switch
test_any(switch("") { case 0: case "gazonk": return 0; } return 1,1)
test_any(switch("") { case "gazonk": case 0: return 0; } return 1,1)
test_any(switch(0) { case 0: case "gazonk": return 0; } return 1,0)
test_any(switch("gazonk") { case "gazonk": case 0: return 0; } return 1,0)
test_any(switch(0) { case "": } return 1,1)
test_any(switch(1) { case 1: return 1; default: } return 0,1)
test_any(switch(2) { case 1: return 0; default: return 1;} return 0,1)
test_any(switch(1) { default: return 0; case 1: return 1; } return 0,1)
test_any(switch(2) { default: return 1; case 1: return 0; } return 0,1)
test_any(switch(0) { case "apa": case 1.0: return 0; }  return 1,1)
test_any(switch("apa") { case "apa": return 1; case 1.0: }  return 0,1)
test_any(switch(1.0) { case "apa": return 0; case 1.0: return 1; } return 0,1)
test_any(switch("sune") { case "gunnel": return 0; case "gunnar": return 1; case "sune": case "gusten": return 0; } return 0,0)
test_any(switch("a") { case "a": return 1; case "b": case "c": case "d": case 'a': case '1': case '0': default: } return 0,1)
test_any(switch("b") { case "a": return 0; case "b": return 1; case "c": case "d": case 'a': case '1': case '0': default: } return 0,1)
test_any(switch("c") { case "a": case "b": return 0; case "c": return 1; case "d": case 'a': case '1': case '0': default: } return 0,1)
test_any(switch("d") { case "a": case "b": case "c": return 0; case "d": return 1; case 'a': case '1': case '0': default: } return 0,1)
test_any(switch('a') { case "a": case "b": case "c": case "d": return 0; case 'a': return 1; case '1': case '0': default: } return 0,1)
test_any(switch('1') { case "a": case "b": case "c": case "d": case 'a': return 0; case '1': return 1; case '0': default: } return 0,1)
test_any(switch('0') { case "a": case "b": case "c": case "d": case 'a': case '1': return 0; case '0': return 1; default: } return 0,1)
test_any(switch("a") { case "a": return 1; case "b": return 2; case "c": return 3; case "d": return 4; case 'a': return 5; case '1': return 6; case '0': return 7; default: return 8; } return 9,1)
test_any(switch("b") { case "a": return 1; case "b": return 2; case "c": return 3; case "d": return 4; case 'a': return 5; case '1': return 6; case '0': return 7; default: return 8; } return 9,2)
test_any(switch("c") { case "a": return 1; case "b": return 2; case "c": return 3; case "d": return 4; case 'a': return 5; case '1': return 6; case '0': return 7; default: return 8; } return 9,3)
test_any(switch("d") { case "a": return 1; case "b": return 2; case "c": return 3; case "d": return 4; case 'a': return 5; case '1': return 6; case '0': return 7; default: return 8; } return 9,4)
test_any(switch('a') { case "a": return 1; case "b": return 2; case "c": return 3; case "d": return 4; case 'a': return 5; case '1': return 6; case '0': return 7; default: return 8; } return 9,5)
test_any(switch('1') { case "a": return 1; case "b": return 2; case "c": return 3; case "d": return 4; case 'a': return 5; case '1': return 6; case '0': return 7; default: return 8; } return 9,6)
test_any(switch('0') { case "a": return 1; case "b": return 2; case "c": return 3; case "d": return 4; case 'a': return 5; case '1': return 6; case '0': return 7; default: return 8; } return 9,7)
test_any(switch('9') { case "a": return 1; case "b": return 2; case "c": return 3; case "d": return 4; case 'a': return 5; case '1': return 6; case '0': return 7; default: return 8; } return 9,8)


define(test_switch0,[[
test_any(switch($1) { case $2: return $6; case $3: return $7; case $4: return $8; case $5: return $9; } return 0,$10)
test_any(switch($1) { default: return 0; case $2: return $6; case $3: return $7; case $4: return $8; case $5: return $9; } return -1,$10)
test_any(switch($1) { case $2: return $6; default: return 0; case $3: return $7; case $4: return $8; case $5: return $9; } return -1,$10)
test_any(switch($1) { case $2: return $6; case $3: return $7; default: return 0; case $4: return $8; case $5: return $9; } return -1,$10)
test_any(switch($1) { case $2: return $6; case $3: return $7; case $4: return $8; default: return 0; case $5: return $9; } return -1,$10)
test_any(switch($1) { case $2: return $6; case $3: return $7; case $4: return $8; case $5: return $9; default: return 0; } return -1,$10)
]])

define(test_switch1,[[
test_switch0($1, $2,$3,$4,$5, $6,$7,$8,$9, $10)
test_switch0($1, $2,$3,$5,$4, $6,$7,$9,$8, $10)
]])

define(test_switch2,[[
test_switch1($1, $2,$3,$4,$5, $6,$7,$8,$9, $10)
test_switch1($1, $2,$4,$3,$5, $6,$8,$7,$9, $10)
test_switch1($1, $2,$5,$4,$3, $6,$9,$8,$7, $10)
]])

define(test_switch3,[[
test_switch2($1, $2,$3,$4,$5, 2,3,4,5, $6)
test_switch2($1, $3,$2,$4,$5, 3,2,4,5, $6)
test_switch2($1, $4,$3,$2,$5, 4,3,2,5, $6)
test_switch2($1, $5,$3,$4,$2, 5,3,4,2, $6)
]])

define(test_switch4,[[
test_switch3($1,$2,$3,$4,$5,0)
test_switch3($2,$2,$3,$4,$5,2)
test_switch3($3,$2,$3,$4,$5,3)
test_switch3($4,$2,$3,$4,$5,4)
test_switch3($5,$2,$3,$4,$5,5)
]])

test_switch4(17,18,19,20,21)
test_switch4("a","b","c","d","e")
test_switch4("a",0,"c","d","e")
test_switch4(1.0,2.0,3.0,4.0,5.0)
test_switch4(this_object(),"",0,4.0,1)

test_any(int e;string t=""; for(e=0;e<10;e++) switch(e) { default: t+=e; case 4..8: } return t,"01239")
test_any([[float e,q; q=0.0; for(e=0.1;e<10.0;e+=1.0) switch(e) { default: q+=e; case 4.0..8.0: } return q]],0.1+1.1+2.1+3.1+8.1+9.1)

// testing preprocessor
// #define
test_any([[
#define FOOa 1
return FOOa;
]],1)

test_any([[
#define FOOb 17
#undef FOOb
#define FOOb 1
return FOOb;
]],1)

test_compile_error([[
#define FOOc FOOc FOO
FOO
]])

test_compile_error([[
#error FOOd
FOO
]])

// /* */
test_any([[
/* return 99; * /  /* */
return 1;
]],1)

// //
test_any([[
// return 99;
return 1;
]],1)

// #if
define(test_if_true,[[test_any([[
#if $1
return 1;
#else
return 0;
#endif
]],1)]])
define(test_if_false,[[test_any([[
#if $1
return 1;
#else
return 0;
#endif
]],0)]])

test_if_true(1)
test_if_false(0)

// #if ==
test_if_true(1==1)
test_if_false(1==2)

// #if !=
test_if_true(1!=2)
test_if_false(1!=1)

// #if ( )
test_if_true( (((1))==1) )
test_if_false( ((1)==(2)) )

// #if -1
test_if_true( -1 )
test_if_true( (-1) )
test_if_true( (-1==0-1) )

// #if ~
test_if_true( (-1-1==~1) )

// #if ?:
test_if_true( 17 == ( 1 ? 17 : 18 ) )
test_if_true( 18 == ( 0 ? 17 : 18 ) )

// #if ||
test_if_true( 10 == ( 10 || 20 ) )
test_if_true( 20 == ( 0 || 20 ) )

// #if &&
test_if_true( 0 == ( 0 && 20 ) )
test_if_true( 20 == ( 10 && 20 ) )

// #if |
test_if_true( 3 == ( 1 | 2 ) )
test_if_true( 2 == ( 2 | 2 ) )

// #if ^
test_if_true( 0 == ( 2 ^ 2 ) )
test_if_true( 3 == ( 1 ^ 2 ) )

// #if &
test_if_true( 0 == ( 1 & 2 ) )
test_if_true( 2 == ( 2 & 7 ) )

// #if <= >= < > ! strings, floats

define(test_if_cmp,[[
test_if_true($1<$2)
test_if_true(!($1>$2))
test_if_true($2>$1)
test_if_true(!($2<$1))
test_if_true($1<=$2)
test_if_true(!($1>=$2))
test_if_true($2>=$1)
test_if_true(!($2<=$1))
test_if_true($2<=$2)
test_if_true($1>=$1) ]])

test_if_cmp(1,2)
test_if_cmp(1.0,2.0)
test_if_cmp("a","b")

// #if <<
test_if_true(1<<10==1024)
test_if_true(5<<3==40)

// #if >>
test_if_true(1024>>10==1)
test_if_true(47>>3==5)

// #if +
test_if_true(1024+10==1034)
test_if_true(47+3==50)

// #if -
test_if_true(1024-10==1014)
test_if_true(47-3==44)

// #if *
test_if_true(1024*10==10240)

// #if /
test_if_true(47/3==15)

test_compile_error([[
#if 1/0
return 1;
#else
return 0;
#endif
]])

// #if %
test_if_true(47%3==2)
test_compile_error([[
#if 1%0
return 1;
#else
return 0;
#endif
]])

// #if [ ]
test_if_true("foo"[0]=='f')

// #if defined
test_any([[
#define FOOe 0
#if defined(FOOe)
return 1;
#else
return 0;
#endif
]],1)

// #if define < x
test_any([[
#define FOOf 1
#if FOOf < 2
return 1;
#else
return 0;
#endif
]],1)

// #if define < x
test_any([[
#define FOOg 1
#if FOOg < 0
return 0;
#else
return 1;
#endif
]],1)

// #if x < define
test_any([[
#define FOOh 1
#if 0 < FOOh
return 1;
#else
return 0;
#endif
]],1)

// #if x < define
test_any([[
#define FOOi 1
#if 2 < FOOi
return 0;
#else
return 1;
#endif
]],1)

// #if efun
// see test for add_efun()

// #if /* */
test_any([[
#if 1 /* trying to be mean //  * / */ /* /* */
return 1;  /* */
#define foo
# 1 "---"
#undef foo
#else /* trying to be mean //  * / */ /* /* */
return 0;  //
#endif /* trying to be mean //  * / */ /* /* */
]],1)

test_any([[
#if 0 /* trying to be mean //  * / */ /* /* */
return 0; /* */
#define foo
# 1 "---"
#undef foo
#else /* trying to be mean //  * / */ /* /* */
return 1; //
#endif /* trying to be mean //  * / */ /* /* */
]],1)

// #if //
test_any([[
#if 1 //* trying to be mean //  */ */
return 1;
#else //* trying to be mean //  */ */
return 0;
#endif //* trying to be mean //  */ */
]],1)

test_any([[
#if 0 //* trying to be mean //  */ */
return 0;
#else //* trying to be mean //  */ */
return 1;
#endif //* trying to be mean // */ */
]],1)

test_any([[
#define FOOj
#if defined(FOOj)
return 1;
#else
return 0;
#endif
]],1)

test_any([[
#if defined(FOOk)
return 0;
#else
return 1;
#endif
]],1)

// #ifdef
test_any([[
#ifdef FOOl
return 0;
#else
return 1;
#endif
]],1)

test_any([[
#define FOOm
#ifdef FOOm
return 1;
#else
return 0;
#endif
]],1)

// #ifndef
test_any([[
#define FOOo
#ifndef FOOo
return 0;
#else
return 1;
#endif
]],1)

test_any([[
#ifndef FOOp
return 1;
#else
return 0;
#endif
]],1)

// #else
test_any([[
#if 1
return 1;
#else
FEL
#if 0
FEL
#else
FEL
#endif
return 0;
#endif
]],1)

test_any([[
#if 0
FEL
#if 0
FEL
#else
FEL
#if 1
FEL
#else
FEL
#endif
#endif
return 0;
#else
return 1;
#endif
]],1)

// #elif
test_any([[
#if 0
return 0;
#elif 0
return 0;
#else
return 1;
#endif
]],1)

test_any([[
#if 0
return 0;
#elif 1
return 1;
#else
return 0;
#endif
]],1)

test_any([[
#if 1
return 1;
#elif 1
return 0;
#else
return 0;
#endif
]],1)

// #elseif
test_any([[
#if 0
return 0;
#elseif 0
return 0;
#else
return 1;
#endif
]],1)

test_any([[
#if 0
return 0;
#elseif 0
return 0;
#elseif 1
return 1;
#elseif 0
return 0;
#elseif 0
return 0;
#else
FEL
#endif
]],1)

test_any([[
#if 0
return 0;
#elseif 1
return 1;
#else
return 0;
#endif
]],1)

test_any([[
#if 1
return 1;
#elseif 1
return 0;
#else
return 0;
#endif
]],1)

// #pragma
// FIXME: add tests for real pragmas
test_any([[
#pragma whatever
return 1;
]],1)

// #include
// FIXME add test for #include

// tests for file module
test_true(programp((program)"/precompiled/file"))
test_true(programp((program)"/precompiled/port"))
test_any(object o; o=clone((program)"/precompiled/file"); destruct(o); return 1,1)

// - file->open
// - file->close
test_any(object o=clone((program)"/precompiled/file"); return o->open("conftest","wct") && o->close(),1)

// - file_stat
test_eq(file_stat("conftest")[1],0)

// - rm
test_true(rm("conftest"))
test_eq(file_stat("conftest"),0)

// - file->write
test_any(int e; object o=clone((program)"/precompiled/file"); if(!o->open("conftest","wct")) return -1; e=o->write("sune"); if(!o->close()) return -1; return e,4)

// - file->read
test_any(string s; object o=clone((program)"/precompiled/file"); if(!o->open("conftest","r")) return -1; s=o->read(4); if(!o->close()) return -1; return s,"sune")

test_any(string s; object o=clone((program)"/precompiled/file"); if(!o->open("conftest","r")) return -1; s=o->read(999999); if(!o->close()) return -1; return s,"sune")

test_any(int e; object o=clone((program)"/precompiled/file"); if(!o->open("conftest","wct")) return -1; e=o->write(sprintf("%'+-*'100000s","")); if(!o->close()) return -1; return e,100000)

test_any(string s; object o=clone((program)"/precompiled/file"); if(!o->open("conftest","r")) return -1; s=o->read(9999999); if(!o->close()) return -1; return s,sprintf("%'+-*'100000s",""))

// - file->seek
// - file->tell
test_any(object o=clone((program)"/precompiled/file"); return o->open("conftest","r") && o->read(4711) && o->tell() == 4711 && o->close(),1)

// - file->stat
test_any(object o=clone((program)"/precompiled/file"); return equal(o->open("conftest","r") && o->stat(), file_stat("conftest")),1)

// - file->errno
test_do(clone((program)"/precompiled/file")->errno())

// - file->set_nonblocking
// - file->set_blocking
// - file->set_id
// - file->query_id
test_any(object o=clone((program)"/precompiled/file"); return o->query_id()==o,1)

// - file->query_read_callback
test_do(clone((program)"/precompiled/file")->query_read_callback())

// - file->query_write_callback
test_do(clone((program)"/precompiled/file")->query_write_callback())

// - file->query_close_callback
test_do(clone((program)"/precompiled/file")->query_close_callback())

// - file->dup
// - file->assign
// - file->assign2
// - file->open_socket
// - file->connect
// - file->query_address

// - socket->bind
// - socket->set_id
// - socket->query_id
// - socket->errno
// - socket->accept

test_true(rm("conftest"))
test_eq(file_stat("conftest"),0)

// - file_stat
// - perror
// - rm
// - mkdir
// - get_dir
// - cd
// - getcwd
test_true(stringp(getcwd()))
test_eq('/',getcwd()[0])

// - sprintf module
test_true(stringp(sprintf("")))
test_eq(sprintf("%d",1),"1")
test_eq(sprintf("%%"),"%")
test_eq(sprintf("%d",1),"1")
test_eq(sprintf("%d",-1),"-1")
test_eq(sprintf("%u",1<<31),"2147483648")
test_eq(sprintf("%o",255),"377")
test_eq(sprintf("%x",255),"ff")
test_eq(sprintf("%X",255),"FF")
test_eq(sprintf("%c",255),"\377")
test_true(stringp(sprintf("%f",255.0)))
test_true(stringp(sprintf("%g",255.0)))
test_true(stringp(sprintf("%e",255.0)))
test_true(stringp(sprintf("%e",255.0)))
test_eq(sprintf("%s","foobaR"),"foobaR")
test_eq(sprintf("%s","foo\nbar"),"foo\nbar")
test_true(stringp(sprintf("%O",this_object())))
test_true(stringp(sprintf("%O",({}))))
test_eq(sprintf("%n"),"")
test_eq(sprintf("%t",1),"int")
test_eq(sprintf("%t",this_object()),"object")
test_eq(sprintf("%{%d\n%}",({1,2,3,4})),"1\n2\n3\n4\n")

test_eq(strlen(sprintf("%1000s","")),1000)
test_eq(sprintf("%2d",1)," 1")
test_eq(sprintf("%2d",1)," 1")
test_eq(sprintf("%2d",2222),"2222")
test_eq(sprintf("%!2d",2222),"22")
test_eq(sprintf("%!!2d",2222),"2222")
test_eq(sprintf("% d",2)," 2")
test_eq(sprintf("% d",-2),"-2")
test_eq(sprintf("%+d",2),"+2")
test_eq(sprintf("%+d",-2),"-2")
test_eq(sprintf("%-2d",2),"2 ")
test_eq(sprintf("%|3d",2)," 2 ")
test_eq(sprintf("%-=3s","f o bar gaz"),"f o\nbar\ngaz")
dnl test_eq(sprintf("%/3s","f o bargaz"),"f o\nbar\ngaz")
dnl test_true(stringp(sprintf("%3#s","f\no\nbargaz\nonk")))
dnl test_true(stringp(sprintf("%3$s","f\no\nbargaz\nonk")))
test_eq(sprintf("%*d",3,3),"  3")
test_eq(sprintf("%'FOO'10s","BAR"),"FOOFOOFBAR")
test_eq(sprintf("%d %<d %<d",2),"2 2 2")
dnl . : and ; hasn't been tested
dnl ^, @ and _ hasn't been tested yet
test_eval_error(sprintf("%d"))

// - Here we try the regexp module
test_true(programp((program)"/precompiled/regexp"))
test_any(object o; o=clone((program)"/precompiled/regexp"); destruct(o); return 1,1)

// regexp->create
test_any(object o; o=clone((program)"/precompiled/regexp","^.*$"); destruct(o); return 1,1)

// regexp->match
test_eq(clone((program)"/precompiled/regexp","^.*$")->match(""),1)
test_eq(clone((program)"/precompiled/regexp","^.*$")->match("a"),1)
test_eq(clone((program)"/precompiled/regexp","^.*$")->match("-"),1)
test_eq(clone((program)"/precompiled/regexp","^$")->match(""),1)
test_eq(clone((program)"/precompiled/regexp","^.$")->match("a"),1)
test_eq(clone((program)"/precompiled/regexp","^.$")->match("-"),1)
test_eq(clone((program)"/precompiled/regexp","^[abc]$")->match("-"),0)
test_eq(clone((program)"/precompiled/regexp","^[abc]$")->match("a"),1)
test_eq(clone((program)"/precompiled/regexp","^[abc]$")->match("c"),1)
test_eq(clone((program)"/precompiled/regexp","^[^abc]$")->match("-"),1)
test_eq(clone((program)"/precompiled/regexp","^[^abc]$")->match("a"),0)
test_eq(clone((program)"/precompiled/regexp","^[^abc]$")->match("c"),0)
test_eq(clone((program)"/precompiled/regexp","^a*$")->match("aaaa"),1)
test_eq(clone((program)"/precompiled/regexp","^a|b$")->match("a"),1)
test_eq(clone((program)"/precompiled/regexp","^a|b$")->match("b"),1)

// regexp->split
test_equal(clone((program)"/precompiled/regexp","^(a*)[^a]*$")->split("aaabbb"),({"aaa"}))


// - Here we try the math module

// - tan
test_true(floatp(tan(0.5)))
test_eq(0.5,tan(atan(0.5)))
test_eq(0.5,atan(tan(0.5)))
// - asin
test_true(floatp(asin(0.7)))
test_eq(asin(0.0),0.0)
// - atan
test_true(floatp(atan(0.7)))
test_true(3.1415 < 4.0*atan(1.0))
test_true(3.1416 > 4.0*atan(1.0))
// - sin
test_true(floatp(sin(1.2)))
test_true(sin(atan(1.0))>0.707)
test_true(sin(atan(1.0))<0.708)
// - acos
test_true(acos(0.7) > 0.795)
test_true(acos(0.7) < 0.796)
// - cos
test_true(floatp(cos(1.2)))
test_true(cos(atan(1.0))>0.707)
test_true(cos(atan(1.0))<0.708)
// - sqrt
test_eq(4,sqrt(16))
test_eq(4,sqrt(17))
test_eq(4,sqrt(24))
test_eq(4.0,sqrt(16.0))
// - floor
test_eq(17.0,floor(17.0))
test_eq(17.0,floor(17.1))
test_eq(17.0,floor(17.7))
// - ceil
test_eq(17.0,ceil(17.0))
test_eq(18.0,ceil(17.1))
test_eq(18.0,ceil(17.7))
// - exp
// - log
test_true(2.70001>exp(log(2.7)))
test_true(2.69999<exp(log(2.7)))
test_true(2.70001>log(exp(2.7)))
test_true(2.69999<log(exp(2.7)))
// - pow
test_eq(pow(10.0,10.0),10000000000.0)

// foop
define(do_test_foop,[[
test_eq($1 (17), !($2))
test_eq($1 (1.7), !($2-1))
test_eq($1 ("17"), !($2-2))
test_eq($1 (this_object()), !($2-3))
test_eq($1 (a), !($2-4)) // a is the test function
test_eq($1 (({})), !($2-5))
test_eq($1 (([])), !($2-6))
test_eq($1 ((<>)), !($2-7))
test_eq($1 (object_program(this_object())), !($2-8))
]])

do_test_foop(intp,0)
do_test_foop(floatp,1)
do_test_foop(stringp,2)
do_test_foop(objectp,3)
do_test_foop(functionp,4)
do_test_foop(arrayp,5)
do_test_foop(mappingp,6)
do_test_foop(listp,7)
do_test_foop(programp,8)

// add_efun
test_do(add_efun("foobar",lambda() { return 1; }))
test_any([[
#if efun(foobar)
return 1;
#else
return 0;
#endif
]],1)
test_eq(foobar(),1)
test_do(add_efun("foobar"))
test_any([[
#if efun(foobar)
return 1;
#else
return 0;
#endif
]],0)

// - aggregate
test_true(arrayp(aggregate()))
test_eq(sizeof(aggregate()),0)
test_equal(aggregate(1,2,3,4),({1,2,3,4}))

// - aggregate_list
test_true(listp(aggregate_list()))

// - aggregate_mapping
test_true(listp(aggregate_list()))

// - all_efuns
test_true(mappingp(all_efuns()))
test_true(all_efuns()["all_efuns"])
test_eq(all_efuns()["all_efuns"],all_efuns)

// - allocate
test_true(arrayp(allocate(0)))
test_equal(allocate(2),({0,0}))
test_false(allocate(2)==({0,0}))

// - backtrace
test_true(arrayp(backtrace()))
test_eq(backtrace()[-1][2],a)

// - call_function
test_eq(1,call_function(a))
test_eq(1,call_function(lambda(int a){ return a; },1))
test_eq(1,call_function(intp,1))

// - capitalize
test_eq(capitalize("fubar"),"Fubar")
test_eq(capitalize("FooBar"),"FooBar")
test_eq(capitalize("-"),"-")

// - clone
// clone is already tested a lot by this script
test_true(objectp(clone(compile_string("int foo() { return 17; }"))))
test_eq(clone(compile_string("int foo() { return 17; }"))->foo(),17)

// - combine_path
test_eq([[combine_path("/foo/bar/gazonk/","..")]],"/foo/bar")
test_eq([[combine_path("/.../","sune")]],"/.../sune")
test_eq([[combine_path("/","foo/.../sune")]],"/foo/.../sune")
test_eq([[combine_path("/./foo/bar//gazonk/","../")]],"/foo/bar/")
test_eq([[combine_path("/","/foo/./bar/gazonk/..")]],"/foo/bar")
test_eq([[combine_path("/","/foo/bar/gazonk/../../")]],"/foo/")
test_eq([[combine_path("/","/foo//bar/gazonk/../..")]],"/foo")
test_eq([[combine_path("/","/foo/bar/./gazonk/../../..")]],"/")
test_eq([[combine_path("/","/foo/../bar//./gazonk/../..")]],"/")
test_eq([[combine_path("/","/foo/././/bar/gazonk/../../../..")]],"/")

// - compile_file
// FIXME: add tests for compile_file

// - compile_string
// see test for clone()

// - copy_value
test_eq(copy_value(1),1)
test_eq(copy_value(""),"")
test_eq(copy_value(1.0),1.0)
test_eq(copy_value(this_object()),this_object())
test_eq(copy_value(a),a)
define(do_test_copy_value,[[
test_any([[mixed x=$1; return x==x]],1)
test_any([[mixed x=$1; return copy_value(x)!=x]],1)
test_any([[mixed x=$1; return equal(copy_value(x),x)]],1)]])
do_test_copy_value( ({1}) )
do_test_copy_value( ([]) )
do_test_copy_value( (<>) )
do_test_copy_value( (< ([]), ({1}) ,"" , 1.0 >) )

// - crypt
test_true(stringp(crypt("hej")))
test_true(crypt("hej",crypt("hej")))

// - ctime
test_true(stringp(ctime(0)))

// - destruct
// FIXME put tests for destruct here.

// - equal
// equl is already tested by this script

// - exit
// FIXME put test for exit here

// - explode
test_equal(({"a","b","c",}), explode("anna bnna c","nna "))
test_equal(({"","",}),explode("hej","hej"))
test_equal(({"",}),explode("","hej"))

// - fork()
// FIXME: add tests for fork

// - function_name
test_eq(function_name(a),"a")
test_eq(function_name(function_name),0)

// - function_object
test_eq(function_object(a),this_object())
test_eq(function_name(function_object),0)

// - get_function (actually in simulate.lpc)
test_eq(a,get_function(this_object(),"a"))
test_eq(a,this_object()->a)

// - hash
test_true(intp(hash("foo")))
test_true(intp(hash("foo",10)))
test_true(hash("foo",10)<10)
test_true(hash("bar",10)<10)
test_true(hash("gazonk",10)<10)
test_eq(hash("foobargazonk"),hash("foobargazonk"))

// - implode
test_eq([[implode(({}),"")]],"")
test_eq([[implode(explode("foo","o"),"o")]],"foo")
test_eq([[implode(({"foo","bar"}),"-")]],"foo-bar")
test_eq([[implode(({"foo",0,"bar"}),"-")]],"foo-bar")
test_eq([[implode(({1.0,"foo",0,"bar",this_object(),([])}),"-")]],"foo-bar")
test_eq([[implode(({"f","o","o"}))]],"foo")

// - indices
test_equal(indices("foo"),({0,1,2}))
test_equal(indices(({'f','o','o'})),({0,1,2}))
test_equal(sort_array(indices(([7:3,8:9,99:12]))),({7,8,99}))
test_equal(sort_array(indices((<7,8,99>))),({7,8,99}))

// - lower_case
test_equal(lower_case("foo"),"foo")
test_equal(lower_case("Foo"),"foo")
test_equal(lower_case("Foo1234-*~\n"),"foo1234-*~\n")

// - next_object
test_true(objectp(next_object()))
test_any(int e;object o=next_object(); for(e=0;e<1000 && o;e++) o=next_object(o); return o,0)

// - object_program
test_true(programp(object_program(this_object())))

// - query_host_name
test_true(stringp(query_host_name()))

// - query_num_arg
test_eq(lambda(int ... q) { return query_num_arg(); }(),0)
test_eq(lambda(int ... q) { return query_num_arg(); }(1),1)
test_eq(lambda(int ... q) { return query_num_arg(); }(1,1),2)
test_eq(lambda(int ... q) { return query_num_arg(); }(1,1,1),3)
test_eq(lambda(int ... q) { return query_num_arg(); }(1,1,1,1),4)

// - random
test_any([[int e,d;for(e=0;e<1000;e++){d=random(10); if(d<0 || d>=10) return 0;} return 1]],1)

// - replace
test_eq(replace("foobargazonk","o","-"),"f--bargaz-nk")
test_eq(replace("foobargazonk",({"o","a"}),({"()","<>"})),"f()()b<>rg<>z()nk")
test_eq(replace("f--barf--",({"f--","f--bar"}),({"f--bar","f--"})),"f--f--bar")
test_eq(replace("f--barf--",({"f--bar","f--"}),({"f--","f--bar"})),"f--f--bar")
test_equal(replace(({1,2,3,4,5,1,2,3,4}),3,-1),({1,2,-1,4,5,1,2,-1,4}))
test_equal(replace(([1:2,3:4,5:1,2:3]),3,-1),([1:2,3:4,5:1,2:-1]))

// - reverse
test_eq(reverse("reverse"),"esrever")
test_eq(reverse(""),"")
test_eq(reverse("a"),"a")
test_equal(reverse(({1,5,9})),({9,5,1}))
test_equal(reverse(0x12345678),0x1e6a2c48)

// - rusage
test_true(arrayp(rusage()))
test_true(sizeof(rusage())>0)

// - search
test_eq(search("foolbar","gazonk"),-1)
test_eq(search("qowiueproqiuweproiwqueoplkjljlklksjjriwueproiuwerowieu","lkjljlklksjj"),24)
test_eq(search("lkjljlklksjjriwueproiuwerlskjdvlaskjfowieu","lkjljlklksjj"),0)
test_eq(search("aaaaaaaaaaaaaaaaaaaaaaaalkjljlklksjj","lkjljlklksjj"),24)
test_eq(search("foobargazonk","oo"),1)
test_eq(search("foobargazonk","o",3),9)
test_eq(search("foobargazonk","o",9),9)
test_eq(search("foobargazonk","o",10),-1)
test_eq(search("foobargazonk","x",9),-1)
test_eq(search(({56,8,2,6,2,7,3,56,7}),8),1)
test_eq(search(({56,8,2,6,2,7,3,56,7}),56,0),0)
test_eq(search(({56,8,2,6,2,7,3,56,7}),56,1),7)
test_eq(search(({56,8,2,6,2,7,3,56,7}),56,7),7)
test_eq(search(({56,8,2,6,2,7,3,56,7}),56,8),-1)
test_eq(search(({"foo"}),"foo"),0)
test_eq(search("fo-obar|gazonk"/"|","fo-obar"),0)
test_eq(search("fo-obar|gazonk"/"|","gazonk"),1)
test_eq(search(([1:2,3:4,5:6,7:8]),4),3)
test_true(zero_type(search(([1:2,3:4,5:6,7:8]),1)))
test_eq(search(([1:2,3:4,5:6,7:8]),8),7)

// test large searches (find string, size, pattern)
define(test_search,[[
test_eq(search(sprintf($1+"%'"+$3+"'*n",$2),$1),0)
test_eq(search(sprintf("%'"+$3+"'*n" ,$2),$1),-1)
test_eq(search(sprintf("%'"+$3+"'*n"+$1,$2),$1),$2)
test_eq(search(sprintf("%'"+$3+"'*n"+$1+"%'"+$3+"'*n",$2,$2),$1),$2)
]])

define(test_search2,[[dnl
test_search($1,$2,$3)
test_search($1,$2+1,$3)
test_search($1,$2+2,$3)
test_search($1,$2+3,$3)
]])

define(test_search3,[[dnl
test_search2($1,10,$2)
test_search2($1,1000,$2)
test_search2($1,100000,$2)
]])

define(test_search4,[[dnl
test_search3($1,"+-*")
test_search3($1,($1[0..strlen($1)-2]))
test_search3($1,($1[1..0x7fffffff]))
]])

test_search4("SUNE")
test_search4("-------------------+")
test_search4("+-------------------")
test_search4(sprintf("%'argel-bargel glop-glyf?'2000n"))

// - sizeof
test_eq(sizeof("felbar"),6)
test_eq(sizeof(({"fulbar","gazonk",7})),3)
test_eq(sizeof(([8:3,6:6,7:0])),3)
test_eq(sizeof((<8,7,6,5,4,7>)),6)

// - sum
test_eq(sum(1,1),2)
test_eq(sum(1,-2),-1)
test_eq(sum(-2,-2),-4)
test_eq(sum("hi","there"),"hithere")
test_eq(sum("human","number",666),"humannumber666")
test_eq(sum("human","number",666),"humannumber666")
test_eq(sum("human","number",666),"humannumber666")
test_eq(sum("human","number",666,111),"humannumber666111")
test_eq(sum("humannumber",sum(666+111)),"humannumber777")
test_eq(sum("a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","x","y"),"abcdefghijklmnopqrstuvxy")
test_eq(sum(1.0+1.0),2.0)
test_eq(sum(1.0,-1.0),0.0)
test_eq(sum(-1.0,-1.0),-2.0)
test_equal(sum(({1,2,3}),({4,5,6})),({1,2,3,4,5,6}))
test_equal(sum((<1,2,3,4>),(<4,5,6>)),(<1,2,3,4,4,5,6>))
test_equal(sum(([0:1,3:6]),([5:2,3:6])),([0:1,3:6,3:6,5:2]))

// - this_object
test_true(objectp(this_object()))

// - throw
test_eq(20,catch(throw(a())))

// - time
test_true(intp(time()))

// - trace
test_do(trace(0))
test_eq(trace(0),0)

// - upper_case
test_equal(upper_case("fooq"),"FOOQ")
test_equal(upper_case("FooR"),"FOOR")
test_equal(upper_case("Foo1234-*~\n"),"FOO1234-*~\n")

// - values
test_equal(values("foo"),({'f','o','o'}))
test_equal(values(({'f','o','o'})),({'f','o','o'}))
test_equal(sort_array(values(([7:3,8:9,99:12]))),({3,9,12}))
test_equal(values((<7,8,99>)),({1,1,1}))

// - zero_type
test_eq(zero_type(0),0)
test_eq(zero_type(([])[7]),1)

// - call_out, call_out_info, remove_call_out, find_call_out
test_do(call_out(a,100000))
test_true(arrayp(call_out_info()))
test_true(sizeof(call_out_info()) > 0)
test_true(call_out_info()[-1][0] > 1)
test_eq(find_call_out(call_out_info()[-1][2]), call_out_info()[-1][0])
test_eq(find_call_out(a),-1)
test_true(zero_type(find_call_out(a)))
test_do(remove_call_out(call_out_info()[-1][2]))
test_true(!sizeof(call_out_info()) || function_name(call_out_info()[-1][2])!="a")

// m_delete
test_equal(([1:1]),m_delete(a(),0))
test_equal(([1:1]),m_delete(([1:1,0:3]),0))
test_any(mapping a=([1:1]); return a==m_delete(a,1),1)

test_program(int b=10; mixed a() { return 1; })
test_program(mixed b=10; mixed a() { return 1;})
test_define_program(/test,[[int q,w,e,r,t; mixed foo() { return 10; }]])

test_program(inherit "/test"; mixed a() { return foo()==10; })
test_program(inherit "/test"; mixed a() { return test::foo()==10; })
test_program(inherit "/test" : bar; mixed a() { return bar::foo()==10; })

test_define_program(/test2,[[int z,x,c,v,b; mixed bar() { return 11; }]])
test_program(inherit "/test"; inherit "/test2"; mixed a() { return foo()==10 && bar()==11; })
test_program(inherit "/test2"; inherit "/test"; mixed a() { return foo()==10 && bar()==11; })

test_define_program(/test,[[int q,w,e,r; mixed t; mixed getw() { return w; } void setw(int _) { w=_; }]])
test_define_program(/test2,[[int z,x,c,v,b; mixed getb() { return b; } void setb(int _) { b=_; }]])

test_program(inherit "/test"; inherit "/test2"; mixed a() { w=20; b=22; return getw()==20 && getb()==22; })
test_program(inherit "/test"; inherit "/test2"; mixed a() { setw(20); setb(22); return w==20 && b==22; })
test_program(inherit "/test2"; inherit "/test"; mixed a() { w=20; b=22; return getw()==20 && getb()==22; })
test_program(inherit "/test2"; inherit "/test"; mixed a() { setw(20); setb(22); return w==20 && b==22; })


  });

  for(e=start;e<sizeof(tests);e++)
  {
    string test;
    int type;
    object o;
    mixed a,b;

    test=tests[e];
    type=test[0];
    test=test[1..strlen(test)-1];

    if(verbose)
    {
      perror("Doing test "+(e+1)+"\n");
      if(verbose>1)
	perror(test+"\n");
    }

    switch(type)
    {
    case 'c':
      master()->set_inhibit_compile_errors(1);
      if(catch(compile_string(test,"Test "+(e+1))))
      {
	successes++;
      }else{
	perror("Test "+(e+1)+" failed.\n");
	perror(test+"\n");
	errors++;
      }
      master()->set_inhibit_compile_errors(0);
      break;

    case 'E':
      master()->set_inhibit_compile_errors(1);
      if(catch(clone(compile_string(test,"Test "+(e+1)))->a()))
      {
	successes++;
      }else{
	perror("Test "+(e+1)+" failed.\n");
	perror(test+"\n");
	errors++;
      }
      master()->set_inhibit_compile_errors(0);
      break;

    default:
      o=clone(compile_string(test,"Test "+(e+1)));

      if(t) trace(t);
      a=b=0;
      if(functionp(o->a)) a=o->a();
      if(functionp(o->b)) b=o->b();
      if(t) trace(0);
      switch(type)
      {
      case 'P':
	b=compile_string(b,"Test "+(e+1));
	master()->add_precompiled_program(a,b);
	successes++;
	break;

      case 'f':
	a=!a;
	
      case 't':
	if(!a)
	{
	  perror("Test "+(e+1)+" failed.\n");
	  perror(test+"\n");
	  errors++;
	}else{
	  successes++;
	}
	break;

      case 'd':
	successes++;
	break;

      case '=':
	if(a!=b)
	{
	  perror("Test "+(e+1)+" failed.\n");
	  perror(test+"\n");
	  perror(sprintf("o->a(): %O\n",a));
	  perror(sprintf("o->b(): %O\n",b));
	  errors++;
	}else{
	  successes++;
	}
	break;
      
      case 'e':
	if(!equal(a,b))
	{
	  perror("Test "+(e+1)+" failed.\n");
          perror(test+"\n");
	  perror(sprintf("o->a(): %O\n",a));
	  perror(sprintf("o->b(): %O\n",b));
	  errors++;
	}else{
	  successes++;
	}
	break;

      default:
	perror("Unknown test type.\n");
	errors++;
      }
    }
    if(fail && errors)
      exit(1);
  }

  if(errors + successes != sizeof(tests))
  {
    perror("Errors + Successes != number of tests!\n");
    errors++;
  }
  if(errors || verbose)
  {
    perror("Failed tests: "+errors+".\n");
  }

  return errors;
}

EOTESTS
